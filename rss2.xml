<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Aaron Lin</title>
    <link>https://aaronlinv.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 21 Nov 2019 16:20:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>我理解的前端</title>
      <link>https://aaronlinv.github.io/2019/11/20/front-end/</link>
      <guid>https://aaronlinv.github.io/2019/11/20/front-end/</guid>
      <pubDate>Wed, 20 Nov 2019 15:30:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;故事开始&quot;&gt;&lt;a href=&quot;#故事开始&quot; class=&quot;headerlink&quot; title=&quot;故事开始&quot;&gt;&lt;/a&gt;故事开始&lt;/h2&gt;&lt;p&gt;这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家</p><p>也是因为这个契机，我开始了解前端，通过这段时间的学习，我对前端有了更为具体的认识。</p><p>数据库老师应该是我遇到最好的专业课老师，他讲的课融入了很多他自己的项目实践经验，他平易近人，很乐意并且有能力解决我们的问题，也鼓励我们主动学习。基本上每个老师都在提倡主动学习，但是真正愿意花时间引导学生去主动学习的老师少之又少</p><h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>在我看刚开始尝试去了解前端的时候，这些资料对我理解前端有很大帮助，所以强烈推荐你也看看，或许有不同的收获</p><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a></p><h2 id="前端是做什么的"><a href="#前端是做什么的" class="headerlink" title="前端是做什么的"></a>前端是做什么的</h2><p>前端主要的两个重点</p><ul><li>界面展示</li><li>用户交互</li></ul><p>看到的一个例子比较形象：如果把网页比喻成汽车，那么前端就是看得见摸得着的内饰、方向盘、油门、刹车，而不容易直接看见但对汽车也很重要的则是后端，比如引擎</p><h2 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h2><p>既然提到网页，那就不得不说说浏览器，浏览器有两种引擎</p><p><img src="/2019/11/20/front-end/1.png" alt="浏览器引擎"></p><p><img src="/2019/11/20/front-end/2.png" alt="浏览器引擎介绍"></p><p>渲染引擎：负责渲染网页的HTML和CSS，随着JS解释引擎越来越独立，现在一般也把渲染引擎称为<strong>浏览器内核</strong></p><p>比较值得一提的是：苹果的Webkit是开源的，谷歌的Blink是Webkit的分支，但可能是谷歌Chrome浏览器市场占有率比较高，很多人会误以为Webkit是Chrome的内核</p><p>Chromium：是谷歌的一个开源项目（Chromium相当于Chrome的工程版），国内的QQ浏览器、360极速浏览器、搜狗浏览器还有微软新推出的Edge都是基于这个项目开发的</p><p><img src="/2019/11/20/front-end/3.png" alt="JS解释引擎"><br>JS解释引擎：负责解释网页的Javascript，不同的浏览器使用的JS解释引擎也不尽相同，这里先提一下大名鼎鼎的 <strong>Chrome V8</strong> </p><h2 id="前端发展"><a href="#前端发展" class="headerlink" title="前端发展"></a>前端发展</h2><p>不同的参考资料会把前端划分成几个不同的阶段，这里我也简单分了几个阶段，可能不太准确，但是希望能帮助你大概梳理前端的发展过程</p><ul><li>静态页面配合Jsp等服务端混合开发</li><li>Ajax JQuery等技术诞生</li><li>前端框架</li></ul><h2 id="静态页面配合Jsp等服务端混合开发"><a href="#静态页面配合Jsp等服务端混合开发" class="headerlink" title="静态页面配合Jsp等服务端混合开发"></a>静态页面配合Jsp等服务端混合开发</h2><p>最开始的网页都是静态的，使用前端三大基础技术（HTML+CSS+JavaScript）开发，但是随着时代的发展，静态网页不能满足需求，网站需要为不同用户显示不同的网页内容</p><p>这个时候就需要动态网页，就有了Jsp( Java Server Pages )这类技术，可以对不同的用户动态生成不同的网页，它的原理就是在传统的网页HTML文件中插入Java程序段和JSP标记</p><p>虽然可以实现动态页面，但是这项技术也有很明显的缺点，就是在前后端都写好各自的代码之后需要将JSP代码插入到HTML，这就要求整合代码的工程师比必须前后端都懂，而且前后端代码杂糅在一起，也不利于维护</p><h2 id="Ajax-JQuery等技术诞生"><a href="#Ajax-JQuery等技术诞生" class="headerlink" title="Ajax JQuery等技术诞生"></a>Ajax JQuery等技术诞生</h2><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>Ajax使得不需要刷新网页，就可以实现网页部分内容的更新，最常见的例子就是各种网页划到最后，网页会继续加载后面的内容，而这个过程，网页没有刷新</p><p>Ajax的出现，可以让前后端工程师以Ajax接口为分界点进行前后端分离，根据规定好的交互接口，分头工作</p><h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><p>JQuery是一套JavaScript的库，简化了JavaScript开发的复杂性</p><p>简化了原生JavaScript代码，举个例获取id为content的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).value　　　　　　　　　　</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery：</span></span><br><span class="line">$(<span class="string">'# content'</span>).val()</span><br></pre></td></tr></table></figure><p>同时JQuery也屏蔽了浏览器兼容性问题。在IE678的时代，不同浏览器存在很多兼容问题，其中IE就不识别很多标准的JavaScript方法和对象。但是JQuery屏蔽了这些问题，开发者可以用JQuery开发而不用考虑兼容问题</p><p>JQuery还允许开发者定制插件，大量优秀的jQuery插件与UI库不断涌现，使得前端开发者可以直接使用这些插件进行开发，极大提高的开发效率，就比如下面的全屏滚动插件 fullPage.js 和粒子插件，点击图片可以访问对应网站</p><p><a href="https://alvarotrigo.com/fullPage/zh/#page1" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/4.png" alt="fullPage.js"></a></p><p><a href="https://vincentgarreau.com/particles.js" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/5.png" alt="particle.js"></a></p><h4 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h4><p>2008年Google丹麦开发了 <strong>Chrome V8</strong> ，把JavaScript编译成机器码，还使用了其他方法提高性能，使得JavaScript在V8引擎下运行速度非常快，可以媲美二进制程序</p><p>有一个组织：Node，发现既然V8运行效率这么高，那么有没有其他的可能呢，所以他们基于 Chrome V8 引擎，加入系统级API，开发了Node.js，这是一个 JavaScript 运行环境</p><p>Noce.js的本质：允许开发者像使用C 或者C++那样程序去使用JS程序，性能还差不多，至此JavaScript已经不仅仅只局限在写网页特性了，还可以写服务器、虚拟机内核等等的，开发者就可以借助node开发各种自动化工具</p><p>2010年10月，Google推出 Angular JS ，这是一款 JavaScript 框架，用来开发浏览器应用，但是 Angular JS缺陷挺多，所以谷歌后来推出 Angular 框架(这两个是独立的产品)</p><p>基于 Angular 思路成功 就有了 Vue 和 React ，就有了前端框架三足鼎立的局面。前端工程师就可以组件化开发模式利用了JS的智能可编程性来管理HTML和CSS<br>工程文件结构</p><p>有了 node ，我可以调用操作系统的资源，我们就可以规定一些语法和文件，就像定义一些模板，让 node 帮我们去生成 HTML ,CSS 和JavaScript ，我们就可以不必去写这些代码，代码管理性、可复用性、工程性就越来越好</p><h4 id="不一样的JavaScript"><a href="#不一样的JavaScript" class="headerlink" title="不一样的JavaScript"></a>不一样的JavaScript</h4><p>在了解前端的发展之前，我对于 JavaScript 的理解还停留在只能写写网页特效的层面，但是现在我才意识到得益于 Chrome V8 和Node ，使得 JavaScript 展现出不一样的活力，可以用来写服务器、内核，还有各种跨平台的应用</p><p>Cordova：Adobe 发起的项目原名叫 PhoneGap，后来贡献给 Apache 基金会，<br>Cordova是一个框架，允许开发者用 HTML ,CSS 和JavaScript 开发可以跨平台在安卓,IOS,Windows上的程序</p><p>Electron：允许开发者用 HTML ,CSS 和JavaScript 开发运行在Windows,Linux,Mac 上的程序。VScode ,微信Linux , Atom , Github客户端都使用这个框架开发</p><p><img src="/2019/11/20/front-end/6.png" alt="VScdoe"><br><img src="/2019/11/20/front-end/7.png" alt="WeChat"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a><br><a href="https://www.bilibili.com/video/av52669035​" target="_blank" rel="noopener">WEB前端——浏览器内核 </a><br><a href="https://cloud.tencent.com/developer/article/1333686​" target="_blank" rel="noopener">web的发展</a><br><a href="https://www.bilibili.com/video/av61920847/" target="_blank" rel="noopener">【网页设计】30年发展史1990-2019 （中英字幕1080P）​</a><br><a href="https://zhuanlan.zhihu.com/p/84054729​" target="_blank" rel="noopener">erverless——前端的3.0时代 </a><br><a href="https://segmentfault.com/a/1190000016269636" target="_blank" rel="noopener">《从零构建前后分离web项目》：开篇 - 纵观WEB历史演变 </a><br><a href="https://cloud.tencent.com/developer/article/1028964​" target="_blank" rel="noopener">学前端，我们要学的是什么 </a><br><a href="https://www.bilibili.com/video/av27151150" target="_blank" rel="noopener">【WEB全能课】第一讲：初识前端  </a><br><a href="https://juejin.im/post/58ed0a938d6d8100580a45b0​" target="_blank" rel="noopener">Web简史 </a><br><a href="https://www.zhihu.com/question/21923056/answer/804820546​​​" target="_blank" rel="noopener">到底什么是前端、后端、后台啊？ - 科普小民工的回答 - 知乎 </a><br><a href="https://zhuanlan.zhihu.com/p/68030183​" target="_blank" rel="noopener">前端开发 20 年变迁史 </a><br><a href="https://www.itsource.cn/web/news/1892.html​" target="_blank" rel="noopener">程序员和准程序员必看：Web技术的发展历史和未来趋势  </a><br><a href="https://zhuanlan.zhihu.com/p/30704540​" target="_blank" rel="noopener">Query真的过时了! </a><br><a href="https://www.cnblogs.com/leftJS/p/11073481.html​" target="_blank" rel="noopener">MD、CMD规范 </a><br><a href="https://www.uisdc.com/brief-history-of-web-design" target="_blank" rel="noopener">涨姿势！写给网页设计师的网页设计简史 </a><br><a href="https://www.zhihu.com/question/304757674/answer/546374749" target="_blank" rel="noopener">前端三大框架以及jquery与bootstrap这种框架有什么（概念上、范畴上的）区别？ - 陈龙的回答 - 知乎</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/11/20/front-end/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop大数据平台搭建</title>
      <link>https://aaronlinv.github.io/2019/11/08/big-data/</link>
      <guid>https://aaronlinv.github.io/2019/11/08/big-data/</guid>
      <pubDate>Fri, 08 Nov 2019 04:16:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在网上看到的一张图片，很真实的描述了学习大数据前后对大数据的看法 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/08/big-dat
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在网上看到的一张图片，很真实的描述了学习大数据前后对大数据的看法 </p><p><img src="/2019/11/08/big-data/1.jpg" alt="大数据"></p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li>大数据</li></ul><blockquote><p> 维基的解释是在传统数据处理应用软件不足以处理的大或复杂的数据集</p><p>大数据有四个特点(4个” V “)：数据量大(Volume)、数据类型繁多(Variety)、处理速度快(Velocity)、价值密度低(Value)</p><p>我自己的理解就是在以前对很多数据没有办法进行筛选、存储、分析等操作，但随着技术的发展，现在有很多技术可以完成这些工作，从而使得我们可以得到很多蕴含在这些数据之间的信息。例如网购的订单，最开始电商平台可能只能存储这些订单信息，还没有进行分析，随着技术的发展，就可以分析这些订单之间的联系，从而实现针对性的商品推荐等功能</p></blockquote><ul><li>云计算</li></ul><blockquote><p>通过网络提供可伸缩的、廉价的分布式计算能力。云计算使得计算资源像自来水一样，可以方便取用。有这几种服务类型</p></blockquote><blockquote><p>基础设施即服务 IaaS (Infrastructure as a Service) 提供了基础设施，CPU、内存、网络、存储等，客户需要自己配置环境，然后运行自己的服务</p><p>平台即服务 PasS (Platform as a Service) 提供了服务器平台或者开发环境，客户可以在这个平台上部署自己的服务</p><p>软件即服务 SaaS (Software as a Service) 提供的就是软件成品，客户可以按需购买，就像购买一些邮件服务，即开即用，不需要关心它运行在什么平台或者是运行在什么硬件上</p></blockquote><ul><li>物联网</li></ul><blockquote><p>利用通信技术把传感器、机器、控制器、人员、物连接在一起，实现彼此间的通信、收集和传输数据。最常见的应用就是一些智能可穿戴设备、智能家居、智能交通</p></blockquote><ul><li>相互的联系</li></ul><blockquote><p>大数据、云计算、物联网之间既有区别也有联系<br>云计算为大数据提供了技术基础<br>物联网是大数据的重要来源</p></blockquote><h2 id="Hadoop开源分布计算式计算平台"><a href="#Hadoop开源分布计算式计算平台" class="headerlink" title="Hadoop开源分布计算式计算平台"></a>Hadoop开源分布计算式计算平台</h2><p>Hadoop是Apache软件基金会旗下的一个开源分布计算式计算平台，Hadoop的核心是HDFS(Hadoop Distributed File System)和MapReduce</p><p>HDFS是面向普通硬件环境的分布式文件系统，MapReduce是开发并行应用的程序</p><h2 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h2><p>我是参考厦门大学林子雨老师的<a href="http://dblab.xmu.edu.cn/blog/285/" target="_blank" rel="noopener">大数据处理架构Hadoop安装教程</a>，这个教程提供了多种不同安装方式的详细指导</p><p>我选择的是VMware虚拟机中安装Ubuntu，伪分布式安装Hadoop2.7.1，建议使用这个教程提供的系统和各种软件，遇到需要输入或者起名的步骤尽量和教程保持一致，这样可以规避一些奇奇怪怪的问题。在学习一个技术的初期，如果因为软件配置、兼容性等问题而浪费大量时间会非常闹心</p><p>解压Hadoop后，如果是是单机模式，无需配置，直接开始使用就好了。如果选择伪分布式，需要配置core-site.xml和hdfs-site.xml即可，需要特别注意的是：配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。同时也指定 dfs.namenode.name.dir 和dfs.datanode.data.dir 避免出错。</p><p>配置好后就要格式化NameNode(在Hadoop目录下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format <span class="comment">#格式化NameNode</span></span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/big-data/2.png" alt="Namenode format"></p><p>看到 successfully formatted 和 Exitting with status 0 就表示格式化成功，然后可以启动所有进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-all.sh <span class="comment">#启动所有进程</span></span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/big-data/3.png" alt="star-all.sh"></p><p>进程启动后可以用jps来查看所有的Java进程，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>如果没有这些进程，可以尝试先停止所有进程，然后再启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-all.sh <span class="comment">#先执行关闭所有进程</span></span><br><span class="line"></span><br><span class="line">./sbin/stop-all.sh <span class="comment">#所有进程都关闭后，再启动所有进程</span></span><br></pre></td></tr></table></figure><h2 id="HDFS-Shell命令"><a href="#HDFS-Shell命令" class="headerlink" title="HDFS Shell命令"></a>HDFS Shell命令</h2><p>HDFS是一个分布式文件系统，所以我们可以对HDFS中的文件进行上传、下载、复制等文件操作。可以用shell命名完成这些操作</p><p>对于文件操作这个功能，HDFS有三种命令标记，如果用来操作HDFS这三中貌似用起来是一模一样的</p><ul><li>hadoop fs  适用于本地系统和HDFS系统</li><li>hadoop dfs 只能操作HDFS文件系统，已经Deprecated(不推荐使用)，推荐使用第三个hdfs dfs</li><li>hdfs dfs 只能操作HDFS文件系统</li></ul><p>实际上很多命令和Linux的shell差不多，不过要注意格式，用ls(显示目录下的文件信息)命令举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls / <span class="comment">#这里用hdfs dfs 用其他两个效果是一样的</span></span><br></pre></td></tr></table></figure><blockquote><p>命令前面一定要加- 如：-ls</p></blockquote><blockquote><p>命令之后一定要指定目录 如：/     (左斜杆就是代表HDFS目录的根)</p></blockquote><p>例举一些常用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls / <span class="comment">#ls 查看更目录下的文件信息</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –mkdir –p /user/hadoop <span class="comment">#mkdir 新建文件夹 -p 递归操作</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –rm –r /input <span class="comment">#rm 删除目录 -r 递归删除</span></span><br><span class="line"></span><br><span class="line">hdfs dfs -cp /myLocalFile.txt /user/hadoop/ <span class="comment">#cp 在HDFS复制文件 复制根目录下的myLocalFile.txt到/user/hadoop/</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –cat /myLocalFile.txt <span class="comment"># cat 查看文件内容 </span></span><br><span class="line"></span><br><span class="line">hdfs dfs -put /home/hadoop/myLocalFile.txt  / <span class="comment">#put 上传文件到HDFS 将本地的myLocalFile.txt文件上传到HDFS的根目录下</span></span><br><span class="line">hdfs dfs -put /home/hadoop/myLocalFile.txt  /test.txt <span class="comment">#将本地的myLocalFile.txt文件上传到HDFS的根目录下,并且重命名为test.txt</span></span><br><span class="line"></span><br><span class="line">hdfs dfs -get /myLocalFile.txt  /home/hadoop/ <span class="comment"># get 下载文件到本地 下载HDFS根目录下的myLocalFile.txt文件到本地的/home/hadoop/</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">IaaS，PaaS，SaaS 的区别 作者： 阮一峰</a></p><p> <a href="https://www.zhihu.com/question/19751763" target="_blank" rel="noopener">什么是物联网？其发展前景如何？</a></p><p> <a href="http://dblab.xmu.edu.cn/blog/install-hadoop-in-centos/" target="_blank" rel="noopener">Hadoop安装教程_伪分布式配置_CentOS6.4/Hadoop2.6.0</a></p><p> <a href="https://blog.csdn.net/pipisorry/article/details/51340838" target="_blank" rel="noopener">Hadoop：hadoop fs、hadoop dfs与hdfs dfs命令的区别</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/11/08/big-data/#disqus_thread</comments>
    </item>
    
    <item>
      <title>爬虫是咋回事</title>
      <link>https://aaronlinv.github.io/2019/10/31/python-web-spider/</link>
      <guid>https://aaronlinv.github.io/2019/10/31/python-web-spider/</guid>
      <pubDate>Thu, 31 Oct 2019 08:46:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前零零碎碎接触过几次爬虫，有的是公开课，有的是实体课。老师都是偏实践，对于理论的部分都是一笔带过，所以对于那些库都是一知半解。自己也想写一
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前零零碎碎接触过几次爬虫，有的是公开课，有的是实体课。老师都是偏实践，对于理论的部分都是一笔带过，所以对于那些库都是一知半解。自己也想写一些东西，尽可能在吸收那些大佬的总结的同时，加入一些自己的理解。把大佬一越而过，而我们要挣扎很久的坑铺平。</p><p>这样学的知识更像是一盘散沙，我会简单地使用这些函数去实现一些功能，但却不清楚它们之间的关系，遇到一些复杂的问题就很难去处理。系统地学习虽然比较耗时，但是会对整个体系有个了解，而这在你遇到一些问题的时候会发挥重要作用。</p><p>网上教程的质量参差不齐，而且代码案例爬取的网站的结构也可能随着时间的推移而改变，对于初学者来说是个不小的挑战。</p><p>我看的是嵩天老师的<a href="https://www.icourse163.org/learn/BIT-1001870001" target="_blank" rel="noopener">Python网络爬虫与信息提取</a>，嵩天老师讲的比较通俗易懂，不需要有特别扎实的Python基础也能听懂。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>爬取网页，程序没有反应：可能是网络连接问题，可以用通用代码架构来提高爬虫的可靠性</li><li>F12开发者工具-Network选项卡里可以看的文本但是爬取的文本却没有：网站防爬机制，可以定义Headers,Cookie等解决</li></ul><h2 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h2><p>对于非异步加载的网站，一般都可以通过requests库和BeautifulSoup库爬取信息</p><ol><li>获取网页的源代码：通过Requests库，来获取网页的HTML代码</li><li>解析网页代码获得期望的数据：通过BeautifulSoup库解析网页源代码，把我们需要的信息按照一定规则提取出来<h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2>requests库有7个主要方法，后6个方法都是对request方法的封装（使用更方便）</li></ol><p><img src="/2019/10/31/python-web-spider/1.png" alt="嵩天"></p><p>6个方法对应的就是HTTP协议对资源的操作</p><p><img src="/2019/10/31/python-web-spider/2.png" alt="嵩天"></p><p>HTTP请求状态：status_code 200表示成功，返回其他值说明连接出现问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url) <span class="comment">#url传入爬取的网址</span></span><br><span class="line">print(r.status_code)  <span class="comment">#200表示连接成功</span></span><br></pre></td></tr></table></figure><p>爬虫通用框架：网络连接可能出现各种异常，所以我们可以用try-except处理异常，增强代码可靠性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，用于获得网页源代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>) <span class="comment"># 设置超时时间为30毫秒</span></span><br><span class="line">        r.raise_for_status() <span class="comment"># 这个方法就是判断status_code是否为200，否的话引发HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text <span class="comment"># 返回爬取到的文本</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure><p>编码：如果header没有chartset指定编码，默认就是ISO-8859-1，这个编码不能解析中文，可能会出现乱码，而apparent_encoding会根据内容猜测编码，所以我们一般把编码设置为apparent_encoding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.encoding = r.apparent_encoding</span><br></pre></td></tr></table></figure><h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>BeautifulSoup使用pip安装要注意，如果没有加末尾的4，实际安装的是BeautifulSoup3 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip insatll beautifulsoup4</span><br></pre></td></tr></table></figure><p>在import的时候也要注意，从bs4库(beautifulsoup4)中引入BeautifulSoup这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#注意B和S是大写</span></span><br></pre></td></tr></table></figure><p>创建一个BeautifulSoup对象，传入的一个参数是需要解析的HTML或者XML文档，第二个参数是使用的解析器，这里需要lxml，需要安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><p>BeautifulSoup类的基本元素：</p><ul><li>Tag：标签，HTML中由&lt;&gt;和&lt;/&gt;构成的那些标签</li><li>Name：就是标签的名字，a标签、p标签</li><li>Attributes：标签的属性</li><li>NavigableString：标签的&lt;&gt;和&lt;/&gt;之间的文字</li><li>Comment：HTML中的注释 </li></ul><p>爬取数据需要先找到数据对应Tag标签，而Name,Attributes,NavigableString,Comment就是围绕着Tag标签，Comment相对来说用的少</p><p>HTML标签树遍历：</p><ul><li>下行遍历：.contents  .children  .descendants</li><li>上行遍历：.parent  .parents</li><li>平行遍历：.next_sibling  .next_siblings  .previous_sibling  .previous_sibling</li></ul><p>有复数含义的属性返回的都是列表，而像.parent .next_sibling  .previous_sibling 这些都是返回一个Tag标签节点 &lt;class ‘bs4.element.Tag’&gt; 或者是一个字符串节点（有可能是\n）,在遍历这些列表的时候如果没有判断类型，使用的时候可能会报错</p><blockquote><p>TypeError: ‘NavigableString’ object is not callable</p></blockquote><p>find_all( )方法：</p><ul><li>可检索标签名、标签属性、标签内的字符串，返回一个列表</li><li>还有find( ),find_parent( ),find_parents( )等方法</li><li>因为dind_all比较常用，所以对象是Tag或者是soup都可以省略find_all,<tag>find_all(…)等价于<tag>(…),soup.find_all(..)等价于soup(…)<h2 id="爬取大学排名实例"><a href="#爬取大学排名实例" class="headerlink" title="爬取大学排名实例"></a>爬取大学排名实例</h2>爬取最好大学网的大学排名数据，将排名、学校名称、地区输出到屏幕</tag></tag></li></ul><p><img src="/2019/10/31/python-web-spider/3.png" alt="爬取大学排名效果"></p><h3 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul><li>遍历每个tr获取每个大学信息，出现object is not callable</li><li>输出到屏幕排版问题</li></ul><h3 id="分析网页结构"><a href="#分析网页结构" class="headerlink" title="分析网页结构"></a>分析网页结构</h3><p>Chrome浏览器打开<a href="http://zuihaodaxue.com/zuihaodaxuepaiming2019.html" target="_blank" rel="noopener">最好大学网的网页</a>，按F12打开开发者工具</p><p><img src="/2019/10/31/python-web-spider/4.png" alt="Chrome开发者工具"></p><p>需要刷新一下网页才会显示，双击这个document文件</p><p><img src="/2019/10/31/python-web-spider/5.png" alt="Document文件"></p><p>选择Response选项卡就可以看到HTML代码，全选复制到编辑器里</p><p><img src="/2019/10/31/python-web-spider/6.png" alt="VScode"></p><p>排名的信息在tbody标签里，每一个tr标签里面都是一所大学的信息，每一个td标签就是每所大学具体的信息。我们可以遍历tbody里面的每个tr标签，然后把每所大学的信息都保存在list里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            <span class="comment"># import bs4 才能使用对应的标签定义</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)  <span class="comment"># 查询tr 中的td标签</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">2</span>].string])</span><br></pre></td></tr></table></figure><p>在遍历的时候报错,会遇到一个问题：</p><blockquote><p>发生异常: TypeError’NavigableString’ object is not callable</p></blockquote><p><img src="/2019/10/31/python-web-spider/7.png" alt="comment"></p><p>原因是：HTML代码tbody标签中最后有一段Comment,而Comment对象和NavigableString对象不能像Tag对象一样被调用，所以我们在遍历时需要对类型进行判断，判断是否为：bs4.element.Tag</p><h3 id="排版问题"><a href="#排版问题" class="headerlink" title="排版问题"></a>排版问题</h3><p>在输出时候中文排版会出现一些小问题<br><img src="/2019/10/31/python-web-spider/8.png" alt="排版错误"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>原因就是我们在使用format方法在我们定义好的布局里填充大学信息的时候，排版默认使用西文的空格，这样会导致排版错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="comment"># 使用中文空格填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="comment"># print(u)</span></span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure><p>我们可以使用中文空格来进行填充，这样可以解决排版问题，chr(12288)就是中文空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个tplt就是我们定义每行的模板，&#123;&#125;里面就是要填充的内容</span></span><br><span class="line"><span class="comment"># 冒号前面是填充内容的索引号，^10 ^的表居中对齐10代表宽度为10</span></span><br><span class="line"><span class="comment"># \t 表示一个制表符，在冒号后面是填充字符，不指定默认使用西文空格</span></span><br><span class="line"><span class="comment"># 这里我们指定&#123;3&#125;,就是使用索引为3的 chr(12288) 来填充</span></span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>先把大体的框架写完</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://zuihaodaxue.com/zuihaodaxuepaiming2019.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 爬取前20名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>再填充每个具体的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            <span class="comment"># import bs4 才能使用对应的标签定义</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)  <span class="comment"># 查询tr 中的td标签</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">2</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def printUnivList(ulist, num):</span></span><br><span class="line"><span class="comment">#     print("&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;".format("排名", "学校名称", "总分"))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     for i in range(num):</span></span><br><span class="line"><span class="comment">#         u = ulist[i]</span></span><br><span class="line"><span class="comment">#         print("&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;".format(u[0], u[1], u[2]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="comment"># 使用中文空格填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="comment"># print(u)</span></span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://zuihaodaxue.com/zuihaodaxuepaiming2019.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/10/31/python-web-spider/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://aaronlinv.github.io/2019/10/23/hello-world/</link>
      <guid>https://aaronlinv.github.io/2019/10/23/hello-world/</guid>
      <pubDate>Wed, 23 Oct 2019 12:23:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;过往&quot;&gt;&lt;a href=&quot;#过往&quot; class=&quot;headerlink&quot; title=&quot;过往&quot;&gt;&lt;/a&gt;过往&lt;/h2&gt;&lt;p&gt;前一段时间发生了很多事，经历了一些变动，让我开始重新审视自己&lt;/p&gt;
&lt;p&gt;大一大二似乎都在随波逐流，做着那些“优秀”的人都在做的事&lt;/p&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="过往"><a href="#过往" class="headerlink" title="过往"></a>过往</h2><p>前一段时间发生了很多事，经历了一些变动，让我开始重新审视自己</p><p>大一大二似乎都在随波逐流，做着那些“优秀”的人都在做的事</p><p>到头来不过只是在重复地做着某些领域最简单的事</p><h2 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h2><p>走出舒适圈，和不同的人交流，了解不同的观点</p><p>一点一点地积累，用博客改变自己，也用博客记录自己的改变</p><p>希望自己能坚持下去，不管是写博客，还是其他喜欢的事</p><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><blockquote><p>写博客是一种“写作式学习”</p><p>只要你坚持写下去几年，写Blog给你带来的收益超乎想象，这是积累的力量。</p><p>引用自 <a href="http://www.read.org.cn/html/2005-xie-bo-ke-shi-yi-zhong-xie-zuo-shi-xue-xi.html" target="_blank" rel="noopener">写博客是一种“写作式学习”</a></p></blockquote><p>搭这个博客的初心就是激励自己，多把时间花在有意义的事情上，深入地学习一些东西</p><p>用的是Hexo + Github Pages，相对那些即开即用的博客，我更享受折腾带来的乐趣</p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/10/23/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
