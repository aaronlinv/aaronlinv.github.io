<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Aaron Lin</title>
    <link>https://aaronlinv.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 08 Feb 2020 13:46:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Web服务器笔记-Servlet</title>
      <link>https://aaronlinv.github.io/2020/02/07/web-server-note-3/</link>
      <guid>https://aaronlinv.github.io/2020/02/07/web-server-note-3/</guid>
      <pubDate>Fri, 07 Feb 2020 11:03:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;Servlet 运行在服务端的Java小程序，是sun公司提供一套规范（接口）&lt;/p&gt;
&lt;ol&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 运行在服务端的Java小程序，是sun公司提供一套规范（接口）</p><ol><li>servlet接收响应请求</li><li>filter过滤器</li><li>listener监听器</li></ol><p>用来处理客户端请求、响应给浏览器的动态资源<br>servlet的实质就是java代码，通过Java的API动态的向客户端输出内容<br>以后写的程序就不在是在本地执行了。而是编译成字节码，放到服务器上来去执行。<br>编写程序时， 不需要有main函数了。因为写完后，就把编写的程序编译成字节码，放到服务器上面。当前发送就一个请求的时候，服务器就会按照一定规则调用编写的代码</p><h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><ol><li>创建一个web工程</li><li>在JavaResource中src下创建一个包名称为com.myxq.servlet</li><li>在创建的servlet包当中创建一个class文件起名为FirstServlet</li><li>进入该class实现一个Servlet接口，实现它未实现的方法，在service方法中写入一句话输出</li><li>在web.xml当中进行配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 在display-name 标签后添加servlet 和 servlet-mapping配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myxq<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.it666.servlet.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myxq<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/firstServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.it666.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello Servlet"</span>);</span><br><span class="line">HttpServletResponse r = (HttpServletResponse) res;</span><br><span class="line">r.getWriter().write(<span class="string">"getWriter"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><img src="/2020/02/07/web-server-note-3/1.png" alt="执行结果"></p><p>修改url路径<br><img src="/2020/02/07/web-server-note-3/2.png" alt="修改url路径"></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h4 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h4><p>当程序要使用某个类时，如果该类还未被加载到内存中，系统会通过加载，连接，初始化三步来实现对这个类进行初始化</p><ul><li>加载<br>就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象</li><li>连接<br>验证 是否有正确的内部结构，并和其他类协调一致<br>准备 负责为类的静态成员分配内存，并设置默认初始化值</li><li>初始化<br>初始化成员变量等等</li></ul><p>加载时机</p><ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>初始化某个类的子类</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li></ul><h4 id="类加载器-classLoader"><a href="#类加载器-classLoader" class="headerlink" title="类加载器 classLoader"></a>类加载器 classLoader</h4><p>负责将.class文件加载到内存中，并为之生成对应的Class对象</p><p>类加载器分类</p><ul><li>根类加载器<br>也被称为引导类加载器，负责Java核心类的加载<br>比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</li><li>扩展类加载器<br>负责JRE的扩展目录中jar包的加载<br>在JDK中JRE的lib目录下ext目录</li><li>系统类加载器<br>负责在JVM启动时加载来自java命令的class文件<br>以及classpath环境变量所指定的jar包和类路径</li></ul><h4 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h4><p>创建一个对象的三个阶段</p><ol><li>源文件阶段 .java的文件</li><li>字节码阶段 .class</li><li>创建对象阶段  new  对象名称</li></ol><p>内省与反射</p><ul><li>内省<br>在运行时能够获取JavaBean当中的属性名称和get与set方法</li><li>反射<br>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的<strong>所有属性和方法</strong><br>对于任意一个对象，都能够调用它的任意一个方法和属性<br>这种<strong>动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制</strong></li></ul><p>获取字节码文件：想要使用反射，就必须得要获取字节码文件</p><ol><li>Object类的getClass()方法<br>判断两个对象是否是同一个字节码文件</li><li>静态属性class<br>当作静态方法的锁对象</li><li>Class类中静态方法forName()<br>读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字节码</span></span><br><span class="line"><span class="comment">// 1.类的全限定名称 ClassNotFoundException</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.it666.reflect.Person"</span>);</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">Class clazz2 = Person.class;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz3 = p.getClass();</span><br></pre></td></tr></table></figure><h4 id="通过字节码创建对象"><a href="#通过字节码创建对象" class="headerlink" title="通过字节码创建对象"></a>通过字节码创建对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过无参构造创建对象</span></span><br><span class="line">Person p2 = (Person)clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过有参构造创建对象</span></span><br><span class="line"><span class="comment">// 获取字节码的构造器：</span></span><br><span class="line"><span class="comment">// 因为在反射阶段操作的都是字节码，不知道具体的类型，只有在创建对象的时候才去给实际参数</span></span><br><span class="line">Constructor c = clazz.getConstructor(String.class, Integer.class);</span><br><span class="line"><span class="comment">// 通过构造器创建对象：调用构造器的newInstance方法并传入参数</span></span><br><span class="line">Person p2 = (Person)c.newInstance(<span class="string">"al"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取pubic字段(默认修饰符是不可以的获取到的：NoSuchFieldException)</span></span><br><span class="line">Field f = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">f.set(p2,<span class="string">"李白"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取private 字段</span></span><br><span class="line">Field f2 = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//private 去除私有权限</span></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">f2.set(p2, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line">Method m1 = clazz.getMethod(<span class="string">"show"</span>);</span><br><span class="line">System.out.println(m1.getName());<span class="comment">//获取名字 </span></span><br><span class="line">m1.invoke(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取私有方法</span></span><br><span class="line">Method m2 = clazz.getDeclaredMethod(<span class="string">"eat"</span>,String.class);</span><br><span class="line"><span class="comment">//去除私有权限</span></span><br><span class="line">m2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m2.invoke(p2, <span class="string">"米饭"</span>);</span><br></pre></td></tr></table></figure><h4 id="越过数组泛型检测"><a href="#越过数组泛型检测" class="headerlink" title="越过数组泛型检测"></a>越过数组泛型检测</h4><p>数组如果定义好了泛型就不能添加泛型以外的类型<br>可以通过反射来去实现添加以外的类型<br>在一个Integer泛型的数组当中添加字符串类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// list.add("myxq");</span></span><br><span class="line"><span class="comment">// 错误检测是Eclipse做的，运行的时候会做一个泛型擦除，编译成字节码，泛型都没了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ArrayList的字节码</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>); <span class="comment">// &lt;?&gt;  ?代表任意类型</span></span><br><span class="line">Method m = clazz.getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">m.invoke(list, <span class="string">"myxq"</span>); </span><br><span class="line">System.out.println(list); <span class="comment">// [20, myxq]</span></span><br></pre></td></tr></table></figure><h2 id="Tomcat反射加载Servlet"><a href="#Tomcat反射加载Servlet" class="headerlink" title="Tomcat反射加载Servlet"></a>Tomcat反射加载Servlet</h2><p>模拟实现过程<br>新建包com.it666.servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">implements</span> <span class="title">IServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.复制web.xml文件，修改servlet-class标签为：com.it666.servlet.FirstServlet</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.测试类模拟Tomcat反射加载Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="comment">//加载web.xml 使用dom4j</span></span><br><span class="line"><span class="comment">// 1.创建SAXReader</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/web.xml"</span>); <span class="comment">// DocumentException</span></span><br><span class="line"><span class="comment">// 获取根元素</span></span><br><span class="line">Element rootElement = doc.getRootElement();</span><br><span class="line">System.out.println(rootElement);</span><br><span class="line"></span><br><span class="line">List &lt;Element&gt; list = rootElement.elements(<span class="string">"servlet"</span>);</span><br><span class="line"><span class="keyword">for</span> (Element ServEle : list) &#123;</span><br><span class="line">Element classEle = ServEle.element(<span class="string">"servlet-class"</span>);</span><br><span class="line">System.out.println(classEle.getText());</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Class clazz = Class.forName(classEle.getText()); <span class="comment">// ClassNotFoundException</span></span><br><span class="line">Object obj = clazz.newInstance();<span class="comment">// InstantiationException</span></span><br><span class="line"></span><br><span class="line">Method m = clazz.getMethod(<span class="string">"init"</span>);<span class="comment">// NoSuchMethodException</span></span><br><span class="line">m.invoke(obj); <span class="comment">//IllegalArgumentException</span></span><br><span class="line"><span class="comment">// 输出：init...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet什么时候被创建</p><ol><li>默认情况下第一次访问的时候创建</li><li>可以通过配置文件设置服务器启动的时候就创建</li></ol><ul><li>init<br>servlet对象创建的时候调用<br>默认第一次访问时创建</li><li>service<br>每次请求都会执行一次</li><li>destroy<br>servlet对象销毁的时候执行<br>默认服务器关闭时销毁</li><li>load-on-startup标签<br>对象在服务器启动时就创建<br>值为数字代表优先级：数据越小，优先级越高，不能为负数<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--load-on-startup在web.xml的servlet标签中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myxq<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.it666.servlet.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Servlet访问流程"><a href="#Servlet访问流程" class="headerlink" title="Servlet访问流程"></a>Servlet访问流程</h2><p>ServletRequest对象和ServletResponse对象是引擎提前创建好的<br>每次请求时调用service方法并把这两个对象传入<br><img src="/2020/02/07/web-server-note-3/3.png" alt="Servlet访问流程"></p><h2 id="Servlet配置信息"><a href="#Servlet配置信息" class="headerlink" title="Servlet配置信息"></a>Servlet配置信息</h2><p>init-params标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myxq<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.it666.servlet.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- init-params标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>my<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// 1.获取web.xml的Servlet名称</span></span><br><span class="line">System.out.println(config.getServletName());<span class="comment">// 获取&lt;servlet-name&gt; 输出：myxq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取一些初始化参数 web.xml</span></span><br><span class="line">String value = config.getInitParameter(<span class="string">"my"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">// 输出：1234</span></span><br><span class="line"><span class="comment">// 3.获取ServletContext</span></span><br><span class="line">ServletContext sc = config.getServletContext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init方法的config参数<br>该servlert的配置信息<br>获得web.xml当中参数<br>初始化参数<br>获取servletContext对象</p><p>url-patten</p><ol><li>完全匹配</li><li>目录匹配</li><li>扩展名匹配<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myxq<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/firstServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/aaa/bbb/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.myxq<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>缺省Servlet<br>访问的资源不存在时，就会找缺省的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-patten</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-patten</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全局Web.xml<br>对于部署在服务器上的所有应用都有效<br>先到自己工程当中找web.xml配置<br>再到全局web.xml当中去找配置<br>如果两个当中有相同的配置，自己当中配置的内容会生效</p><p>静态资源加载过程<br>在path后面写的静态资源名称index.html或者是其它的.html它都是会找ur-patten当中有没有匹配的内容<br>如果有，就加载对应的servlet，如果没有就到自己配置当中找缺省的url-patten<br>如果自己配置文件当中没有缺省的，就会找全局配置缺省的url-patten<br>在全局配置当中有一个缺省的url-patten 对应的是default的Servlet<br>defaultServlet内部会到当前访问的工程根目录当中去找对应的名称的静态资源，如果有，就把里面的内容逐行读出。响应给浏览器，如果没有，就会报404错误</p><p>欢迎页面 Welcome-file-list<br>不写任何资源名称的时候，会访问欢迎页面<br>默认从上往下找</p><h2 id="使用注解创建Servlet"><a href="#使用注解创建Servlet" class="headerlink" title="使用注解创建Servlet"></a>使用注解创建Servlet</h2><p>包名右键-new-Servlet<br><img src="/2020/02/07/web-server-note-3/4.png" alt="new Servlet"><br><img src="/2020/02/07/web-server-note-3/5.png" alt="new Servlet2"><br><img src="/2020/02/07/web-server-note-3/6.png" alt="new Servlet3"></p><p>修改web.xml web-app标签中的 metadata-complete=”false”<br>该属性为true时，web应用将不会加载注解配置的Web组件</p><p>从Servlet3.0开始可以直接使用注解的形式来去使用Servlet<br>在创建好的Servlet上面有会有一个@WebServlet(“/myServlet”)<br>这个就是一个注解，就相当于在代码上添加了一个小插件<br>贴上这个注解后，就不用再去做配置文件，会在内部自动帮你去做<br>括号当中的内容就是url-patten的内容，要在地址栏当中path后面跟的内容</p><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>直接new的Servlet它是一个HttpServlet<br>它是GenericServlet的子类<br>GenericServlet实现了Servlet接口<br>HttpServlet是专门负责处理http请求与响应的<br>以后创建Servlet时，直接使用httpServlet</p><h4 id="HttpServlet方法"><a href="#HttpServlet方法" class="headerlink" title="HttpServlet方法"></a>HttpServlet方法</h4><ul><li>service<br>每一次发送请求的时候就会调用<br>当写了service就会不再调用get或post</li><li>doGet<br>当发送get请求时调用</li><li>doPost<br>当发送post请求的时候调用</li></ul><h4 id="内部方法调用过程"><a href="#内部方法调用过程" class="headerlink" title="内部方法调用过程"></a>内部方法调用过程</h4><p>当接收到一个请求时， tomcat就会找对应的service方法<br>如果当中servlet当中没有存在service方法，就会到它的父类(HttpServlet)当中去找<br><img src="/2020/02/07/web-server-note-3/7.png" alt="HttpServlet"><br>在父类当中找到service是参数为ServletRequest，在会内部把参数转为httpServlet<br>转换完毕后会再继续调用参数为httpServletRequest的service方法<br><img src="/2020/02/07/web-server-note-3/8.png" alt="HttpServlet2"><br>在此方法当中会获取参数的类型，根据不同的参数类型再去调用不同的方法</p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/07/web-server-note-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Web服务器笔记-Tomcat服务器</title>
      <link>https://aaronlinv.github.io/2020/02/07/web-server-note-2/</link>
      <guid>https://aaronlinv.github.io/2020/02/07/web-server-note-2/</guid>
      <pubDate>Fri, 07 Feb 2020 05:25:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Java分类&quot;&gt;&lt;a href=&quot;#Java分类&quot; class=&quot;headerlink&quot; title=&quot;Java分类&quot;&gt;&lt;/a&gt;Java分类&lt;/h2&gt;&lt;h4 id=&quot;JavaSE&quot;&gt;&lt;a href=&quot;#JavaSE&quot; class=&quot;headerlink&quot; titl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Java分类"><a href="#Java分类" class="headerlink" title="Java分类"></a>Java分类</h2><h4 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h4><p>Java的标准版，一般用来开发桌面应用程序，但是在开发桌面应用程序上相对VB，Delphi，VC++并没有什么优势</p><h4 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h4><p>也就是Java Enterprise Edition，Java的企业版<br>开发JavaWeb应用程序，初级的一般是用JSP(Java Server Pages) + servlet + Javabean来开发的<br>大型的网站一般是使用框架来开发: struts , hibernate , spring , Mybatis</p><h4 id="JavaME"><a href="#JavaME" class="headerlink" title="JavaME"></a>JavaME</h4><p>JavaME,Java Micro Edition,Java的微型版<br>诺基亚手机上运行的Java程序就是指用这个版本开发的程序</p><h2 id="JavaEE规范"><a href="#JavaEE规范" class="headerlink" title="JavaEE规范"></a>JavaEE规范</h2><p>JavaEE的共有13个技术规范<br>Sun公司定义了这么多标准，其它公司的人都可以来去根据这些标准来做JavaEE程序</p><p>JDBC<br>java数据连接，是一种用于执行SQL语句的Java API</p><p>JNDI<br>Java命名和目录接口</p><p>EJB<br>EJB是sun的JavaEE服务器端组件模型，设计目标与核心应用是部署分布式应用程序</p><p>RMI<br>远程方法调用，能够让在某个java虚拟机上的对象调用本地对象一样的<br>调用另一个java虚拟机中高的对象上的方法</p><p>JSP<br>java服务器页面，是一个动态内容模板，实现了Html语法中的java扩展</p><p>Servlet<br>Servlet是一种小型的Java程序，它扩展了Web服务器的功能</p><p>XML<br>是一种可扩展的标记语言</p><p>JMS<br>是一个Java平台中关于面向消息中间件（MOM）的API<br>用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信</p><p>Java IDL<br>Java IDL支持的是一个瞬间的CORBA对象，即在对象服务器处理过程中有效</p><p>JTS<br>子主题 1组件事务监视器，TPM 是一个程序，它代表应用程序协调分布式事务的执行</p><p>JTA<br>JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据</p><p>JavaMail<br>提供给开发者处理电子邮件相关的编程接口</p><p>JAF<br>JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口</p><h2 id="常见JavaWeb应用服务器"><a href="#常见JavaWeb应用服务器" class="headerlink" title="常见JavaWeb应用服务器"></a>常见JavaWeb应用服务器</h2><p>weblogic<br>oracle公司的大型收费Web服务器 支持全部JavaEE规范</p><p>websphere<br>IBM公司的大型收费Web服务器 支持全部的JavaEE规范</p><p>Tomcat<br>Apache开源组织下的开源免费的中小型的Web应用服务器<br>支持JavaEE中的servlet和JSP规范</p><h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><p>企业老项目一般使用Tomcat7<br>解压到</p><h5 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h5><p>bin<br>脚本程序<br>可执行的命令</p><p>conf<br>配置目录<br>内部有一个server.xml核心配置文件</p><p>lib<br>依赖库目录 </p><p>logs<br>日志目录</p><p>temps<br>临时文件目录</p><p>webapps<br>web应用发布目录<br>把开发的项目放到该目录当中运行</p><p>work<br>tomcat处理jsp的工作目录</p><h4 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h4><ol><li>进入到解压目录</li><li>找到bin目录</li><li>找到startup.bat双击启动脚本</li></ol><ul><li>没有配置JAVA_HOME</li></ul><p>在启动过程当中如果没有配置Java_home，就会一闪没了<br>Java_HOME配置的就是JDK bin的上级目录</p><ul><li>端口冲突,默认的端口是8080(两种解决方法)</li></ul><p>把占用的端口杀死<br>netstat -aov  查看端口占用情况  记下占用端口的pid<br>到任务管理器当中查看任务详细信息，把对应pid给关掉</p><p>到config目录当中修改核心配置文件server.xml，修改por</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过浏览器访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>看到以下界面<br><img src="/2020/02/07/web-server-note-2/1.png" alt="Tomcat"><br>返回的就是一个页面<br>这个页面可以在webapps目录当中的ROOT文件夹当中找到</li><li>shutdown.bat停止脚本</li></ol><h2 id="手动创建项目"><a href="#手动创建项目" class="headerlink" title="手动创建项目"></a>手动创建项目</h2><ol><li>在webapps目录下，新建一个文件夹mytest</li><li>在mytest文件夹里放置html、jsp、js文件</li><li>在mytest内新建WEB-INF目录，在WEB-INF目录内新建：classes目录和lib目录、web.xml文件</li></ol><p>classes目录：Java类字节码文件<br>lib目录：Java类运行时需要的jar包<br>web.xml文件：当前整个web应用的核心配置文件，可以到ROOT当中复制一个过来<br><img src="/2020/02/07/web-server-note-2/2.png" alt="项目目录"></p><p>WEB-INF目录下当前的资源不能直接通过浏览器访问，是保护的， 外界不能直接访问</p><h2 id="使用开发工具构建web工程"><a href="#使用开发工具构建web工程" class="headerlink" title="使用开发工具构建web工程"></a>使用开发工具构建web工程</h2><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>创建一个名为myproject的工程<br><img src="/2020/02/07/web-server-note-2/3.png" alt="创建项目"><br><img src="/2020/02/07/web-server-note-2/4.png" alt="选择Tomc目录"><br><img src="/2020/02/07/web-server-note-2/5.png" alt="选择web module版本"><br>3.0不会在WEB_INF 里生成xml文件</p><h4 id="切换JavaEE视图"><a href="#切换JavaEE视图" class="headerlink" title="切换JavaEE视图"></a>切换JavaEE视图</h4><p><img src="/2020/02/07/web-server-note-2/6.png" alt="切换JavaEE视图"></p><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><p>在创建项目的时候已经添加好了服务器<br><img src="/2020/02/07/web-server-note-2/7.png" alt="服务器"></p><p>在Servers标签创建Server<br>右键-new-Server-选择对应Tomcat版本-下面Next-添加已有的项目-Finish<br>也可通过右键已创建的Server-Add and Remove-添加已有项目</p><p>双击Server，修改配置<br><img src="/2020/02/07/web-server-note-2/9.png" alt="修改Server配置"><br>设置目录，发布时候就会把WebContent和字节码部署到设置好的目录里（我设置的是D:\Tomcat\apache-tomcat-7.0.85\webapps）</p><h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>新建index.html文件<br><img src="/2020/02/07/web-server-note-2/8.png" alt="html网页"></p><p>右键项目-run Server 或者 是在Server右键-Start</p><ol><li>将未发布的工程，发布到webapps下面</li><li>启动tomcat（如果用startup.bat打开了Tomcat，要先关闭）</li></ol><p>在发布时<br>会在Tomcat的webapps目录下创建一个名称myproject的目录<br>并且把WebContent当中的所有内容放入到webapps目录下当中的myproject目录中<br>不会把写的Java代码给放到webapps当中，运行时，只需要字节码就行了</p><p>浏览器访问：<a href="http://localhost:8080/myproject/" target="_blank" rel="noopener">http://localhost:8080/myproject/</a><br>就可看到刚才写的index.html</p><h2 id="优化Tomcat启动速度"><a href="#优化Tomcat启动速度" class="headerlink" title="优化Tomcat启动速度"></a>优化Tomcat启动速度</h2><ol><li>删除webApps里面的自带的项目（保留ROOT，ROOT是默认访问的项目），加快启动速度</li><li>复制ROOT里面的xml的web-app标签，替换当前项目的web-app标签（原因是3.0才支持优化）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"3.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>添加上这个标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">absolute-ordering</span>&gt;</span><span class="tag">&lt;/<span class="name">absolute-ordering</span>&gt;</span> </span><br><span class="line">省略写法：<span class="tag">&lt;<span class="name">absolute-ordering</span>/&gt;</span></span><br></pre></td></tr></table></figure>扫描的jar包，里面为空，就是不扫描 提升速度<br>在ROOT的xml也添加这句</li></ol><p>新建工程就可以选3.0，把修改好的web.xml复制到WEB-INF里，修改下display-name标签内容</p><h2 id="Tomcat服务器Context"><a href="#Tomcat服务器Context" class="headerlink" title="Tomcat服务器Context"></a>Tomcat服务器Context</h2><p>添加工程就是在conf/server.xml 中添加Context标签，一个项目就是一个Context<br><img src="/2020/02/07/web-server-note-2/10.png" alt="Context"></p><p>docBase<br>web应用的文件路径，相对路径，相对的是Server设置的目录</p><p>path<br>URL入口（网页输入的地址）</p><p>reloadable<br>字节码变化服务器是否重新加载web应用</p><h4 id="tomcat服务器体系结构"><a href="#tomcat服务器体系结构" class="headerlink" title="tomcat服务器体系结构"></a>tomcat服务器体系结构</h4><ol><li>Server：整个Servlet容器组合，可以包含一个或多个Service标签</li><li>service：它由一个或者多个Connector组成，以及一个Engine，负责处理所有Connector所获得的客户请求</li><li>Connector：客户端与程序交互组件，负责接收请求以及向客户端返回响应</li><li>Engine：处理连接器接收到请求</li><li>Host：虚拟主机</li><li>Context：一个Context对应于一个Web Application</li></ol><p><img src="/2020/02/07/web-server-note-2/11.png" alt="服务器体系"></p><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><ol><li>输入网址时， 就会先到host文件当中查找有没有对应的IP地址，如何有就直接访问该IP地址</li><li>如果没有，就会到外网去找DNS服务器进行域名与IP地址的解析，查找</li><li><strong>多个域名可以访问同一个IP</strong></li><li>一个IP对应一台电脑</li></ol><p><img src="/2020/02/07/web-server-note-2/12.png" alt="虚拟主机"></p><p>修改本机host文件(C:\Windows\System32\drivers\etc)<br>Win10不能直接修改，复制到桌面修改，然后覆盖host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1          m.myxq.com</span><br></pre></td></tr></table></figure><p>原来的server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span></span></span><br><span class="line"><span class="tag"><span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag"><span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span></span></span><br><span class="line"><span class="tag"><span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"myproject2"</span> <span class="attr">path</span>=<span class="string">"/myp2"</span></span></span><br><span class="line"><span class="tag"><span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">source</span>=<span class="string">"org.eclipse.jst.jee.server:myproject2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"myproject"</span> <span class="attr">path</span>=<span class="string">"/myproject"</span></span></span><br><span class="line"><span class="tag"><span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">source</span>=<span class="string">"org.eclipse.jst.jee.server:myproject"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加虚拟主机：在Host标签后面再添加一个Host标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"m.myxq.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"myproject"</span> <span class="attr">path</span>=<span class="string">"/myp2"</span></span></span><br><span class="line"><span class="tag"><span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">source</span>=<span class="string">"org.eclipse.jst.jee.server:myproject"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在server.xml修改端口，浏览器默认访问80端口，这样就可以免输入端口<br>通过<a href="http://http://m.myxq.com/myp/" target="_blank" rel="noopener">http://http://m.myxq.com/myp/</a> 和<a href="http://localhost/myp/" target="_blank" rel="noopener">http://localhost/myp/</a> 访问的项目不同，不同域名映射到同一个IP</p><h2 id="Tomcat插件安装"><a href="#Tomcat插件安装" class="headerlink" title="Tomcat插件安装"></a>Tomcat插件安装</h2><ol><li><a href="https://jaist.dl.sourceforge.net/project/tomcatplugin/net.sf.eclipse.tomcat.updatesite-2018-03-08.zip" target="_blank" rel="noopener">下载插件</a></li><li>到Eclipse当中找到help-&gt;install new software</li><li>进入对话框，点击add然后弹出add Repository  选择下载的插件位置，name随便写,点击确定</li><li>在列表框中选中tomcat-plugin直接点击下一步</li><li>接受许可，然后等待，在eclipse右下角会有安装进度。进度完成时，会弹出要求重新启动eclipse</li></ol><p>配置插件与Tomcat关联<br>1.windon-&gt;preferences<br>2.找到tomcat<br>3.选择对应版本的服务器<br>4.找到tomcat服务器存放的根路径</p><p>Atl+t 重启服务器        </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005981003.htm" target="_blank" rel="noopener">Java零基础到高级JavaWeb与项目</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/07/web-server-note-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Web服务器笔记-http协议</title>
      <link>https://aaronlinv.github.io/2020/02/05/web-server-note-1/</link>
      <guid>https://aaronlinv.github.io/2020/02/05/web-server-note-1/</guid>
      <pubDate>Wed, 05 Feb 2020 13:48:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;CS与BS&quot;&gt;&lt;a href=&quot;#CS与BS&quot; class=&quot;headerlink&quot; title=&quot;CS与BS&quot;&gt;&lt;/a&gt;CS与BS&lt;/h2&gt;&lt;p&gt;软件使用方式上两种划分&lt;/p&gt;
&lt;h4 id=&quot;C-S-Client-Server-PC客户端、服务器架构&quot;&gt;&lt;a 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="CS与BS"><a href="#CS与BS" class="headerlink" title="CS与BS"></a>CS与BS</h2><p>软件使用方式上两种划分</p><h4 id="C-S-Client-Server-PC客户端、服务器架构"><a href="#C-S-Client-Server-PC客户端、服务器架构" class="headerlink" title="C/S:Client/Server PC客户端、服务器架构"></a>C/S:Client/Server PC客户端、服务器架构</h4><p>特点：在服务器当中就主要是一个数据库，把所有的业务逻辑以及界面都交给客户端完成<br>优点：较为安全，用户界面丰富，用户体验好<br>缺点：每次升级都要重新安装，针对于不同的操作系统开发，可移植性差</p><h4 id="B-S：Browser-Server-浏览器-服务器架构"><a href="#B-S：Browser-Server-浏览器-服务器架构" class="headerlink" title="B/S：Browser/Server 浏览器/服务器架构"></a>B/S：Browser/Server 浏览器/服务器架构</h4><p>特点：</p><ul><li>基于浏览器访问的应用</li><li>把业务层交给服务器来完成，客户端仅仅做界面的渲染和数据的交换</li></ul><p>优点：只开发服务器端，可以跨平台、移植性很强<br>缺点：安全性比较低，用户体验较差</p><h2 id="Web资源"><a href="#Web资源" class="headerlink" title="Web资源"></a>Web资源</h2><p>WEB网页，它用于表示网络主机上供外界访问的资源<br>Web资源分类</p><ul><li>静态Web资源：指web页面中供人们浏览的数据始终是不变</li><li>动态Web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同</li></ul><p>web资源存放在哪里<br>所有的web资源都放在一个web服务器当中<br>web服务器就是可以供外界访问web资源的一个软件<br>web资源放到指定的目录当中，就可以通过对应的端口在浏览器当中访问到</p><p>URL地址<br>协议：//主机地址：端口号/资源地址<br><img src="/2020/02/05/web-server-note-1/1.png" alt="URL协议"><br>资源访问流程<br>客户端：浏览器、Android程序、iOS程序、微信小程序<br>服务器：php服务器、tomcat服务器、nodeJS服务器等</p><p>http请求的过程<br>浏览器通过网址（就是IP地址）找到对应的电脑，电脑当中安装的有web服务器，通过端口号找到对应服务器，服务器把页面返回给你</p><p>BS结构流程图<br><img src="/2020/02/05/web-server-note-1/2.png" alt="BS结构流程图"></p><h4 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h4><p>请求：把客户端请求发送给服务器<br>响应：服务器把你要的数据发送给客户端</p><p>请求与响应都要一定的格式</p><ul><li>约定好客户端以什么样的格式把数据给服务器</li><li>约定好服务器以什么样的格式把数据给客户端</li><li>这个约定使用的就是HTTP协议</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP，超文本传输协议 (HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议<br>所有的WWW文件都必须遵守这个标准<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法<br>约束请求与响应的规则</p><p>HTTP组成部分：请求、响应<br>请求与响应都是成对存在的</p><p>请求的发送方式</p><ol><li>通过浏览器的地址栏</li><li>通过html当中的form表单</li><li>通过a链接的href</li><li>src属性        </li></ol><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h4><p>请求方式<br>POST<br>GET</p><p>协议版本<br>HTTP/1.0，发送请求，创建一次连接，获得一个web资源，连接断开<br>HTTP/1.1，发送请求，创建一次连接，获得<strong>多个web资源，保持连接</strong></p><h4 id="2-请求头"><a href="#2-请求头" class="headerlink" title="2.请求头"></a>2.请求头</h4><p>请求头是客户端发送给服务器端的一些信息<br>使用键值对表示key：value<br>自动的把客户端的信息发送给服务器</p><h4 id="3-常见请求头"><a href="#3-常见请求头" class="headerlink" title="3.常见请求头"></a>3.常见请求头</h4><p>Referer：    浏览器通知服务器，当前请求来自何处。如果是直接访问，则不会有这个头。常用于：防盗链<br>If-Modified-Since：浏览器通知服务器，本地缓存的最后变更时间<br>Cookie：用于存放浏览器缓存的cookie信息<br>User-Agent：浏览器通知服务器，客户端浏览器与操作系统相关信息<br>Connection：保持连接状态。Keep-Alive 连接中，close 已关闭<br>Host：请求的服务器主机名<br>Content-Length：请求体的长度<br>Content-Type：如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码</p><p>Accept：浏览器可支持的MIME类型，文件类型的一种描述方式</p><ul><li>text/html ，html文件</li><li>text/css，css文件</li><li>text/javascript，js文件</li><li>image/*，所有图片文件</li></ul><p>Accept-Encoding：浏览器通知服务器，浏览器支持的数据压缩格式。如：GZIP压缩<br>Accept-Language：浏览器通知服务器，浏览器支持的语言</p><h4 id="4-请求体"><a href="#4-请求体" class="headerlink" title="4.请求体"></a>4.请求体</h4><p>当请求方式是post，请求体会有请求的参数<br>如果请求方式为get，请求参数不会出现在请求体中，会拼接在url地址后面</p><p><img src="/2020/02/05/web-server-note-1/3.png" alt="http请求"></p><h2 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h2><h4 id="1-状态码"><a href="#1-状态码" class="headerlink" title="1.状态码"></a>1.状态码</h4><p>200 ：请求成功<br>302 ：请求重定向<br>304 ：请求资源没有改变，访问本地缓存<br>404 ：请求资源不存在，通常是用户路径编写错误，也可能是服务器资源已删除<br>500 ：服务器内部错误，通常程序抛异常</p><h4 id="2-响应头"><a href="#2-响应头" class="headerlink" title="2.响应头"></a>2.响应头</h4><p>服务器端将信息以键值对的形式返回给客户端<br>自动的把服务器端的信息传给客户端</p><h4 id="3-常见响应头"><a href="#3-常见响应头" class="headerlink" title="3.常见响应头"></a>3.常见响应头</h4><p>Location：指定响应的路径，需要与状态码302配合使用，完成跳转<br>Content-Type：响应正文的类型（MIME类型）<br>Content-Disposition：通过浏览器以下载方式解析正文<br>Set-Cookie：服务器向浏览器写入cookie<br>Content-Encoding：服务器使用的压缩格式<br>Content-length：响应正文的长度<br>Refresh：定时刷新<br>Server：服务器名称，默认值：Apache-Coyote/1.1。可以通过conf/server.xml配置进行修改<br>Last-Modified：服务器通知浏览器，文件的最后修改时间</p><h4 id="4-响应体"><a href="#4-响应体" class="headerlink" title="4.响应体"></a>4.响应体</h4><p>响应体是服务器回写给客户端的页面正文<br>浏览器将正文加载到内存<br>然后解析渲染显示页面内容</p><p><img src="/2020/02/05/web-server-note-1/4.png" alt="http响应"></p><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><p>8种请求类型</p><ol><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</li><li>HEAD：请求指定的页面信息，并返回头部信息</li><li>GET：请求指定的页面信息，并返回实体主体</li><li>POST：向指定资源提交数据进行处理请求</li><li>PUT：向指定资源位置上传其最新内容</li><li>DELETE：请求服务器删除Request-URL所标识的资源</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断</li><li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li></ol><h2 id="常用两种请求"><a href="#常用两种请求" class="headerlink" title="常用两种请求"></a>常用两种请求</h2><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>GET 方法向页面请求发送参数<br>地址和参数信息中间用 ? 字符分隔<br>    <a href="http://www.it666.com/hello?key1=value1&amp;key2=value2" target="_blank" rel="noopener">http://www.it666.com/hello?key1=value1&amp;key2=value2</a><br>查询字符串会显示在地址栏的URL中，不安全，请不要使用GET请求提交敏感数据<br>GET 方法有大小限制：请求字符串中最多只能有 1024 个字符<br>GET请求能够被缓存<br>GET请求会保存在浏览器的浏览记录中<br>可以添加书签<br>编码类型为application/x-www-form-urlencoded<br>只允许ASCII字符类型，不能用二进制流<br>点击刷新时，不会有反应<br>GET请求主要用以获取数据</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST 方法向页面请求发送参数<br>使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器<br>编码类型为：application/x-www-form-urlencoded or multipart/form-data. 请为二进制数据使用multipart编码<br>没有历史记录<br>参数类型没有限制，可以是字符串也可以是二进制流<br>数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以看POST求情比GET请求安全，但也不是最安全的方式。如需要传送敏感数据，请使用加密方式传输<br>查询字符串不会显示在地址栏中<br>POST传输的数据量大，可以达到2M，而Get方法由于受到URL长度限制,只能传递大约1024字节.<br>POST就是为了将数据传送到服务器段，Get就是为了从服务器段取得数据</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005981003.htm" target="_blank" rel="noopener">Java零基础到高级JavaWeb与项目</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/05/web-server-note-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC笔记-DBUtils</title>
      <link>https://aaronlinv.github.io/2020/02/04/jdbc-note-5/</link>
      <guid>https://aaronlinv.github.io/2020/02/04/jdbc-note-5/</guid>
      <pubDate>Tue, 04 Feb 2020 07:32:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;DBUtils&quot;&gt;&lt;a href=&quot;#DBUtils&quot; class=&quot;headerlink&quot; title=&quot;DBUtils&quot;&gt;&lt;/a&gt;DBUtils&lt;/h2&gt;&lt;p&gt;Apache公司编写的数据库操作实用的工具，小巧，简单，实用&lt;br&gt;封装了对JDBC的操作，简化了J
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h2><p>Apache公司编写的数据库操作实用的工具，小巧，简单，实用<br>封装了对JDBC的操作，简化了JDBC操作</p><h4 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h4><ul><li>QueryRunner(DataSource ds) 提供数据源连接池，会自动帮你创建连接</li><li>Update(String sql,Object…obj) 执行更新数据</li><li>query(String sql, ResultSetHandler<T> rsh,Object…params) 执行查询</T></li></ul><h4 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h4><ul><li>query(sql, new BeanHandler<Student>(Student.class), params) 把查询的结果封装成一个指定对象</Student></li><li>query(sql, new BeanListHandler<Student>(Student.class) 把查询结果封装成一个指定对象集合</Student></li><li>qr.query(sql, new ScalarHandler()) 查询单个值，返回为一个Long类型</li><li>qr.query(sql, new MapListHandler()) 把查询的结果封装成一个Map集合</li><li>query(sql, new ColumnListHandler(“列名”)) 查询指定的列</li></ul><h2 id="使用DBUtils"><a href="#使用DBUtils" class="headerlink" title="使用DBUtils"></a>使用DBUtils</h2><ol><li>导入jar包，build path</li></ol><p>commons-dbutils-1.4.jar<br>druid-1.0.15.jar<br>mysql-connector-java-5.1.40-bin.jar</p><ol start="2"><li>在JDBCUtil中提供一个获取DataSource的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.util;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataSource ds = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">FileInputStream in;</span><br><span class="line">in = <span class="keyword">new</span> FileInputStream(<span class="string">"resource/db.properties"</span>);</span><br><span class="line">p.load(in);</span><br><span class="line"></span><br><span class="line">ds = DruidDataSourceFactory.createDataSource(p);<span class="comment">// 这样写的ProPerties必须按照条件写</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在DAO实现类的方法中创建QueryRunner对象，DML使用update方法执行，DQL使用query方法执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.dao.impl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">String sql = <span class="string">"insert into stu(name,age) values (?,?)"</span>;</span><br><span class="line">QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtil.getDataSource());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">qr.update(sql,stu.getName(),stu.getAge());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtil.getDataSource());</span><br><span class="line">String sql = <span class="string">"select * from stu where id = ?"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> qr.query(sql, <span class="keyword">new</span> BeanHandler&lt;Student&gt;(Student.class),id);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtil.getDataSource());</span><br><span class="line">String sql = <span class="string">"select * from stu"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student.class));</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构<br><img src="/2020/02/04/jdbc-note-5/1.png" alt="DBUtils项目结构"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005977005.htm" target="_blank" rel="noopener">Java零基础到高级JDBC连接数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/04/jdbc-note-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC笔记-改进</title>
      <link>https://aaronlinv.github.io/2020/02/04/jdbc-note-4/</link>
      <guid>https://aaronlinv.github.io/2020/02/04/jdbc-note-4/</guid>
      <pubDate>Tue, 04 Feb 2020 03:40:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;重构DAO&quot;&gt;&lt;a href=&quot;#重构DAO&quot; class=&quot;headerlink&quot; title=&quot;重构DAO&quot;&gt;&lt;/a&gt;重构DAO&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/04/jdbc-note-4/1.png&quot; alt=&quot;重构代码&quot;&gt;&lt;/p&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="重构DAO"><a href="#重构DAO" class="headerlink" title="重构DAO"></a>重构DAO</h2><p><img src="/2020/02/04/jdbc-note-4/1.png" alt="重构代码"></p><p>重构代码原则</p><ul><li>同一个类中<br>在一个类当中有多个方法当中有太多相同的代码<br>不同的地方通过参数传递进去<br>把它们抽到一个方法当中</li><li>不同类中<br>不同类当中有共同的代码给抽取到一个新类当中。<br>大家同时共享该类中的内容</li></ul><h2 id="抽取DML方法"><a href="#抽取DML方法" class="headerlink" title="抽取DML方法"></a>抽取DML方法</h2><ol><li>设计一个方法</li><li>要求传入两个参数<br>第一个参数sql语句模板<br>第二个参数为可变参数，设置语句参数值</li><li>返回值<br>返回值为int，受影响的行数</li></ol><p>抽取代码</p><ol><li>用可变参数（可变参数要放在参数的最后一个，可变参数本质是数组<br>）</li><li>在com.it666.jdbc.util中新建一个CRUDTemplate类<br><img src="/2020/02/04/jdbc-note-4/2.png" alt="抽取代码"><br>调用代码<br><img src="/2020/02/04/jdbc-note-4/3.png" alt="调用代码"></li></ol><h2 id="抽取DQL"><a href="#抽取DQL" class="headerlink" title="抽取DQL"></a>抽取DQL</h2><p>抽取代码前<br><img src="/2020/02/04/jdbc-note-4/4.png" alt="抽取代码"><br>抽取代码，也是写在com.it666.jdbc.util中的CRUDTemplate类中<br><img src="/2020/02/04/jdbc-note-4/5.png" alt="调用代码"></p><h2 id="用结果集处理器改进DQL"><a href="#用结果集处理器改进DQL" class="headerlink" title="用结果集处理器改进DQL"></a>用结果集处理器改进DQL</h2><p>每一个都封装成了student对象，这写死了，只能查询学生，使用泛型改进<br>不知道封装成什么类型的对象，就不应该处理结果集</p><p>解决办法</p><ul><li>把处理结果集的行为交给每个DAO</li><li>为了规范每个DAO的处理结果集，大家都叫同样的名字，这样在模板中就可以调用同一个名称</li><li>定义一个处理结果集的接口</li></ul><ol><li>定义一个接口</li></ol><p>声明一个处理结果集方法 com.it666.jdbc.handler中的IResultSetHandler<br><img src="/2020/02/04/jdbc-note-4/6.png" alt="定义接口"><br>2. 在具体DAO当中实现接口</p><p>实现处理结果集方法 com.it666.jdbc.handler中的StudentResHandleImp<br><img src="/2020/02/04/jdbc-note-4/7.png" alt="实现接口"></p><ol start="3"><li>创建一个接口实现对象传给查询方法</li></ol><p>com.it666.jdbc.dao.impl中的StudentDaoImpl<br><img src="/2020/02/04/jdbc-note-4/8.png" alt="传递接口"></p><ol start="4"><li>在查询方法当中调用处理结果集方法</li></ol><p>com.it666.jdbc.util中的CRUDTemplate<br><img src="/2020/02/04/jdbc-note-4/9.png" alt="调用结果集"></p><p>项目结构<br><img src="/2020/02/04/jdbc-note-4/11.png" alt="调用结果集"></p><p>总流程<br><img src="/2020/02/04/jdbc-note-4/10.png" alt="调用结果集"></p><h2 id="用泛型改进结果集处理器"><a href="#用泛型改进结果集处理器" class="headerlink" title="用泛型改进结果集处理器"></a>用泛型改进结果集处理器</h2><ol><li>直接定义为T</li></ol><p>处理所有结果集都必须得要返回List<br>有的时候没有必要返回List,想要查询的仅仅是一个结果整数，此时还必须得要从List当中出来</p><ol start="2"><li>由调用者自己来决定返回什么内容</li></ol><p>统一规定返回类型为T类型，调用者使用时去决定是什么类型<br><img src="/2020/02/04/jdbc-note-4/12.png" alt="定义接口"></p><ol start="3"><li>实现类当中实现接口时，要指定返回什么类型<br><img src="/2020/02/04/jdbc-note-4/13.png" alt="实现类"></li></ol><p>4.声明方法时，声明返回值为一个泛型类型，具体是什么类型，有参数来指定</p><p>在方法的参数中标识泛型 必须在方法名前加<T> T 不然报错<br><img src="/2020/02/04/jdbc-note-4/14.png" alt="声明方法"></T></p><p>总体结构<br><img src="/2020/02/04/jdbc-note-4/15.png" alt></p><p>例子：添加获取总人数方法<br><img src="/2020/02/04/jdbc-note-4/16.png" alt></p><h2 id="结构集处理器"><a href="#结构集处理器" class="headerlink" title="结构集处理器"></a>结构集处理器</h2><p>存在的问题<br>该类只能将结果集中的一行数据封装成一个Student对象<br>我们如果有多个domain，就得提供多个结果集处理器</p><p>自动的把一行行数据封装成对象，自动设置属性，结果集处理器，处理不同表时，干的事都一样<br>1.给我一个要封装的类<br>2.自动设置属性</p><p>规定<br>1.表中的列名必须和对象中的属性名相同<br>2.规定表中的类型必须和Java中的类型匹配<br>想要完成此项工作，就要使用内省机制</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.创建一个类实现结果集处理器<br>    实现的时候也不知道是什么类型，所以也可以指定为一个泛型<br>2.提供一个字段，表示要封装成对象的类型<br>3.提供一个构造器，在创建时，就指定是什么类型<br>4.在实现方法当中，通过内省机制获取所有属性名称，做为列名<br>5.通过传入的类字节码创建对象<br>6.通过内省获取字节码中所有的信息<br>7.获取所有的属性描述器<br>8.遍历属性描述器，获取对象的属性名称 ，规定的属性名和列名相同<br>9.通过列名获取结果集中的值<br>10.调用属性的set方法把属性的值设置进去</p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>Class类型</p><ul><li>字节码类型</li><li>所有的字节码把他们当做一个群体类型</li><li>通过字节码创建对象<br>Student stu = Student.class.newInstance();</li></ul><h4 id="内省-1"><a href="#内省-1" class="headerlink" title="内省"></a>内省</h4><p>内省 (Introspector类)<br>用于查看和操作JavaBean中的属性</p><p>Introspector.getBeanInfo(A.class,B.class);</p><ul><li>获取指定类当中的字节码属性信息</li><li>获取A类及A类父类当中的属性，但是不包括指定的类</li><li>返回值BeanInfo</li></ul><p>BeanInfo</p><ul><li>getPropertyDescriptors()</li></ul><p>获取JavaBean中的属性描述器<br>返回的是一个数组（PropertyDescriptor[]）<br>每一个属性都有描述器<br>JavaBean中有多个属性，所以返回了一个数组</p><ul><li>获取属性名<br>pd.getName();</li><li>获取get方法<br>pd.getReadMethod();</li><li>获取set方法<br>pd.getWriteMethod</li><li>动态调用方法<br>方法名.invoke(对象名称,”值”)<h2 id="内省改进结果集处理器"><a href="#内省改进结果集处理器" class="headerlink" title="内省改进结果集处理器"></a>内省改进结果集处理器</h2></li></ul><p>注意属性必须和数据字段名相同</p><p>封装一个对象的通用结果集处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.handler;</span></span><br><span class="line"><span class="comment">// BeanHandler 封装一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IResultSetHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; classType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanHandler</span><span class="params">(Class&lt;T&gt; classType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.classType = classType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line">T obj = <span class="keyword">this</span>.classType.newInstance();</span><br><span class="line"><span class="comment">// 通过内省来拿属性</span></span><br><span class="line">BeanInfo bf = Introspector.getBeanInfo(classType,Object.class);<span class="comment">//Object.class代表不要获取Object，获取到Object就停止</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取所有描述器</span></span><br><span class="line">PropertyDescriptor[] pds = bf.getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line"><span class="comment">// 根据属性名去数据库里取值</span></span><br><span class="line">                Object val = rs.getObject(pd.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 给创建的对象设置属性值</span></span><br><span class="line">pd.getWriteMethod().invoke(obj, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用通用结果集处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;  </span><br><span class="line">    String sql = <span class="string">"select * from stu where id = ?"</span>;</span><br><span class="line">    <span class="comment">// 传入new BeanHandler&lt;Student&gt;(Student.class)</span></span><br><span class="line">    <span class="comment">// Student.class代表需要封装一个Student类型</span></span><br><span class="line">    <span class="comment">// &lt;Student&gt;代表返回值为Student类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  CRUDTemplate.executeQuery(sql,<span class="keyword">new</span> BeanHandler&lt;Student&gt;(Student.class) ,id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装多个对象的通用结果集处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.handler;</span></span><br><span class="line"><span class="comment">// BeanListHandler 封装多条信息的结果集处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanListHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IResultSetHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; classType;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanListHandler</span><span class="params">(Class&lt;T&gt; classType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.classType = classType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">T obj = classType.newInstance();</span><br><span class="line">BeanInfo bf = Introspector.getBeanInfo(<span class="keyword">this</span>.classType,Object.class);</span><br><span class="line">PropertyDescriptor [] pds = bf.getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">Object val = rs.getObject(pd.getName());</span><br><span class="line">pd.getWriteMethod().invoke(obj, val);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用通用结果集处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from stu"</span>;</span><br><span class="line">    <span class="keyword">return</span> CRUDTemplate.executeQuery(sql,<span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程结构<br><img src="/2020/02/04/jdbc-note-4/17.png" alt="内省工程结构"></p><h2 id="整体重构思路"><a href="#整体重构思路" class="headerlink" title="整体重构思路"></a>整体重构思路</h2><ol><li>写DAO接口，在实现类中现实各种方法save(),delete(),updata(),get(),getAll();<br><img src="/2020/02/04/jdbc-note-4/18.png" alt="原始代码"></li></ol><ul><li>声明静态变量：驱动名称、url、用户名、密码</li><li>静态代码块加载驱动</li><li>JDBCUtil提供获取Connection对象和关闭资源的方法</li><li>预编译语句对象，解决拼接sql语句太麻烦的问题</li></ul><ol start="2"><li>用连接池和配置文件改进，创建CRUDTemplate类，DML使用executeUpdate方法，DQL使用executeQuery方法</li></ol><p><img src="/2020/02/04/jdbc-note-4/19.png" alt="重构1"></p><ol start="3"><li>结果集处理器改进</li></ol><p>在实现类StudentDaoImpl中添加class StudentResHandleImp implements IResultSetHandler</p><p><img src="/2020/02/04/jdbc-note-4/20.png" alt="重构2"></p><ol start="4"><li>用泛型改进结果集处理器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IResultSetHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">handle</span> <span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类</span></span><br><span class="line"><span class="comment">// package com.it666.jdbc.dao.impl;</span></span><br><span class="line"><span class="comment">// 获取对象List的结果集处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentResHandleImp</span> <span class="keyword">implements</span> <span class="title">IResultSetHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Student</span>&gt;&gt;</span>&#123; &#125;</span><br><span class="line"><span class="comment">// 获取一个Integer的结果集处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StuCountResultSetImpl</span> <span class="keyword">implements</span> <span class="title">IResultSetHandler</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2020/02/04/jdbc-note-4/21.png" alt="重构3"></p><ol start="5"><li>用内省改进<br>针对DQL，对get()和getAll()的改进代码不同<br><img src="/2020/02/04/jdbc-note-4/22.png" alt="重构4"></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005977005.htm" target="_blank" rel="noopener">Java零基础到高级JDBC连接数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/04/jdbc-note-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC笔记-连接池</title>
      <link>https://aaronlinv.github.io/2020/02/03/jdbc-note-3/</link>
      <guid>https://aaronlinv.github.io/2020/02/03/jdbc-note-3/</guid>
      <pubDate>Mon, 03 Feb 2020 07:55:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;存储过程&quot;&gt;&lt;a href=&quot;#存储过程&quot; class=&quot;headerlink&quot; title=&quot;存储过程&quot;&gt;&lt;/a&gt;存储过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在数据库当中定义一个存储过程&lt;br&gt;&lt;img src=&quot;/2020/02/03/jdbc-note-3/1.pn
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ol><li>在数据库当中定义一个存储过程<br><img src="/2020/02/03/jdbc-note-3/1.png" alt="定义存储过程"></li><li>JDBC调用一个参数的存储过程<br><img src="/2020/02/03/jdbc-note-3/2.png" alt="jdbc执行存储过程"></li><li>编写输入参数和输出参数的存储过程<br><img src="/2020/02/03/jdbc-note-3/3.png" alt="2定义存储过程"></li><li>JDBC调用二个参数的存储过程<br><img src="/2020/02/03/jdbc-note-3/4.png" alt="2jdbc执行存储过程"></li></ol><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>模拟zs与ls进行转账<br>1.检查zs账户余额<br>2.减少zs账户1000<br>3.增加ls账户1000<br><img src="/2020/02/03/jdbc-note-3/5.png" alt="模拟转账"></p><h4 id="处理事务过程"><a href="#处理事务过程" class="headerlink" title="处理事务过程"></a>处理事务过程</h4><ol><li>关闭自动提交 conn.setAutoCommit(false);</li><li>没有问题时，提交事务 conn.commit();</li><li>出现异常时，进行回滚操作 conn.rollback()</li></ol><p><img src="/2020/02/03/jdbc-note-3/6.png" alt="模拟转账事物"></p><p>回滚之后，事务结束，释放资源<br>出现异常，没有提交，也不会更新数据库，但是会占用资源，所以要出现异常时，进行回滚操作<br>只有增、删、改才需要事务，查询不需要事务</p><p>如果代码是正确的，测试也成功，但是数据库当中的数据不变，可能是事务没有提交</p><p>InnoDB才支持外键和事务。MyISAM不支持外键和事务<br>设置事务的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_REPATABLE_READ)</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>一次性执行多条Sql语句，允许多条语句一次性提交给数据库批量处理，比单独提交处理要效率高</p><p>批处理方法</p><ul><li>addBatch(String) 添加需要批处理的sql语句</li><li>executeBatch() 最后执批处理</li></ul><p>MySQL默认情况下是不支持批处理的，从5.1.13开始，添加了一个rewriteBatchedStatement参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/jdbc_db?rewriteBatchedStatements=true"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/03/jdbc-note-3/7.png" alt="批处理"></p><h2 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h2><p>数据库当中的BLOB：以二进制流的形式存储图片、音频、视频等多媒体信息</p><p>真正开发中，不会把二进制的文件存放在数据库当中<br>而是把文件存储的路径保存在数据库当中，以后再取出路径，到该路径下读取信息</p><p>BLOB类型</p><ul><li>TINYBLOB (255个字节)</li><li>BLOB (65535字节)</li><li>MEDIUMBLOB (16M)</li><li>LONGBLOB(4G)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入图片</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception, SQLException </span>&#123;</span><br><span class="line">Connection conn = JDBCUtil.getConn();</span><br><span class="line">String sql = <span class="string">"insert into student (img) values (?)"</span>;</span><br><span class="line"></span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件转换成二进制</span></span><br><span class="line">ps.setBlob(<span class="number">1</span>, <span class="keyword">new</span> FileInputStream(<span class="string">"d:/test.jpg"</span>));</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">JDBCUtil.close(conn, ps, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据库图片</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Connection conn = JDBCUtil.getConn();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select * from student where id=?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="comment">// 获取图片</span></span><br><span class="line">Blob blob = rs.getBlob(<span class="string">"img"</span>);</span><br><span class="line"><span class="comment">// 获取图片二进制流</span></span><br><span class="line">InputStream in = blob.getBinaryStream();</span><br><span class="line"><span class="comment">// 写入磁盘</span></span><br><span class="line">Files.copy(in, Paths.get(<span class="string">"d:/myxq.jpg"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JDBCUtil.close(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取自动生成的主键"><a href="#获取自动生成的主键" class="headerlink" title="获取自动生成的主键"></a>获取自动生成的主键</h2><p>需求场景<br>用户注册时，添加用户名，密码后，插入到数据库当中<br>跳转成完善个人信息页，完善信息更新到刚插入的那个记录当中，所以要获取刚插入的那个主键是多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection conn = JDBCUtil.getConn();</span><br><span class="line">    String sql = <span class="string">"insert into stu (name,age) values (?,?)"</span>;</span><br><span class="line">    <span class="comment">//PreparedStatement sql参数是在定义的时候设置的，所有与Statement不同的是，这个的RETURN_GENERATED_KEYS 是设置在这定义这里</span></span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">    </span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">"张三"</span>);</span><br><span class="line">    ps.setInt(<span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 这里面是空的</span></span><br><span class="line">    ps.executeUpdate();</span><br><span class="line">    </span><br><span class="line">    ResultSet rs = ps.getGeneratedKeys();</span><br><span class="line">    <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id =rs.getInt(<span class="number">1</span>);<span class="comment">//获取第一列</span></span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line">    JDBCUtil.close(conn, ps, rs);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection conn = JDBCUtil.getConn();</span><br><span class="line">    String sql = <span class="string">"insert into stu (name,age) values ('张三',30)"</span>;</span><br><span class="line">    </span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line">    <span class="comment">// 1.创建语句时，设置可以获取主键</span></span><br><span class="line">    st.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">    <span class="comment">// 2.通过语句对象的getGeneratedKeys获取主键</span></span><br><span class="line">    ResultSet rs = st.getGeneratedKeys();</span><br><span class="line">    <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id =rs.getInt(<span class="number">1</span>);<span class="comment">//获取第一列</span></span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line">    JDBCUtil.close(conn, st, rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h4 id="没有连接池的情况"><a href="#没有连接池的情况" class="headerlink" title="没有连接池的情况"></a>没有连接池的情况</h4><ul><li>每次CRUD操作都要使用数据库的时候，都要创建一个数据库连接对象</li><li>普通的JDBC数据库连接使用 DriverManager 来获取</li><li>每次向数据库建立连接的时候都要将 Connection 加载到内存中</li><li>然后再验证用户名和密码花费时间0.05s～1s左右</li><li>每次CRUD操作就向数据库要一个连接</li><li>执行完成后再断开连接，这样的方式将会消耗大量的资源和时间，若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃</li></ul><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><ul><li>池<br>保存对象的容器</li><li>连接池<br>保存数据库连接对象的容器</li><li>作用<br>初始化时创建一定数量的对象。需要时直接从池中取出一个空闲对象<br>用完后并不直接释放掉对象，而是再放到对象池中以方便下一次对象请求可以直接复用<br>池技术的优势是，可以消除对象创建所带来的延迟，从而提高系统的性能 </li><li>数据库连接池<br>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”<br>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时<br>只需从“缓冲池”中取出一个，使用完毕之后再放回去<br>我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接<br>可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据</li></ul><p><img src="/2020/02/03/jdbc-note-3/8.png" alt="连接池"><br>连接对象是以链表形式存放，已释放的连接，放到最后</p><h4 id="连接池中的属性"><a href="#连接池中的属性" class="headerlink" title="连接池中的属性"></a>连接池中的属性</h4><p>合理的设置连接池的属性，会提高连接池的性能</p><ol><li>连接数据库时需要的4个要素<br>驱动名称，数据库地址，用户名，密码</li><li>初始化连接数<br>初始化时，连接池当中创建多少个Connection对象</li><li>最大连接数<br>连接池当中最多存储多少个Connection对象</li><li>最小连接数<br>连接池当中最少得存多个少Connection对象</li><li>最大的空闲时间<br>如果一个获取了连接对象，在指定时间内没有任何动作，就会自动释放链接</li><li>最大等待时间<br>在指定时间内，尝试获取连接，如果超出了指定时间，就会提示获取失败</li></ol><h4 id="连接池使用"><a href="#连接池使用" class="headerlink" title="连接池使用"></a>连接池使用</h4><p>连接池是使用javax.sql.DataSource接口来表示连接池<br>DataSource和jdbc一样，也是只提供一个接口，由第三方组织来提供<br>DataSource数据源和连接池Connection Pool是同一个东西，只是叫法不一样而已</p><p>常见连接池</p><ul><li>DBCP<br>Spring推荐，Tomcat的数据源使用的就是DBCP</li><li>C3P0<br>C3P0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布<br>从2007年就没有更新了，性能比较差</li><li>Druid<br>阿里巴巴提供的连接池-德鲁伊-号称最好的连接池，它里面除了这些， 还有更多的功能</li></ul><p>使用连接池与不使用连接池区别</p><ol><li>获取方式不同<br>传统：Connection conn = DriverManager.getConnection(url.userName,pwd);<br>连接池：Conneciton conn = DataSource对象.getConnection();</li><li>释放资源不同<br>传统：和数据库断开conn.close();<br>连接池：把数据库连接对象还给连接池，还可以给下一个人来使用</li></ol><h4 id="创建DataSource"><a href="#创建DataSource" class="headerlink" title="创建DataSource"></a>创建DataSource</h4><p>使用DBCP，DBCP是Apache软件基金组织下的开源连接池实现</p><p>1.导入相关的jar包<br>commons-dbcp-1.4.jar<br>commons-pool-1.5.6.jar<br>记得build path</p><p><img src="/2020/02/03/jdbc-note-3/9.png" alt="DBCP"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>以.properties作为扩展名的文件<br>把库的连接地址，用户名，密码都写在了代码当中，不便于后期的维护<br>专门为数据库提供一个配置文件，里面就专门存放连接数据库的相关信息</p><p>配置文件的书写</p><ul><li>db.properties</li><li>内部是以key-value的形式存放<br>userName=root<br>password=1234</li><li>在Java中读取配置文件</li></ul><p><img src="/2020/02/03/jdbc-note-3/10.png" alt="配置文件"></p><h4 id="改写配置文件"><a href="#改写配置文件" class="headerlink" title="改写配置文件"></a>改写配置文件</h4><p>创建一个Source Folder文件夹，命名为:resource<br>只有Source Folder才会编译到字节码中，会编译到bin目录中<br><img src="/2020/02/03/jdbc-note-3/11.png" alt="Source Folder"></p><p>创建db.properties配置文件，注意key值必须和规定的一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/jdbc_db</span><br><span class="line">username=root</span><br><span class="line">password=1234</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>修改后的JDBCUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.util;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataSource ds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"resource/db.properties"</span>);</span><br><span class="line">p.load(in);</span><br><span class="line"></span><br><span class="line">ds = DruidDataSourceFactory.createDataSource(p);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ds.getConnection();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close方法没有变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement st, ResultSet rs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Druid"><a href="#使用Druid" class="headerlink" title="使用Druid"></a>使用Druid</h4><p>开源地址：<a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">https://github.com/alibaba/druid</a><br>Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。DruidDataSource是最好的数据库连接池</p><p>从DBCP到Druid<br>DruidDataSource的配置是兼容DBCP的，从DBCP迁移到DruidDataSource，只需要修改数据源的实现类就可以了<br>只需要导入jar包(druid-1.0.15.jar)，修改代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改创建DataSource的实现类即可，将Basic修改为Druid</span></span><br><span class="line">ds = BasicDataSourceFactory.createDataSource(p); <span class="comment">// DBCP</span></span><br><span class="line">ds = DruidDataSourceFactory.createDataSource(p); <span class="comment">// Druid</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005977005.htm" target="_blank" rel="noopener">Java零基础到高级JDBC连接数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/03/jdbc-note-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC笔记-DAO</title>
      <link>https://aaronlinv.github.io/2020/02/03/jdbc-note-2/</link>
      <guid>https://aaronlinv.github.io/2020/02/03/jdbc-note-2/</guid>
      <pubDate>Mon, 03 Feb 2020 06:19:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;DAO设计规范&quot;&gt;&lt;a href=&quot;#DAO设计规范&quot; class=&quot;headerlink&quot; title=&quot;DAO设计规范&quot;&gt;&lt;/a&gt;DAO设计规范&lt;/h2&gt;&lt;p&gt;编写DAO组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义DAO接口&lt;/li&gt;
&lt;li&gt;编写对应DAO实现类&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="DAO设计规范"><a href="#DAO设计规范" class="headerlink" title="DAO设计规范"></a>DAO设计规范</h2><p>编写DAO组件</p><ol><li>定义DAO接口</li><li>编写对应DAO实现类</li></ol><p>面向接口编程<br>根据客户提出的需求，定义接口，业务具体实现是通过实现类来完成<br>当客户提出新的需求，只需要编写该业务逻辑新的实现类<br>好处</p><ul><li>业务逻辑更加清晰</li><li>增强代码的扩展性，可维护性</li><li>接口和实现相分离，适合团队协作开发</li><li>降低耦合度，便于以后升级扩展</li></ul><p>包名的规范</p><p>域名倒写.模块名称.组件名称</p><ul><li>存储所有的domain：package com.it666.jdbc.domain</li><li>存储所有的dao接口：page com.it666.jdbc.dao</li><li>存储所有的Dao接口实现类：page com.it666.jdbc.dao.impl</li><li>存储Dao组件的测试类：page com.it666.jdbc.dao.test</li></ul><p>类名规范</p><ul><li>domain类：存储在domain包中，用于描述一个对象，是一个javaBean,写时要见名知意</li><li>dao接口：存储在dao包中，用于表示某一个对象的CRUD声明，起名规范IDomainDao</li><li>dao实现类：存储到dao.impl包中，用于表示DAO接口的实现类，要实现DAO接口</li></ul><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li>创建表</li><li>建立domain包和domain类</li><li>建立dao包和dao接口</li><li>建立dao.impl包和dao实现类</li><li>根据dao接口创建dao测试类</li><li>编写实现类当中dao的声明的方法体</li><li>每编写一个dao方法，进行测试功能是否正确</li></ol><p>（放大图片，Chrome浏览器可以用imagus插件，或者按Ctrl和加号键，Ctrl和0 还原网页大小）<br>建立stu表，设置id,name,age字段，id设置为主键和自动递增</p><p><img src="/2020/02/03/jdbc-note-2/1.png" alt="包结构"><br><img src="/2020/02/03/jdbc-note-2/2.png" alt="内部结构"></p><p>写IStudentDao接口，写类StudentDaoImpl应用接口，重写方法<br>写完一个方法就在测试类中写测试方法</p><p>使用单元测试，在测试StudentDaoTest类中，写一个public方法<br>在方法上面加@Test，Ctrl+1 选择Adds the JUnit 4 library to the build path.<br>点想要单元测试的方法，点击运行或者Ctrl+F11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setName(<span class="string">"al"</span>);</span><br><span class="line">    stu.setAge(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    IStudentDao dao = <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">    dao.save(stu);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存方法<br><img src="/2020/02/03/jdbc-note-2/3.png" alt="保存方法"></p><p>删除方法<br><img src="/2020/02/03/jdbc-note-2/4.png" alt="删除方法"></p><p>修改方法<br><img src="/2020/02/03/jdbc-note-2/5.png" alt="修改方法"></p><p>获取一个学生<br><img src="/2020/02/03/jdbc-note-2/6.png" alt="获取一个学生"></p><p>获取所有学生<br><img src="/2020/02/03/jdbc-note-2/7.png" alt="获取所有学生"></p><h2 id="预编译语句"><a href="#预编译语句" class="headerlink" title="预编译语句"></a>预编译语句</h2><p>Statement接口：用于进行Java程序和数据库之间的数据传输<br>具体类有3个实现</p><ul><li>Statement：用于对数据库进行通用访问，使用的是静态sql</li><li>PreparedStatement：用于预编译模板SQL语句,在运行时接受sql输入参数</li><li>CallableStatement：要访问数据库存储过程时使用，也可以接受运行时输入参数</li></ul><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>没有预编译语句，所有的sql都是进行拼接</p><p>PreparedStatement 用于预编译模板SQL语句<br>在性能和代码灵活性上有显著地提高<br>PreparedStatement 对象使用 ? 作为占位符，即参数标记<br>使用 setXXX( index，value) 方法将值绑定到参数中，index是引用顺序从 1 开始</p><p>PreparedStatement 对象执行SQL语句（注意，它们都没有参数，不同于Statement要传入sql语句）</p><ul><li>executeQuery()</li><li>executeUpdate()</li></ul><p>内部优化：MySql不支持，Oracle支持<br>预编译语句更安全，防止sql注入（通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令）</p><p>PreparedStatement能防止注入是因为它把单引号转义了，变成了&#39;<br>这样一来，就无法截断SQL语句，进而无法拼接SQL语句 基本上没有办法注入了<br><img src="/2020/02/03/jdbc-note-2/8.png" alt="sql注入"></p><h2 id="重构1-抽取JDBCUtil"><a href="#重构1-抽取JDBCUtil" class="headerlink" title="重构1-抽取JDBCUtil"></a>重构1-抽取JDBCUtil</h2><ol><li>每一个DAO方法当中都会写驱动名称、url、用户名、密码，把公共的这些声明为成员变量，在一个类当中能够共享这些成员变量</li><li>不需要每次都注册驱动，把加载驱动放到静态代码块当中，只会在类被加载到JVM时，才会执行一次</li><li>每个dao方法每次操作只需要connection对象，至于是怎么样创建的不关心，把创建Connection代码抽取到jdbcUtil当中，并提供一个getConn就能够获得连接对象</li><li>每个dao方法都要关闭资源，在util当中提供一个方法专门关闭资源，在方法当中传入要关闭哪些资源</li><li>DAO方法中，拼接SQL太麻烦，要使用预编译语句对象</li></ol><ol start="6"><li>（代办）DAO方法当中每次都创建一个connection对象，用完就关闭了，创建Connection成本很大，通过数据库连接池来解决</li><li>（代办）JDBCUtil当中的用户名，密码这些信息都写到了文件当中，不便于维护，给写到一个单独的配置文件当中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.util;</span></span><br><span class="line"><span class="comment">// 需要import包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.公共成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/jdbc_db"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String password = <span class="string">"1234"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">注意！！变量这些要写在前面，如果把静态代码块写在静态字段前，会导致这些变量无法初始化（报错：初始化异常）</span></span><br><span class="line"><span class="comment">    因为这些静态变量都是在静态代码块中初始化的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 加载驱动只执行一次，用静态代码块加载驱动   </span></span><br><span class="line">Class.forName(driverName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 3.getConn方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 4.close方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement st, ResultSet rs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改StudentDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.it666.jdbc.dao.impl;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 5.使用预编译语句</span></span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;<span class="comment">// 用预编译语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line">String sql = <span class="string">"insert into stu (name,age) values (?,?)"</span>; <span class="comment">// 预编译语句用?占位</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ps.setString(<span class="number">1</span>, stu.getName());<span class="comment">// 设置第一个占位符?的值</span></span><br><span class="line">ps.setInt(<span class="number">2</span>, stu.getAge());</span><br><span class="line"></span><br><span class="line">ps.executeUpdate(); <span class="comment">//执行sql语句</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">JDBCUtil.close(conn, ps, <span class="keyword">null</span>); <span class="comment">//因为PreparedStatement是Statement的实现类，所以可以传入ps</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DML语句同理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, Student stu)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line">String sql = <span class="string">"select * from stu where id = ?"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ps.setInt(<span class="number">1</span>, id);</span><br><span class="line"></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">stu.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">stu.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line"><span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">JDBCUtil.close(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line">String sql = <span class="string">"select * from stu"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line">List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">stu.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">stu.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">stu.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">list.add(stu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">JDBCUtil.close(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005977005.htm" target="_blank" rel="noopener">Java零基础到高级JDBC连接数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/03/jdbc-note-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC笔记-基础</title>
      <link>https://aaronlinv.github.io/2020/02/01/jdbc-note-1/</link>
      <guid>https://aaronlinv.github.io/2020/02/01/jdbc-note-1/</guid>
      <pubDate>Sat, 01 Feb 2020 04:01:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;JDBC-概述&quot;&gt;&lt;a href=&quot;#JDBC-概述&quot; class=&quot;headerlink&quot; title=&quot;JDBC 概述&quot;&gt;&lt;/a&gt;JDBC 概述&lt;/h2&gt;&lt;p&gt;Java数据库连接 (Java Database Connectivity)&lt;br&gt;用于执行SQL语
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="JDBC-概述"><a href="#JDBC-概述" class="headerlink" title="JDBC 概述"></a>JDBC 概述</h2><p>Java数据库连接 (Java Database Connectivity)<br>用于执行SQL语句的Java API，它由一组用Java语言编写的类和接口组成<br>JDBC提供了一种操作数据的标准，JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统</p><p>java.sql包装的就是JDBC的API<br><img src="/2020/02/01/jdbc-note-1/1.png" alt="高新强"></p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><p>新建一个lib文件夹，拖入MySQL驱动，builder path 编译路径<br><img src="/2020/02/01/jdbc-note-1/2.png" alt="加载驱动"></p><p>查看驱动相关API：Ctrl+Shift+T 查找driver，关联源码<br><img src="/2020/02/01/jdbc-note-1/3.png" alt="关联源码"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_01Connect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把com.mysql.jdbc.Driver这份字节码加载进JVM，会执行该字节码中的静态代码块</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">// ClassNotFoundException异常</span></span><br><span class="line"></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/jdbc_db"</span>;<span class="comment">// 需要创建jdbc_db这个数据库</span></span><br><span class="line">String user = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"1234"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);<span class="comment">// SQLException异常</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从1.6开始它会自动读这个文件，不用手动加载驱动<br>在JavaWeb中不支持自动注册，所以以后我们都要自己手动写上</p><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>用Statement接口执行静态SQL语句对象</p><p>把SQL语句发送到数据库中去执行，并返回执行的结果</p><ul><li>对于DQL返回查询的结果集</li><li>对于DML返回受影响的行数</li><li>对于DDL返回0</li></ul><p>执行sql后需要释放资源<br>Connection连接就相当于Java和到Mysql之间建立管道<br>Statement就相当于从数据库又接了一个管道连接MySQL的执行程序<br><img src="/2020/02/01/jdbc-note-1/4.png" alt="释放资源"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/jdbc_db"</span>;</span><br><span class="line">String user = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"create table jdbc_stu(id int,name varchar(30),age int)"</span>;</span><br><span class="line"><span class="keyword">int</span> row = st.executeUpdate(sql);</span><br><span class="line">System.out.println(row);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行DML和执行DDL步骤相同，只有sql语句发生了改变</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>常用方法</p><ul><li>boolean  next():判断是否有下一行数据,若有,则向下移动一行指针</li><li>getXxx(int columnIndex):获取当前行中,第几列.(从1开始)不推荐</li><li>getXxx(String columnName):获取当前行中的,指定列名的列的值.columnName是列名/列的别名</li><li>若列的类型是VARCHAR/CHAR/TEXT,都使用getString来获取列的值</li><li>若列的类型是int/integer/–&gt;getInt来获取列的值<br><img src="/2020/02/01/jdbc-note-1/5.png" alt="MySQL与Java数据类型对照表"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/jdbc_db"</span>;</span><br><span class="line">String user = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 1.executeQuery(Sql)会得到一个结果集ResultSet，最后也需要释放</span></span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.executeQuery执行DQL返回一个结果集</span></span><br><span class="line">String sql = <span class="string">"select * from emp where ename = '李白' "</span>;<span class="comment">//需要有建emp表，否则会报错</span></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line"><span class="keyword">int</span> salary = rs.getInt(<span class="string">"salary"</span>);</span><br><span class="line">System.out.println(<span class="string">"姓名："</span>+ename+<span class="string">" 薪水："</span>+salary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.结果集也要释放</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAO设计"><a href="#DAO设计" class="headerlink" title="DAO设计"></a>DAO设计</h2><p>Data Access Object（数据存取对象）<br>位于业务逻辑和持久化数据之间，实现对持久化数据的访问<br>解决问题：多个地方都要都同时做CRUD操作时，重复的代码就会很多<br><img src="/2020/02/01/jdbc-note-1/6.png" alt="DAO示例图"></p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>Object Relational Mapping（对象关系映射）<br>将关系数据库中表中的记录映射成为对象，以对象的形式展现<br>方便开发人员以面向对象的思想来实现对数据库的操作<br><img src="/2020/02/01/jdbc-note-1/7.png" alt="对应关系"><br><img src="/2020/02/01/jdbc-note-1/8.png" alt="ORM示例图"></p><h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h2><p>符合JavaBean规范的类<br>JavaBean：一个类当中有字段和该字段的getter与Setter方法<br>作用：是用户与数据库交互的核心中转站</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005977005.htm" target="_blank" rel="noopener">Java零基础到高级JDBC连接数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/02/01/jdbc-note-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL数据库进阶2</title>
      <link>https://aaronlinv.github.io/2020/01/27/mysql-note-5/</link>
      <guid>https://aaronlinv.github.io/2020/01/27/mysql-note-5/</guid>
      <pubDate>Mon, 27 Jan 2020 11:29:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;存储过程&quot;&gt;&lt;a href=&quot;#存储过程&quot; class=&quot;headerlink&quot; title=&quot;存储过程&quot;&gt;&lt;/a&gt;存储过程&lt;/h2&gt;&lt;p&gt;一组可编程的函数，是为了完成特定功能的SQL语句集&lt;br&gt;经编译创建并保存在数据库字典中，用户可通过指定存储过程的名字并给定
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>一组可编程的函数，是为了完成特定功能的SQL语句集<br>经编译创建并保存在数据库字典中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行</p><p>为什么要用存储过程</p><ul><li>将重复性很高的一些操作，封装到一个存储过程中，简化了对这些SQL的调用</li><li>批量处理</li><li>统一接口，确保数据的安全</li><li>相对于Oracle数据库来说，MySQL的存储过程相对功能较弱，使用较少</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">语句</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span>  存储过程名称();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询指定数据库中的存储过程</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span> <span class="keyword">where</span> db=<span class="string">'数据库名称'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询存储过程详情</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除存储过程</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span>  存储过程名称;</span><br></pre></td></tr></table></figure><h4 id="DELIMITER"><a href="#DELIMITER" class="headerlink" title="DELIMITER"></a>DELIMITER</h4><p>修改标准分隔符，这个命令与存储过程语法无关<br>作用是告诉MySQL解释器，该段命令是否已经结束了<br>默认情况下，DELIMITER是分号; ，在命令行客户端中，如果有一行命令以分号结束，那么回车后MySQL将立即执行该语句</p><p>在为可能输入较多的语句，且语句中包含有分号,DELIMITER $$ 把标准分隔符; 修改为$$，这样只有当$$出现之后，MySQL解释器才会执行这段语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> show_emp()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">call</span> show_emp();</span><br></pre></td></tr></table></figure><h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> <span class="keyword">test</span>()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- 声明变量</span></span><br><span class="line"><span class="comment">-- DECLARE 变量名 数据类型(大小) DEFAULT 默认值;</span></span><br><span class="line"><span class="keyword">declare</span> res <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">''</span>;</span><br><span class="line"><span class="comment">-- 声明多个变量</span></span><br><span class="line"><span class="keyword">declare</span> x,y <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过into 赋值</span></span><br><span class="line"><span class="keyword">declare</span> avgRes <span class="keyword">double</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">into</span> avgRes <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出变量</span></span><br><span class="line"><span class="keyword">select</span> avgRes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h4 id="存储过程参数"><a href="#存储过程参数" class="headerlink" title="存储过程参数"></a>存储过程参数</h4><ul><li>IN 传入值</li><li>OUT 传出值</li><li>INOUT IN和OUT参数的组合</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> produce <span class="keyword">name</span>(参数类型 参数名称 数据类型(大小) )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN 传入值</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getName (<span class="keyword">in</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename = <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">-- 传入参数</span></span><br><span class="line"><span class="keyword">call</span> getName(<span class="string">'李白'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- OUT 传出值</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getSalary(<span class="keyword">in</span> n <span class="built_in">varchar</span>(<span class="number">255</span>), <span class="keyword">out</span> eSalary <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">into</span> eSalary <span class="keyword">from</span> emp <span class="keyword">where</span> ename = n;</span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">-- 传入参数</span></span><br><span class="line"><span class="keyword">call</span> getSalary(<span class="string">'李白'</span>,@s);</span><br><span class="line"><span class="keyword">select</span> @s;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- INOUT IN和OUT参数的组合</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getNum(inout <span class="keyword">num</span> <span class="built_in">int</span>,<span class="keyword">in</span> x <span class="built_in">int</span> )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span> + x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置变量 传入参数</span></span><br><span class="line"><span class="keyword">set</span> @num1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">call</span> getNum(@num1,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">select</span> @num1;</span><br></pre></td></tr></table></figure><h4 id="存储过程语句"><a href="#存储过程语句" class="headerlink" title="存储过程语句"></a>存储过程语句</h4><p>IF语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF expression THEN </span><br><span class="line">statements;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">IF expression THEN</span><br><span class="line">statements;</span><br><span class="line">ELSE</span><br><span class="line">else-statements;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure><p>CASE语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE  case_expression</span><br><span class="line">WHEN when_expression_1 THEN commands</span><br><span class="line">WHEN when_expression_2 THEN commands</span><br><span class="line">...</span><br><span class="line">ELSE commands</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>循环语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- while循环</span></span><br><span class="line">WHILE expression <span class="keyword">DO</span></span><br><span class="line">statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- repeat循环</span></span><br><span class="line"><span class="keyword">REPEAT</span></span><br><span class="line">statements;</span><br><span class="line">UNTIL expression</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span></span><br></pre></td></tr></table></figure><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 随机生成字符串</span></span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="comment">-- 注意return加s</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_str(n <span class="built_in">int</span>) <span class="keyword">returns</span> <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明一个str 52个字母</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">str</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 记录当前是第几个字符</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> res_str <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">while i &lt; n do</span><br><span class="line"><span class="comment">-- 生成1-52 ：floor(1+RAND()*52)  floor()去掉小数</span></span><br><span class="line"><span class="comment">-- substr(str,floor(1+RAND()*52),1); -- 最后一个代表截取一位</span></span><br><span class="line"><span class="keyword">set</span> res_str = <span class="keyword">concat</span>(res_str,<span class="keyword">substr</span>(<span class="keyword">str</span>,<span class="keyword">floor</span>(<span class="number">1</span>+<span class="keyword">RAND</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"></span><br><span class="line">return res_str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用自定义函数</span></span><br><span class="line"><span class="keyword">select</span> rand_str(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="创建千万条数据"><a href="#创建千万条数据" class="headerlink" title="创建千万条数据"></a>创建千万条数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- create table emp (id int,name varchar(50),age int);</span></span><br><span class="line"><span class="comment">-- 插入</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp(<span class="keyword">in</span> startNum <span class="built_in">int</span>,<span class="keyword">in</span> max_num <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 默认自动提交sql，这样比较慢，设置为不自动提交sql</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span> (startNum+i,rand_str(<span class="number">5</span>),<span class="keyword">floor</span>(<span class="number">10</span>+<span class="keyword">rand</span>()*<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">until i = max_num</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 整体提交所有sql，提高效率 </span></span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> insert_emp(<span class="number">100</span>,<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>帮助MySQL高效获取数据的数据结构</p><p>优势</p><ul><li>索引类似大学图书馆建立的书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引对数据项进行排序，降低数据排序成本，降低了CPU的消耗</li></ul><p>劣势</p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占空间的</li><li>虽然索引大大提高了查询速度，同时确会降低更新表的速度，如对表进行INSERT、UPDATE、DELETE</li></ul><p>索引分类</p><ul><li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：一个索引包含多个列 INDEX MultiIdx(id,name,age)</li><li>全文索引：只能在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引</li><li>空间索引：只能在MyISAM引擎上才能使用，对空间数据类型的字段建立索引</li></ul><p>索引操作<br>自动创建索引</p><ul><li>在表上定义了主键时， 会自动创建一个对应的唯一索引</li><li>在表上定义了一个外键时，会自动创建一个普通索引</li></ul><p>explain<br>用来查看索引是否正在被使用，并且输出其使用的索引的信息</p><ul><li>key：实际选用的索引</li><li>key_len：显示了MySQL使用索引的长度(也就是使用的索引个数)，当 key 字段的值为 null时，索引的长度就是 null。注意，key_len的值可以告诉你在联合索引中mysql会真正使用了哪些索引。这里就使用了1个索引，所以为1，</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="comment">-- CREATE INDEX 索引名称 ON table (column[, column]...);</span></span><br><span class="line"><span class="comment">-- 默认是NORMAL类型索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">INDEX</span> salary_index <span class="keyword">ON</span> emp(salary);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名称 <span class="keyword">ON</span> 表名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>索引方法：innoDB不支持Hash，只能Btree<br>Btree索引：B+树<br>Hash索引：哈希算法</p><p>哪些情况需要创建索引</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引</li><li>WHERE条件里用不到的字段不创建索引</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p>哪些情况不需要创建索引</p><ul><li>表记录太少</li><li>经常增删改的表</li><li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005932016.htm" target="_blank" rel="noopener">Java零基础到高级MySQL数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/01/27/mysql-note-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL数据库进阶1</title>
      <link>https://aaronlinv.github.io/2020/01/23/mysql-note-4/</link>
      <guid>https://aaronlinv.github.io/2020/01/23/mysql-note-4/</guid>
      <pubDate>Thu, 23 Jan 2020 13:28:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h4 id=&quot;字符串函数&quot;&gt;&lt;a href=&quot;#字符串函数&quot; class=&quot;headerlink&quot; title=&quot;字符串函数&quot;&gt;&lt;/a&gt;字符串函
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>concat(s1,s2…sn)将传入的字符连接成一个字符串，任何字符串与null进行连接结果都是null</p><p>insert(str,x,y,instr)将字符串str从x位置开始，y个字符长的子串替换为指定的字符</p><p>LOWER(Str)和UPPER(str)将字符串转成小写或大写</p><p>LEFT(str,x)和RIGHT(str，x)分别返回字符串最左边的x个字符和最右边的x个字符，如果第二个参数为null，不返回任何字符</p><p>LPAD（str,n,pad）和RPAD(str,n,pad)用字符串pad对str最左边或最右边进行填充，直接到长度为n个字符长度</p><p>LTRIM(str)和RTRIM(str)去掉字符串当中最左侧和最右侧的空格</p><p>TRIM(str)去掉字符串左右的空格</p><p>REPEAT(str,x)返回str重复x次的结果REPLACE(str,a,b)用字符串b替换字符串str中所有出现的字符串a.</p><p>SUBSTRING(str,x,y)返回字符串str中第x位置起y个字符长度的字符</p><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p>ABS(x)返回X的绝对值</p><p>CEIL(x)小数不为零部分上取整，即向上取最近的整数</p><p>FLOOR(x)小数部分下取整，即向下取最近的整数</p><p>MOD(x,y)返回X/Y的模</p><p>RAND()返回0-1内容的随机值</p><h4 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h4><p>CURDATE()返回当前日期，只包含年月日</p><p>CURTIME()返回当前时间，只包含时分秒</p><p>NOW()返回当前日期和时间，年月日时分秒都包含</p><p>UNIX_TIMESTAMP返回当前日期的时间戳</p><p>FROM_UNIXTIME(unixtime)将一个时间戳转换成日期</p><p>WEEK(DATE)返回当前是一年中的第几周</p><p>YEAR(DATE)返回所给日期是那一年</p><p>HOUR(TIME)返回当前时间的小时</p><p>MINUTE(TIME)返回当前时间的分钟</p><p>DATE_FORMAT(date,fmt)按字符串格式化日期date值</p><p>DATE_ADD(date,interval expr type)计算日期间隔</p><p>DATEDIFF(date1,date2)计算两个日期相差的天数</p><p>流程函数<br>IF(value,t,f)如果value是真，返回t,否则返回f</p><p>IFNULL(value1,value2)如果value1不为空，返回value1否者返回value2</p><p>CASE WHEN THEN END</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="number">2</span>&gt;<span class="number">3</span> <span class="keyword">then</span> <span class="string">'对'</span> <span class="keyword">else</span> <span class="string">'错'</span> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><p>DATABASE()返回当前数据库名</p><p>VERSION()返回当前数据库版本</p><p>USER()返回当前登陆用户名</p><p>PASSWORD(STR)对str进行加密</p><p>MD5()返回str的MD5值</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>不可分割的操作，假设该操作有ABCD四个步骤组成<br>若ABCD四个步骤都成功完成,则认为事务成功，若ABCD中任意一个步骤操作失败，则认为事务失败<br>每条sql语句都是一个事务，事务只对DML语句有效，<strong>对于DQL无效</strong></p><h4 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h4><ul><li>原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li><li>一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</li><li>隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li><li>持久性（Durability）持久性是指一个事务一旦被提交了，就不能再回滚了，已经把数据保存到数据库当中了</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 需要手动开启事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line"><span class="comment">-- 执行update后查询score没有被改变</span></span><br><span class="line"><span class="comment">-- 事务对于DQL无效</span></span><br><span class="line"><span class="keyword">update</span> score <span class="keyword">set</span> score = <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 执行了commit后，数据才会改变</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 如果想撤销之前的sql语句使用回滚</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h4 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h4><ul><li>脏读:读取到了别的事务回滚前的脏数据</li><li>不可重复读：一个事务两次相同的查询却返回了不同数据（两次查询中被其他事务修改了数据）</li><li>幻读：开启事务查询，另一个事务插入或删除数据并提交，再次查询发现与原来数据不同，像是出现了幻觉</li></ul><p>不可重复读的重点是<strong>修改</strong>，同样的条件，你读取过的数据，再次读取出来发现值不一样；（主要在于update和delete）<br>幻读的重点在于<strong>新增或者删除</strong>，同样的条件，第 1 次和第 2 次读出来的记录数不一样。（主要在于insert）</p><table><thead><tr><th align="center">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交（read-uncommitted）</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">不可重复读（read-committed）</td><td align="center"></td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读（repeatable-read）</td><td align="center"></td><td align="center"></td><td align="center">是</td></tr><tr><td align="center">串行化（serializable）</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>Read uncommitted：读未提交，一个事务可以读取另一个未提交事务的数据<br>Read committed：读提交，一个事务要等另一个事务提交后才能读取数据<br>Repeatable read：重复读，在开始读取数据（事务开启）时，不再允许删除或修改操作 (MySQL默认这个级别)<br>Serializable：事务串行化顺序执行，可以避免脏读、不可重复读与幻读，这种事务隔离级别效率低下，比较耗数据库性能，一般不使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@global.tx_isolation,@@tx_isolation;</span><br><span class="line"><span class="comment">-- 修改当前会话隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别;</span><br><span class="line"><span class="comment">-- 修改全局会话隔离级别（需要重开会话）</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br></pre></td></tr></table></figure><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>限制一个用户能够做什么事情，在MySQL中，可以设置全局权限，指定数据库权限，指定表权限，指定字段权限</p><p>权限分类<br>CREATE 创建数据库、表或索引权限<br>DROP 除数据库或表权限<br>ALTER 更改表，比如添加字段、索引等<br>DELETE 删除数据权限<br>INDEX 索引权限<br>INSERT 插入权限<br>SELECT 查询权限<br>UPDATE 更新权限<br>CREATE VIEW 创建视图权限<br>EXECUTE 执行存储过程权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户 ，新建的用户只能看到information_schema数据库 ，下面不加单引号也可</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"><span class="comment">-- 分配权限 (把mytest数据库里所有表的select权限分配给用户dev)</span></span><br><span class="line"><span class="comment">-- with grant option 表示这个被授予权限的用户可以把权限传递给其他用户</span></span><br><span class="line"><span class="comment">-- flush privileges; 刷新权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> my_test.* <span class="keyword">to</span> dev@localhost  <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对所有数据库的所有权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> dev@localhost  <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分配一个用户只能对stu表进行CRUD操作的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">select</span>,<span class="keyword">delete</span> <span class="keyword">on</span> my_test.stu <span class="keyword">to</span> privuser@localhost ;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span></span><br><span class="line"><span class="comment">-- 查看指定用户的权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> root@localhost</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除权限</span></span><br><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> 数据库对象 <span class="keyword">from</span> 用户名@localhost；</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> 用户名@localhost;</span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是一个虚拟表，其内容由查询定义</p><p>视图是对若干张基本表的引用，一张虚表，查询语句执行的结果<br>不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）<br>可以跟基本表一样，进行增删改查操作(增删改操作有条件限制)</p><p>优点：安全性 提高查询性能 提高数据独立性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_salary_view</span><br><span class="line"><span class="keyword">as</span>(<span class="keyword">select</span> * <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="number">2000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询视图</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_salary_view;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改视图  </span></span><br><span class="line"><span class="comment">-- create or replace view</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> emp_salary_view</span><br><span class="line"><span class="keyword">as</span>(<span class="keyword">select</span> * <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="number">2999</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> emp_salary_view;</span><br></pre></td></tr></table></figure><p>ALGORITHM参数</p><ul><li>MERGE：替换式，可以通过修改视图数据更新真实表中的数据</li><li>TEMPTABLE：具化式，由于数据存储在临时表中，所以不可以进行更新操作</li><li>UNDEFINED：没有定义ALGORITHM参数，MySQL更倾向于选择MERGE替换方式，因为它更加有效</li></ul><p>替换式与具化式区别</p><ul><li>MERGE替换式，将视图公式替换后，当成一个整体sql进行处理了</li><li>TEMPTABLE具化式，先处理视图结果，该结果形成一个中间结果暂时存在内存中，后处理外面的查询需求</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MERGE替换式（MySQL默认方式）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> salary&gt;<span class="number">2000</span>) t;</span><br><span class="line"><span class="comment">-- TEMPTABLE具化式</span></span><br><span class="line"><span class="comment">-- (select * from emp where salary&gt;2000) as temptable; 不可执行用于理解</span></span><br><span class="line"><span class="comment">-- select * from temptable1;</span></span><br></pre></td></tr></table></figure><p>WITH CHECK OPTION</p><ul><li>更新数据时不能插入或更新不符合视图限制条件的记录</li></ul><p>LOCAL和CASCADED</p><ul><li>WITH [CASCADED|LOCAL] CHECK OPTION</li><li>为可选参数，决定了检查测试的范围，MySQL默认值为CASCADED</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- with check option</span></span><br><span class="line"><span class="comment">-- 通过视图修改salary的值就不能小等于2500</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_s_v</span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> salary&gt;<span class="number">2500</span> </span><br><span class="line">) <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure><p>视图不可更新部分：只要视图当中的数据不是来自于基表，就不能够直接修改</p><ul><li>聚合函数</li><li>DISTINCT 关键字</li><li>GROUP BY子句</li><li>HAVING 子句</li><li>UNION 运算符</li><li>FROM 子句中包含多个表</li><li>SELECT 语句中引用了不可更新视图</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005932016.htm" target="_blank" rel="noopener">Java零基础到高级MySQL数据库</a><br><a href="https://www.cnblogs.com/jieerma666/p/10805578.html" target="_blank" rel="noopener">数据库事务、事务隔离级别以及锁机制详解</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/01/23/mysql-note-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL数据库基础2</title>
      <link>https://aaronlinv.github.io/2020/01/16/mysql-note-3/</link>
      <guid>https://aaronlinv.github.io/2020/01/16/mysql-note-3/</guid>
      <pubDate>Thu, 16 Jan 2020 13:28:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;DQL（查询表数据）&quot;&gt;&lt;a href=&quot;#DQL（查询表数据）&quot; class=&quot;headerlink&quot; title=&quot;DQL（查询表数据）&quot;&gt;&lt;/a&gt;DQL（查询表数据）&lt;/h2&gt;&lt;h4 id=&quot;条件查询和运算符&quot;&gt;&lt;a href=&quot;#条件查询和运算符&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="DQL（查询表数据）"><a href="#DQL（查询表数据）" class="headerlink" title="DQL（查询表数据）"></a>DQL（查询表数据）</h2><h4 id="条件查询和运算符"><a href="#条件查询和运算符" class="headerlink" title="条件查询和运算符"></a>条件查询和运算符</h4><p>= != &lt;&gt;(不等于) &lt; &lt;= &gt; &gt;=<br>BETWEEN…AND…<br>IN<br>IS NULL, IS NOT NULL<br>AND OR NOT </p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>通配符：</p><ol><li>_：任意一个字符</li><li>%：任意0-n个字符<br>写在WHERE关键词后</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询姓名中包含“s”字母的学生记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%s%'</span>;</span><br></pre></td></tr></table></figure><h4 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h4><ol><li>DISTINCT 去重</li><li>查询结果进行运算，必须都是数据型（值可能为NULL的需要转换为0，任何值与NULL相加还是NULL）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,age+<span class="keyword">IFNULL</span>(score,<span class="number">0</span>) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><ol start="3"><li>对查询结果起别名 AS 可省略AS</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, yw+<span class="keyword">IFNULL</span>(sx,<span class="number">0</span>) <span class="keyword">AS</span> total <span class="keyword">FROM</span> score;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>ORDER BY<br>默认ASC 升序，DESC降序</p><h4 id="聚合行数"><a href="#聚合行数" class="headerlink" title="聚合行数"></a>聚合行数</h4><p>COUNT()<br>MAX()<br>MIN()<br>SUM()<br>AVG()</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>将查询结果按照1个或多个字段进行分组，字段值相同的为一组<br>当group by单独使用时，只显示出每组的第一条记录<br>在使用分组时，select后面直接跟的字段一般都出现在group by 后</p><ul><li>group_concat(字段名)：显示分组后每一组的某字段的值的集合</li><li>聚合函数：显示分组后每一组的聚合函数值</li><li>having：筛选分组之后的结果</li></ul><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT * FROM 表名 LIMIT 从哪一行开始查询,需要查询的行数;</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p>书写顺序<br><img src="/2020/01/16/mysql-note-3/1.png" alt></p><p>执行顺序<br><img src="/2020/01/16/mysql-note-3/2.png" alt></p><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>保证用户输入的数据保存到数据库中是正确的</p><ol><li>实体完整性：一行（一条记录）数据代表一个实体 （标识每一行数据不重复，行级约束）<ul><li>主键</li><li>唯一</li><li>自动增长列</li></ul></li><li>域完整性：限制此单元格的数据正确<ul><li>数据类型</li><li>非空约束 (NOT NULL)</li><li>默认值约束 (DEFAULT)</li></ul></li><li>参照完整性：指表与表之间的一种对应关系<br>通常情况下可以通过设置两表之间的主键、外键关系，或者编写两表的触发器来实现<br>对两张表的要求：<ul><li>数据库的主键和外键类型一定要一致</li><li>两个表必须得要是InnoDB类型</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 实体完整性</span></span><br><span class="line"><span class="comment">-- 三个完整性约束都可以在建表时，在数据类型后指定</span></span><br><span class="line"><span class="comment">-- CREATE TABLE 表名(字段名 数据类型 PRIMARY KEY | UNIQUE | AUTO_INCREMENT);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名<span class="number">1</span> 数据类型 PRIMARY <span class="keyword">KEY</span>,字段<span class="number">2</span> 数据类型);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名<span class="number">1</span> 数据类型, 字段<span class="number">2</span> 数据类型 <span class="keyword">UNIQUE</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名<span class="number">1</span> 数据类型 PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT ，字段<span class="number">2</span> 数据类型 <span class="keyword">UNIQUE</span>);</span><br><span class="line"><span class="comment">-- PRIMARY KEY 和 UNIQUE 可以在参数最后指定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段<span class="number">1</span> 数据类型, 字段<span class="number">2</span> 数据类型,PRIMARY <span class="keyword">KEY</span> | <span class="keyword">UNIQUE</span> (要设置的字段));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 联合主键：两个字段数据同时相同时，才违反联合主键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段<span class="number">1</span> 数据类型, 字段<span class="number">2</span> 数据类型,PRIMARY <span class="keyword">KEY</span>(主键<span class="number">1</span>，主键<span class="number">2</span>));</span><br><span class="line"><span class="comment">-- 建表后设置主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student  <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span>  PRIMARY <span class="keyword">KEY</span> (要设置的字段);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 域完整性</span></span><br><span class="line"><span class="comment">-- 非空约束 NOT NULL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名<span class="number">1</span> 数据类型 PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT ，字段<span class="number">2</span> 数据类型 <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">-- 默认值约束DEFAULT</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(字段名<span class="number">1</span> 数据类型 PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT ，字段<span class="number">2</span> 数据类型 <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'男'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 参照完整性</span></span><br><span class="line"><span class="comment">-- 创建student表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(<span class="keyword">sid</span> <span class="built_in">int</span> PRIMARY <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,sex <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">'男'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建score表，设置外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> score(</span><br><span class="line"><span class="keyword">sid</span> <span class="built_in">INT</span>,</span><br><span class="line">score <span class="keyword">DOUBLE</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_stu_score_sid <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(<span class="keyword">sid</span>) <span class="keyword">REFERENCES</span> student(<span class="keyword">sid</span>));</span><br><span class="line"><span class="comment">-- CONSTRAINT：约束，fk_stu_score_sid是约束名，FOREIGN KEY代表外键，REFERENCES：参考</span></span><br></pre></td></tr></table></figure><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>主键约束</p><ul><li>每个表中要有一个主键（或者联合主键）</li><li>每个数据唯一，非空</li></ul><p>唯一约束</p><ul><li>指定列的数据不能重复</li><li>可以为空值</li></ul><p>自动增长列</p><ul><li>指定列的数据自动增长</li><li>即使数据删除，还是从删除的序号继续往下</li><li>设置自动增长的列必须时主键</li></ul><h4 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h4><p>三种：数据类型、非空约束、默认值约束</p><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>设置参照完整性后 ，外键当中的内值，必须得是主键当中的内容</p><h2 id="表之间的关系"><a href="#表之间的关系" class="headerlink" title="表之间的关系"></a>表之间的关系</h2><p>一对一<br>一对多<br>多对多</p><ul><li>学生选课:一个学生可以选修多门课程，每门课程可供多个学生选择</li><li>需要创建中间的关系表</li><li>拆分表：避免大量冗余数据的出现<br><img src="/2020/01/16/mysql-note-3/3.png" alt="冗余数据"><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h4>合并结果集就是把两个select语句的查询结果合并到一起        </li><li>UNION：合并时去除重复记录</li><li>UNION ALL：合并时不去除重复记录</li><li>注意事项:被合并的两个结果列数、列类型必须相同</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span>   <span class="keyword">UNION</span> | <span class="keyword">UNION</span> <span class="keyword">ALL</span>   <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">2</span>；</span><br></pre></td></tr></table></figure><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>也可以叫跨表查询，需要关联多个表进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同时查询两个表，出现的就是笛卡尔集结果</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student,score;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在查询时要把主键和外键保持一致,逐行判断，相等的留下，不相等的全不要</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student st,score sc <span class="keyword">WHERE</span> st.id = sc.sid;</span><br></pre></td></tr></table></figure><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>内连接</p><ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul><p>外连接</p><ul><li>左外连接（左连接）</li><li>右外连接（右连接）<br>两种连接方式同理，只是顺序不同</li></ul><p>自然连接</p><ul><li>根据主外键等式，自动去除无用的笛卡尔集</li><li>两张连接的表中列名称和类型完全一致</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 等值连接 (INNER可省略) 与多表联查约束主外键是一样，只是写法改变了</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student st <span class="keyword">INNER</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.id = sc.sid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表连接</span></span><br><span class="line"><span class="comment">-- 99连接法（在WHERE中用AND并列条件）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu st,score sc,course c <span class="keyword">where</span> st.id=sc.sid <span class="keyword">and</span> sc.cid =c.cid;</span><br><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu st </span><br><span class="line"><span class="keyword">join</span> score sc <span class="keyword">on</span> st.id = sc.sid</span><br><span class="line"><span class="keyword">join</span> course c <span class="keyword">on</span> c.cid=sc.cid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非等值连接</span></span><br><span class="line"><span class="comment">-- 查询所有员工的姓名，工资，所在部门的名称以及工资的等级</span></span><br><span class="line"><span class="keyword">select</span> e.ename,s.grade <span class="keyword">from</span> emp e</span><br><span class="line"><span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno</span><br><span class="line"><span class="keyword">join</span> salgrade s <span class="keyword">on</span> e.salary <span class="keyword">BETWEEN</span> s.lowSalary <span class="keyword">and</span> s.highSalary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自连接 （给同一个表起不同别名）</span></span><br><span class="line"><span class="comment">-- 求7369员工编号、姓名、经理编号和经理姓名</span></span><br><span class="line"><span class="keyword">select</span> e1.ename,e1.empno,e2.ename <span class="keyword">from</span> </span><br><span class="line">emp e1 <span class="keyword">join</span> emp e2 <span class="keyword">on</span> e1.mgr=e2.empno</span><br><span class="line"><span class="keyword">where</span> e1.empno = <span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="comment">-- 左边表当中的数据全部查出，右边表当中，只查出满足条件的内容（右表中不存在的会用NULL填充）</span></span><br><span class="line"><span class="comment">-- 查询所有学生的成绩信息（所有学生都会被查询到，没有成绩的同学成绩会显示NULL）</span></span><br><span class="line"><span class="comment">-- 可以省略outer</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu st <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> score sc <span class="keyword">on</span> st.id=sc.sid; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自然连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu <span class="keyword">natural</span> <span class="keyword">join</span> score;</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>一个select语句中包含另一个完整的select（子查询语句需要用括号括起来）</p><p>子查询出现的位置</p><ul><li>where后，把select查询出的结果当作另一个select的条件值</li><li>from后，把查询出的结果当作一个新表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- where后：先查出项羽所在的部门编号</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> deptno=</span><br><span class="line">    (<span class="keyword">select</span> deptno <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> ename=<span class="string">'项羽'</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- from后：查询30号部门薪资大于2000</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=<span class="number">30</span>) s</span><br><span class="line"><span class="keyword">where</span> s.salary&gt;<span class="number">2000</span>;</span><br><span class="line"><span class="comment">-- 注意要对表起别名</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005932016.htm" target="_blank" rel="noopener">Java零基础到高级MySQL数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/01/16/mysql-note-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL数据库基础1</title>
      <link>https://aaronlinv.github.io/2020/01/12/mysql-note-2/</link>
      <guid>https://aaronlinv.github.io/2020/01/12/mysql-note-2/</guid>
      <pubDate>Sun, 12 Jan 2020 08:49:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;字符集&quot;&gt;&lt;a href=&quot;#字符集&quot; class=&quot;headerlink&quot; title=&quot;字符集&quot;&gt;&lt;/a&gt;字符集&lt;/h2&gt;&lt;p&gt;计算机只能识别二进制，要处理文字，就需要对字符进行编码，于是就有各种不同编码方式的字符集&lt;br&gt;常见的字符集有：ASCII,GB23
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>计算机只能识别二进制，要处理文字，就需要对字符进行编码，于是就有各种不同编码方式的字符集<br>常见的字符集有：ASCII,GB2312,BIG5,GB18030,Unicode</p><h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>American Standard Code for Information Interchange，美国信息互换标准编码<br>等同于国际标准ISO-646<br>7位编码的字符集只能支持128个字符<br>为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用<strong>8位</strong>（bits）表示一个字符，共256字符</p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施<br>每个汉字及符号以<strong>两个字节</strong>来表示。第一个字节称为“高位字节”（也称“区字节）”，第二个字节称为“低位字节”（也称“位字节”）<br>收录的汉字已经覆盖中国大陆99.75%的使用频率<br>对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB18030汉字字符集的出现</p><h4 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h4><p>又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码<br>Big5码使用了<strong>双字节</strong>储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”</p><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>《汉字内码扩展规范(GBK)》1.0版，由中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订<br>只为“技术规范指导性文件”，<strong>不属于国家标准</strong><br>根据微软资料，GBK是对GB2312-80的扩展</p><h4 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h4><p>全称：GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准<br>采用单字节、双字节和四字节三种方式对字符编码</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>全称：Universal Multiple-Octet Coded Character Set 通用多八位编码字符集<br>它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求</p><p>Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案，UTF是 Unicode Tranformation Format</p><ul><li>UTF-32：用4字节的数字来表达每个字母、符号，或者表意文字，就空间而言，是非常没有效率的</li><li>UTF-16：尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符，因此有了UTF-16编码，每个字符只需要2个字节来存储</li><li>UTF-8：针对Unicode的可变长度字符编码，其编码中的第一个字节仍与ASCII兼容，ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节，辅助平面字符则使用4字节</li></ul><h2 id="SQL语句概述"><a href="#SQL语句概述" class="headerlink" title="SQL语句概述"></a>SQL语句概述</h2><p>Structured Query Language (结构化查询语言)<br>SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言</p><h4 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h4><ul><li>DDL DataDefinationLanguage 数据定义语言：用来定义数据库对象：创建库，表，列等</li><li>DML DataManipulationLanguage 数据操作语言：用来操作数据库表中的记录</li><li>DQL DataQueryLanguage 数据查询语言：用来查询数据</li><li>DCL DataControlLanguage 数据控制语言：用来定义访问权限和安全级别</li></ul><h4 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h4><p>SQMySQL支持所有标准SQL数值数据类型</p><p>常用数据类型</p><ul><li>int：整数</li><li>double：浮点型，例如double(5,2)表示最多5位，其中- 须有2位小数，即最大值为999.99</li><li>char：固定长度字符串类型 char(10)  ‘abc       ‘ （abc后面有7个空格）</li><li>varchar：可变长度字符串类型；varchar(10) ‘abc’</li><li>text：字符串类型</li><li>blob：二进制类型</li><li>date：日期类型，格式为：yyyy-MM-dd</li><li>time：时间类型，格式为：hh:mm:ss （HH是24小时制，hh是12小时制）</li><li>datetime:日期时间类型 yyyy-MM-dd hh:mm:ss</li></ul><h2 id="DDL-对表结构的操作"><a href="#DDL-对表结构的操作" class="headerlink" title="DDL (对表结构的操作)"></a>DDL (对表结构的操作)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库操作</span></span><br><span class="line"><span class="comment">-- 1.创建数据库 create database 数据库名  character set utf8;</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> my_database <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.修改数据库字符集 alter database 数据库名 charactor set gbk;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> my_database <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择数据库 use 数据库名;</span></span><br><span class="line"><span class="keyword">use</span> my_database;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表操作</span></span><br><span class="line"><span class="comment">-- 1.新建表 create table 表名 (列名 数据类型,类名 数据类型...);</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_table (<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),age <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查看表的创建细节 show create table 表名;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> my_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查看表的字段信息 desc 表名;</span></span><br><span class="line">desc my_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.添加一列(字段) alter table 表名 add 列名 数据类型;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> my_table <span class="keyword">add</span> <span class="keyword">id</span> <span class="built_in">bigint</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.修改一个表的字段类型 alter table 表名 modify 字段名 数据类型;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> my_table <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.修改表的列名 alter table 表名 change 原始列名 新列名 数据类型;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> my_table <span class="keyword">change</span> age <span class="keyword">id</span> <span class="built_in">bigint</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.删除一列 alter table 表名 drop 字段名;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> my_table <span class="keyword">drop</span> <span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8.修改表名 rename table 原始表名 to 要修改的表名;</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> my_table <span class="keyword">to</span> my_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9.删除表 drop table 表名;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> my_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10.删除数据库 drop database 数据库名;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> my_database;</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>字符集UTF-8要写作utf8</li><li>modify只能修改数据类型，change可以修改字段名和数据类型，修改的数据类型都在最后指定</li><li>修改表名比较特殊：rename table 原始表名 to 要修改的表名;</li></ul><h2 id="DML（对表的数据增、删、改）"><a href="#DML（对表的数据增、删、改）" class="headerlink" title="DML（对表的数据增、删、改）"></a>DML（对表的数据增、删、改）</h2><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表：create table my_table (name varchar(20),age int);</span></span><br><span class="line"><span class="comment">-- insert into 表名（列名1，列名2 ...）value (列值1，列值2...);</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> my_table (<span class="keyword">name</span>,age) <span class="keyword">value</span> (<span class="string">'zs'</span>,<span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多条</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> my_table (<span class="keyword">name</span>,age) <span class="keyword">values</span> </span><br><span class="line">    (<span class="string">'ls'</span>,<span class="number">30</span>)，</span><br><span class="line">    (<span class="string">'ww'</span>,<span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询是否插入成功 select * from 表名;</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> my_table;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>列名与列值的类型、个数、顺序要一一对应</li><li>值不要超出列定义的长度</li><li>插入的日期和字符一样，都使用引号括起来</li><li>插入多条，多条数据之间用逗号隔开</li><li>插入一条或者多条时，用value或者values好像都可以</li></ul><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- updata 表名 set 列名1=列值1,列名2=列值2...  where 列名=值</span></span><br><span class="line"><span class="comment">-- 修改表中所有列的age为10</span></span><br><span class="line"><span class="keyword">update</span> my_table <span class="keyword">set</span> age=<span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改name为'zs'的列的age为20</span></span><br><span class="line"><span class="keyword">update</span> my_table <span class="keyword">set</span> age=<span class="number">20</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zs'</span>;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- delete from 表名 where 列名=值;</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> my_table <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- truncate table 表名;</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> my_table;</span><br></pre></td></tr></table></figure><p>delete与truncate的区别</p><ul><li>delete 删除表中的数据，表结构还在;删除后的数据可以找回</li><li>truncate 删除是把表直接drop掉，然后再创建一个同样的新表，删除的数据不能找回，执行速度比delete快</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005932016.htm" target="_blank" rel="noopener">Java零基础到高级MySQL数据库</a><br><a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">百度百科-字符集</a><br><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="noopener">字符集和字符编码（Charset &amp; Encoding） - 吴秦</a><br><a href="https://www.cnblogs.com/chenpingzhao/p/4761747.html" target="_blank" rel="noopener">关于字符集和字符编码那些事</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/01/12/mysql-note-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL数据库概述</title>
      <link>https://aaronlinv.github.io/2020/01/12/mysql-note-1/</link>
      <guid>https://aaronlinv.github.io/2020/01/12/mysql-note-1/</guid>
      <pubDate>Sun, 12 Jan 2020 06:24:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;数据库概述&quot;&gt;&lt;a href=&quot;#数据库概述&quot; class=&quot;headerlink&quot; title=&quot;数据库概述&quot;&gt;&lt;/a&gt;数据库概述&lt;/h2&gt;&lt;p&gt;这学期专业课数据库学的虽然是SQL Server，但是很多数据库的概念都相通的，所以引用了很多SQL Sever的笔
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><p>这学期专业课数据库学的虽然是SQL Server，但是很多数据库的概念都相通的，所以引用了很多SQL Sever的笔记</p><h4 id="数据库系统-Database-System-DBS"><a href="#数据库系统-Database-System-DBS" class="headerlink" title="数据库系统 Database System DBS"></a>数据库系统 Database System DBS</h4><ul><li>数据库 Database, DB</li><li>数据库管理系统</li><li>应用程序</li><li>数据库管理员 Database Administrator, DAB</li></ul><p><img src="/2020/01/12/mysql-note-1/2.png" alt="SQL Server"></p><p>数据库管理系统 Database Management System —— DBMS<br>DBMS属于系统软件<br><img src="/2020/01/12/mysql-note-1/1.png" alt="SQL Server"><br>数据库是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS<br>它对数据库进行统一的管理和控制，以保证数据库的<strong>安全性</strong>和<strong>完整性</strong><br>用户通过DBMS访问数据库中的数据，数据库管理员也通过DBMS进行数据库的维护工作<br>数据库管理系统是数据库系统的<strong>核心</strong>，是管理数据库的软件<br>我们一般说的数据库,就是指的DBMS</p><h4 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h4><ul><li>关系型数据库：Oracle,DB2,MySQL,SQL Server</li><li>非关系型数据库NoSQL：MongoDB,Redis,HBase</li></ul><p>非关系型数据库NoSQL：(NoSQL = Not Only SQL),意即“不仅仅是SQL”</p><h4 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库 RDBMS"></a>关系型数据库 RDBMS</h4><ul><li>表：类似Excel表格，具有固定的列数,和任意的行数</li><li>数据库：数据库是一些关联表的集合</li><li>列：一个数据项 Field 字段</li><li>行：一条记录  row</li><li>主键：唯一，不为空，可以使用主键来查询数据</li><li>外键：外键用于关联两个表</li><li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录</li></ul><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>MySQL是开源的，由瑞典MySQL AB公司开发，现在属于Oracle旗下产品。<br>MySQL可以允许于多个系统上，并且支持多种语言，包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等</p><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p><img src="/2020/01/12/mysql-note-1/3.png" alt="SQL Server"><br>选择Custom然后自己选择要安装的组件</p><p><img src="/2020/01/12/mysql-note-1/4.png" alt="SQL Server"><br>仅选择MySQL Server即可</p><p><img src="/2020/01/12/mysql-note-1/5.png" alt="SQL Server"></p><p><img src="/2020/01/12/mysql-note-1/6.png" alt="SQL Server"><br>记住端口号，这个很重要</p><p><img src="/2020/01/12/mysql-note-1/7.png" alt="SQL Server"><br>Authentication Method 就选择推荐的吧</p><p><img src="/2020/01/12/mysql-note-1/8.png" alt="SQL Server"><br>账号密码很重要</p><p>接下来一路Next即可</p><h5 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h5><p>打开命令提示符(cmd)<br>cd 到MySQL的目录下的bin目录：C:\Program Files\MySQL\MySQL Server 8.0\bin （不同版本路径可能不同）<br>可以把MySQL的bin配置到环境变量里，这样就不用手动cd到bin目录<br><img src="/2020/01/12/mysql-note-1/9.png" alt="SQL Server"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL -u root -p</span><br><span class="line"><span class="comment"># -u 表示用户 -p 表示密码</span></span><br></pre></td></tr></table></figure><p>输入密码，光标前变成 MySQL&gt; 就登录成功了</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>MySQL有两种数据库：<br>系统数据库(数据库服务器自带的,自带的4个)</p><ul><li>information_schema：存储数据库对象信息，如用户表信息,列信息,根除,字符,分区</li><li>performance_schema：存储数据库服务器性能参数信息</li><li>MySQL：存储数据库用户权限信息</li><li>sys：通过这个库可以快速的了解系统的元数据信息，这个库是通过视图的形式把information_schema和performance_schema结合起来，查询出更加令人容易理解的数据</li></ul><p>用户数据库（用户自己创建的数据库,一个项目用一个数据库）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.连接数据库</span></span><br><span class="line">MySQL -u root -p</span><br><span class="line"><span class="comment">-- 输入密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始写sql语句，有三点要注意</span></span><br><span class="line"><span class="comment">--    1.每一条sql语句后面都要以分号结尾;</span></span><br><span class="line"><span class="comment">--    2.sql语句的注释是两个减号：--</span></span><br><span class="line"><span class="comment">--    3.sql语句的关键字不区分大小写，非关键字像数据库名、表名这些最好都区分一下大小写，避免出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.显示所有数据库show databases; (注意最后是有s)</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">-- 3.创建数据一个数据库(并设置字符集为UTF-8) create database 数据库名  character set utf8;</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> my_demo <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="comment">-- 4.选择数据库 use 数据库名;</span></span><br><span class="line"><span class="keyword">use</span> my_demo;</span><br><span class="line"><span class="comment">-- 5.查看这个数据库里所有表 show tables; (注意最后是有s)</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 6.新建表 create table 表名 (列名 数据类型,类名 数据类型...);</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_table (<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),age <span class="built_in">int</span>);</span><br><span class="line"><span class="comment">-- 7.查看表的字段信息 desc 表名;</span></span><br><span class="line">desc my_table;</span><br><span class="line"><span class="comment">-- 8.删除表 drop table 表名;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> my_table;</span><br><span class="line"><span class="comment">-- 9.删除数据库 drop database 数据库名；</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> my_demo;</span><br></pre></td></tr></table></figure><h4 id="使用Navicat连接MySQL"><a href="#使用Navicat连接MySQL" class="headerlink" title="使用Navicat连接MySQL"></a>使用Navicat连接MySQL</h4><p><img src="/2020/01/12/mysql-note-1/10.png" alt="Navicat"><br><img src="/2020/01/12/mysql-note-1/11.png" alt="Navicat"></p><p>我自己在使用Navicat连接数据库的时候MySQL报错2059<br>搜索后得知是因为MySQL8之后修改了加密规则，参考这篇文章解决了问题：<a href="https://blog.csdn.net/CheneyKKE/article/details/80272777" target="_blank" rel="noopener">Navicat连接数据库MySQL报错2059</a></p><p>这里就有一个小感想：学习一个新技术的时候，最好使用和教程相同版本的软件，这样可以避免很多问题。因为刚接触一个事务的时候，对这个事物的认知往往还不能够支持你解决这些问题。当然爱折腾除外，遇到这些问题解决它其实也是一种学习的方式</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005932016.htm" target="_blank" rel="noopener">Java零基础到高级MySQL数据库</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2020/01/12/mysql-note-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-面向对象4</title>
      <link>https://aaronlinv.github.io/2019/12/30/java-note-5/</link>
      <guid>https://aaronlinv.github.io/2019/12/30/java-note-5/</guid>
      <pubDate>Mon, 30 Dec 2019 07:16:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h4&gt;&lt;p&gt;求不同图形的面积&lt;br&gt;定义一个Graph类，getArea方法求图形面积，不同的图形求面积算法是不一样，不同图形写不同子类，继承Graph
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>求不同图形的面积<br>定义一个Graph类，getArea方法求图形面积，不同的图形求面积算法是不一样，不同图形写不同子类，继承Graph类</p><ol><li>每一个图形子类，都必须得要覆盖getArea方法，在每个里面写上自己的方法体</li><li>父类不知道方法体里面该怎么写，不需要方法体</li></ol><p>抽象方法（在方法前面添加了一个关键字abstract）：</p><ol><li>没有方法体（但是有返回值）</li><li>必须要定义在抽象类当中或接口（在类前面添加上了一个abstract就成为了抽象类）</li><li>不能是私有的<strong>private</strong>（子类就不能访问该方法就不能重写），不能使用<strong>final</strong>修饰（final要求子类不能重写，但是abstract要求必须要重写），不能同时使用<strong>static</strong>（static属于类，方法属于对象）</li></ol><p>抽象类<br>抽象类必须得要有子类才行（抽象类一般都当作父类来继承）</p><p>抽象类的注意点：</p><ol><li>抽象类是不能直接创建对象的（但<strong>抽象类是有构造器的</strong>）</li><li>抽象类当中，可以有抽象方法，也<strong>可以有非抽象方法</strong>（普通方法：给子类调用的）</li><li>子类没有去覆盖抽象方法，把子类也变成抽象类（子类没有实现抽象方法，有孙类孙类就要实现，总有人要还的）</li><li>构造方法不能定义为私有化（抽象方法必须得要让子类继承之后，才能实现内部的方法体）（子类继承的话，先去调用父类的构造方法）</li><li>抽象类不能使用final来去修饰</li></ol><p>抽象类和普通类的区别<br>其实是一个不完整类。需要做为一个父类，子类才能完成对应的功能。<br>命名：抽象类命令时，都喜欢在前面添加上一个Abstract</p><p>抽象类与普通的类有什么区别？</p><ol><li>普通类（方法，字段，构造器），抽象类都有</li><li>抽象不能创建对象</li><li>抽象类可以包含抽象方法，也可以包含非抽象方法</li><li>抽象类必须有子类才有意义</li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口只定义了类应当遵循的规范，却不关心这些类的内部数据和其功能的实现细节<br>站在程序角度上说接口只<strong>规定了类里必须提供的方法，从而分离了规范和实现</strong>，增强了系统的可拓展性和可维护性</p><p>Java接口也是表示一种规范，使用<strong>抽象方法</strong>来去定义一组功能，必须要实现者给提供方法的实现</p><p>接口命名：I+名字+able</p><p>接口它其实是一个特殊的抽象类(abstract 可以不写)，接口也会生成对应的字节码</p><p>内部方法的abstract可以省略不写，如果没有在方法前面添加abstract会在编译时自动的添加上public abstract</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//编译自动加上等同于：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>接口当中的注意点</p><ol><li>接口是<strong>没有构造器</strong>，接口是不能创建对象</li><li>接口当中定义变量，都是<strong>全局的静态常量</strong>,少用<br>String name=”myxq”;<br>编译后：public static final String name；   //final 修饰的变量必须初始化</li><li>接口当中定义的方法都是<strong>公共的抽象方法</strong><br>void transData（）;<br>编译后：<strong>public abstract</strong> void transData（）;</li><li>接口可以多继承 (类不能多继承，接口继承的时候，不会去覆盖父接口的方法，因为没有方法体，所以无意义）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iwalkable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>; <span class="comment">// 接口方法默认public abstract ，可以不写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iswimable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iamphibiousable</span> <span class="keyword">extends</span> <span class="title">Iwalkable</span>, <span class="title">Iswimable</span> </span>&#123;</span><br><span class="line"><span class="comment">//void swim(); 接口继承的时候，一般都不进行方法覆盖，无意义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口中 可以定义内部类，内部类也是public abstract</li></ol><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>实现类 extends 父类（只能继承一个类）implements其它的接口（接口可以实现多个）<br>例如：class Cat extends Animal implements Iwalkable{}</p><p>在实现类当中必须得要去覆盖接口当中定义的方法<br>实现的方法必须得是public（子类权限不能比父类小）</p><p>多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(Iamphibiousable接口可以说是forg的父类)</span></span><br><span class="line">    <span class="comment">//多态写法，把子类对象赋值给父类类型</span></span><br><span class="line">    Iamphibiousable frog = <span class="keyword">new</span> Frog();<span class="comment">//面向接口编程</span></span><br><span class="line">    frog.swim();<span class="comment">//多态运行时表现子类特征（编译看左边，运行看右边）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时看左边的Iamphibiousable又没有swin方法（这里是继承自Iswimable），没有就报错，有的话运行右边的Frog类的的swim方法</p><h4 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h4><p>相同点</p><ol><li>都是被其它类实现或者被继承</li><li>都不能实例化</li><li>都可以定义抽象方法，定义的抽象方法子类都必须得要覆盖</li></ol><p>不同点</p><ol><li>抽象类当中是有构造器，接口是没有构造器</li><li>抽象类可以包含普通方法和抽象方法，接口当中只能有抽象方法，不能有普通方法（带有方法体）(Java8开始，接口可以有普通方法)</li><li>成员变量：抽象类当中默认的权限，接口当中默认：public static final变量 -&gt; 全局静态常量    </li><li>方法：抽象类默认的权限，接口当中默认方法public abstract 方法名；</li></ol><h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>把实现类对象赋值给接口类型的变量<br>好处：蔽了不同类之间实现差异，从而达到通用编程（就是多态的好处）</p><ol><li>定义接口</li><li>定义接口实现类</li><li>创建具体对象<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4>定义在<strong>类当中的一个类</strong></li></ol><p>为什么要使用内部类<br>1.增强封装，把内部类隐藏在外部类当中，不允许其它类访问这个内部类<br>2.增加了代码一个维护性<br>3.内部类可以直接访问外部类当中的成员</p><p>内部类的分类（4种）<br>1.实例内部类：直接定义在类当中的一个类，在类前面没有任何一个修饰符<br>2.静态内部类：在内部类前面加上一个static<br>3.局部内部类：定义在方法的内部类<br>4.匿名内部类：属于局部内部的一种特殊情况</p><p>外部类的修饰符只能有两个：public或者默认修饰符，内部类可以使用很多个修饰符</p><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>类当中的成员：<br>字段<br>方法<br>内部类</p><p>实例内部类：属于对象的内部类，不属于类的，不使用static修饰<br>想要使用内部类，必须得要先创建外部类在内部类<br>当中可以访问外部类中的成员，外部类是不能直接访问内部中的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"Outer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"Inner"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"Inner test()"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(name);</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.name); <span class="comment">//调用外部类的变量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer outer=<span class="keyword">new</span> Outer(); <span class="comment">//先new 外部类</span></span><br><span class="line">Outer.Inner inner=outer.new Inner();<span class="comment">//赋值给 Inner inner 会报错</span></span><br><span class="line">inner.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建内部类对象当中，会有一个<strong>外部类的引用</strong><br><img src="/2019/12/30/java-note-5/1.png" alt="高新强"></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"Outer"</span>;</span><br><span class="line"><span class="keyword">static</span> String sname = <span class="string">"Outer staic"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">// 5.可以定义非静态成员</span></span><br><span class="line"><span class="keyword">static</span> String iname = <span class="string">"Inner static"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(sname);</span><br><span class="line"><span class="comment">// System.out.println(name); 报错，非静态变量,可以创建实例对象来访问</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> Outer().name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.static 静态的，属于类，就不需要创建外部类</span></span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner(); <span class="comment">// 类型Outer.Inner 和实例内部类相同</span></span><br><span class="line">inner.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.调用静态类中的静态变量</span></span><br><span class="line">System.out.println(Outer.Inner.iname);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类：在内部类前面加上static</p><ol><li>静态内部类是<strong>不需要创建外部对象</strong>（因为是static，所以是属于类）<br>outter.Inner in=new outter.Inner（）；</li><li>在静态内部类中，<strong>没有外部类引用</strong></li><li>静态内部类，可以访问外部类的静态成员</li><li>访问静态内部类当中的静态成员Outter.Inner.iname</li><li>静态内部当中可以定义静态成员，也可以定义非静态成员</li></ol><h4 id="局部内部类（少用）"><a href="#局部内部类（少用）" class="headerlink" title="局部内部类（少用）"></a>局部内部类（少用）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myxq</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"Outer test()"</span>;<span class="comment">// 4.本质final 编译自动加</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;<span class="comment">// 局部内部类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部内部类的方法test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//name="test"; 因为是final 所以不能修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">in.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Outer().myxq();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在方法中的内部类<br>1.不能用一些修饰符public private（因为只在方法的局部生效）<br>2.只能在定义的方法中使用<br>3.不能包含静态变量（staic是属于类，但是这个变量属于方法）<br>4.可以包含局部变量，本质是final，编译自动加上（JDK1.8之后可以省略final）（这里的局部变量指的是与局部内部类同级的变量，就是在myxq方法里的局部变量，至于局部内部类里面非final也可以）</p><p>内存分析<br>myxq方法栈帧 入栈 有一个变量name<br>堆中创建Inner对象，地址0x0001赋值栈的in<br>Inner对象的test方法引用了name，指向栈里的<br><img src="/2019/12/30/java-note-5/2.png" alt="高新强"></p><p>myxq方法出栈后<br>堆中一个对象没有人引用，它并不是直接就销毁<br>所以name现在空指针<br>所以引用的必须是final 常量（在方法区）<br><img src="/2019/12/30/java-note-5/3.png" alt="高新强"></p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUSB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapData</span><span class="params">()</span></span>;<span class="comment">// public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotherBoard</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PluginIn</span><span class="params">(IUSB iusb)</span> </span>&#123;</span><br><span class="line">iusb.swapData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MotherBoard board = <span class="keyword">new</span> MotherBoard();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类</span></span><br><span class="line">board.PluginIn(<span class="keyword">new</span> IUSB() &#123; <span class="comment">// 这里new的不是接口而是匿名内部类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个没有名字的局部内部类  安卓用的比较多<br>匿名内部类是没有构造器<br>只使用一次的时候,来去使用匿名内部类  </p><p>new 父类的构造器 或 接口( ){<br>内部写的代码（在new时候就会自动执行）<br>}      </p><p>匿名内部类必须得要有父类才,或者是实现了接口</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/30/java-note-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-面向对象3</title>
      <link>https://aaronlinv.github.io/2019/12/29/java-note-4/</link>
      <guid>https://aaronlinv.github.io/2019/12/29/java-note-4/</guid>
      <pubDate>Sun, 29 Dec 2019 00:36:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;代码块&quot;&gt;&lt;a href=&quot;#代码块&quot; class=&quot;headerlink&quot; title=&quot;代码块&quot;&gt;&lt;/a&gt;代码块&lt;/h4&gt;&lt;p&gt;在类中或方法中使用 { } 括起来的一段代码就称它是一个代码块&lt;br&gt;代码块当中定义的变量，我们称它是局部变量&lt;/p&gt;
&lt;ol&gt;
&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>在类中或方法中使用 { } 括起来的一段代码就称它是一个代码块<br>代码块当中定义的变量，我们称它是局部变量</p><ol><li>局部代码块：直接定义在方法内部的代码块  在调用方法的时候执行。（很少用，if while for（）{} 这个{} 就是局部代码块）</li><li>初始化代码块：直接在类当中定义代码块<br>初始化代码块在运行时，还是要把它放到<strong>构造方法</strong>当中（编译时候直接初始代码块的写到构造方法第一行,带参无参都会）</li><li>静态代码块：在初始化代码块前面加上一个static<br>在加载字节码时就会自动调用在主方法之前执行的。<strong>只执行一次</strong>（先执行静态代码块，然后再执行main）</li></ol><h4 id="组合关系和类的加载"><a href="#组合关系和类的加载" class="headerlink" title="组合关系和类的加载"></a>组合关系和类的加载</h4><p>组合关系：自己当中的字段是一个“类”类型依赖其它的类（类的成员变量是另一个类）<br>类加载：<br>类在什么时候去加载：当第一次使用该类对象的时候，去加载到JVM当中<br><strong>只加载一次，下一次直接从内存中使用了</strong></p><h4 id="字段初始化"><a href="#字段初始化" class="headerlink" title="字段初始化"></a>字段初始化</h4><ol><li>类的加载：第一次创建该类对象的时候，加载到内存中，加载时会执行static代码块</li><li>字段初始化</li></ol><ul><li>静态字段：在静态代码块中初始化</li><li>非静态字段：在构造器中初始化</li></ul><ol start="3"><li>子类构造器默认会调用父类构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass static代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SubClass static代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">SubClass() &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.println(<span class="string">"SubClass 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//private static MyXq xq=new MyXq(); //静态字段实在静态代码块中初始化</span></span><br><span class="line"><span class="comment">//编译实际上是：</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MyXq xq=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">xq=<span class="keyword">new</span> MyXq();</span><br><span class="line">System.out.println(<span class="string">"MyXq 类的static静态初始化 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//private SubClass sub=new SubClass();</span></span><br><span class="line"><span class="comment">//编译实际上是:</span></span><br><span class="line"><span class="keyword">private</span> SubClass sub=<span class="keyword">null</span>;</span><br><span class="line">MyXq()&#123;</span><br><span class="line">sub=<span class="keyword">new</span> SubClass(); <span class="comment">//在构造器中初始化</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"MyXq构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"main"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">SuperClass static代码块</span></span><br><span class="line"><span class="comment">SubClass static代码块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SuperClass 构造器</span></span><br><span class="line"><span class="comment">SubClass 构造器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyXq构造器</span></span><br><span class="line"><span class="comment">MyXq 类的static静态初始化</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>程序运行：执行main，在main之前需要对类初始化</li><li>对MyXq类进行初始化，会执行静态代码块：调用MyXq构造器</li><li>MyXq构造器：new了一个SubClass，new之前先把SubClass这个类加载到内存，加载子类前会先判断有没有父类，如果有，会先把父类加载成字节码放到内存当中，然后再去把自己加载到内存，所以是先加载SuperClass，执行SuperClass的静态代码块，然后是SubClass的静态代码块</li><li>子类构造器第一句为super(),所以先执行SuperClass构造器，再执行SubClass构造器</li></ol><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>继承弊端：破坏了我们的封装，继承可去访问父类当中的实现细节，可以覆盖父类当中的方法</p><p>字段：不能再去修改该字段<br>方法：子类就能再去覆盖该方法<br>类：该类就不能再去被继承</p><p>final关键字：只能用，不能修改</p><p>注意点：</p><ul><li>final 修饰字段：必须得要自己手动设置初始值</li><li>final 修饰变量：就代表是一个常量，命令规则：所有的字母都大写MAX_VALUE</li><li>final 可以在局部代码块当中使用</li><li>final 修饰基本数据类型：值不能修改</li><li>final 修饰引用类型：可以修改类里面的成员，但是不能修改地址</li></ul><h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>设计模式：之前很多程序员经常无数次的尝试，总结出来一套最佳实践<br>单例：一个类在内存当中只有一个对象。别人不能再去创建对象<br>工具类一般都是单例设计模式<br>工具类：把一些经常使用的功能，写在一个类当中，以后使用该功能时，直接调用</p><p>饿汉模式（<strong>这类的单例不能被继承</strong>，因为子类默认有构造器，构造器默认有super()默认访问父类构造器，所以报错，其他形式单例可被继承）<br>1.必须得要在该类中创建一个对象出来<br>2.私有化自己的构造器。防止外界通过构造器来创建新的对象<br>3.给外界提供一个方法，能够获取已经创建好的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolUtil</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ToolUtil instance=<span class="keyword">new</span> ToolUtil();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ToolUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ToolUtil <span class="title">getInstantce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点<br>1.控制资源的使用<br>2.控制实例的产生数量，达到节省资源目的<br>3.作为通信媒介，数据共享</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>对基本数据类型进行包装，把基本数据类型包装一个对象。<br>把基本数据类型变的更强大，以面向对象的思想来去使用这些类型。<br>基本数据类型    包装类       （都是首字母大写，只有int和char是英文全称）</p><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center"><strong>Integer</strong></td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center"><strong>Character</strong></td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">20</span>;</span><br><span class="line">    Integer num=<span class="keyword">new</span> Integer(i);</span><br><span class="line">    </span><br><span class="line">    System.out.println(num);</span><br><span class="line">    System.out.println(num.MAX_VALUE);<span class="comment">//本质用类名调用 同下一行</span></span><br><span class="line">    System.out.println(Integer.MAX_VALUE);</span><br><span class="line">    System.out.println(Integer.MIN_VALUE);</span><br><span class="line">    System.out.println(num.TYPE);</span><br><span class="line">    </span><br><span class="line">    num=Integer.valueOf(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装箱:基本数据类型 -&gt; 包装类<br>拆箱:包装类-&gt;基本数据类型</p><p>自动装箱 自动拆箱（语法糖）</p><ul><li>自动装箱<br>Integer i1=10;<br>//本质 Integer i1=Integer.valueOf(10);</li><li>自动拆箱<br>int i2=i;<br>//本质int i2=i.intValue() ;</li></ul><h4 id="字符串与其他类型转换"><a href="#字符串与其他类型转换" class="headerlink" title="字符串与其他类型转换"></a>字符串与其他类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串-&gt;包装类型</span></span><br><span class="line">Integer i =<span class="keyword">new</span> Integer(<span class="string">"10"</span>);<span class="comment">//字符串中不能有非数字，比如字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型-&gt;字符串</span></span><br><span class="line">String s=i.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型-&gt;字符串</span></span><br><span class="line">String str2=<span class="number">2</span>+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串-&gt;基本数据类型</span></span><br><span class="line">String str3=<span class="string">"2020"</span>;</span><br><span class="line"><span class="keyword">int</span> i3 =Integer.parseInt(str3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转boolean</span></span><br><span class="line">Boolean b=<span class="keyword">new</span> Boolean(<span class="string">"myxq"</span>); <span class="comment">//除了字符串true其他都返回false</span></span><br></pre></td></tr></table></figure><h4 id="基本数据类型和包装类区别"><a href="#基本数据类型和包装类区别" class="headerlink" title="基本数据类型和包装类区别"></a>基本数据类型和包装类区别</h4><ol><li>默认值<br>int 0<br>Integer null</li><li>包装类当中提供了很多方法直接给我们使用如：<br>Integer.toBinaryString(5)</li><li>集合框架当中不能存放基本数据类型，只能存对象</li></ol><p>什么时候使用基本数据类型什么时候使用包装类</p><ul><li>在类当中，成员变量一般都使用包装类</li><li>在方法中，我们一般都使用基本数据类型</li></ul><p>方法中，基本数据类型存储在栈当中，包装类型存放在堆当中</p><h4 id="包装类valueOf缓存设计"><a href="#包装类valueOf缓存设计" class="headerlink" title="包装类valueOf缓存设计"></a>包装类valueOf缓存设计</h4><p>用valueOf获取包装类对象，在缓存范围内直接使用缓存，超过缓存范围，则创建新的对象，返回新的地址</p><ul><li>Boolean：(全部缓存)</li><li>Byte：(全部缓存)</li><li>Character(&lt;= 127缓存)</li><li>Short(-128 — 127缓存)</li><li>Long(-128 — 127缓存)</li><li>Integer(-128 — 127缓存)</li><li>Float(没有缓存)</li><li>Doulbe(没有缓存)</li></ul><h4 id="对基本数据类型包装的好处"><a href="#对基本数据类型包装的好处" class="headerlink" title="对基本数据类型包装的好处"></a>对基本数据类型包装的好处</h4><p>1.使用包装对象后，功能变的更加强大<br>例如：使用Double表示一个人的分数，一个人的分数为0分，可以表示0.0，如果这个人没有来考试可以用null表示</p><p>2.包装类当中给我们提供了很多方法<br>例如：我们要将一个数据转成二进制，使用包装对象后，就可以直接调用方法</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a><br><a href="https://www.cnblogs.com/javatech/p/3650460.html" target="_blank" rel="noopener">JAVA包装类的缓存范围</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/29/java-note-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-面向对象2</title>
      <link>https://aaronlinv.github.io/2019/12/28/java-note-3/</link>
      <guid>https://aaronlinv.github.io/2019/12/28/java-note-3/</guid>
      <pubDate>Sat, 28 Dec 2019 14:37:05 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;包&quot;&gt;&lt;a href=&quot;#包&quot; class=&quot;headerlink&quot; title=&quot;包&quot;&gt;&lt;/a&gt;包&lt;/h4&gt;&lt;p&gt;规范：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遵循关键字，全部小写&lt;/li&gt;
&lt;li&gt;企业开发包名用公司域名倒写 域名倒写.模块名.组件名&lt;/li&gt;
&lt;/ol&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>规范：</p><ol><li>遵循关键字，全部小写</li><li>企业开发包名用公司域名倒写 域名倒写.模块名.组件名</li></ol><p>类的全限定名称：包名.类名</p><p>静态导入：把其他包里面的内容在本类当中使用、不需要使用类名调用，直接使用包里面的方法</p><p>import static java.util.Arrays.sort;</p><p>不推荐用：1.有些方法不能这么用比如toString，2.不知道是自己写的还是导入的</p><h4 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h4><p>写一个用户注册，有很多信息需要填写，如果写方法，需要传入很多参数，有很多参数是非必要的但是都要写<br>方法重载写起来麻烦<br>封装到一个对象里，那就只要传一个参数即可new一个对象，其他用初始值，当成一个整体</p><p>优点：<br>1.参数少了很多，传的是一个对象，把某些信息当成一个整体去使用<br>2.安全性：变量加private，不允许外部读取或者修改它</p><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p><img src="/2019/12/28/java-note-3/1.png" alt="高新强"></p><p>默认和protected的区别：同包下都可以访问，但是只要继承默认权限就不能访问，protected则可以访问<br>使用不同包的成员需要导入</p><h4 id="属性概念"><a href="#属性概念" class="headerlink" title="属性概念"></a>属性概念</h4><p>字段或者成员变量 加上get和set方法才能叫属性<br>Eclipse自动生成右键 -&gt; Source -&gt; Generate Getters and Setters…</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this:  “这个”指向当前正在使用对象的地址</p><p>注意点：</p><ol><li>帮我们区分成员变量和局部变量的二异性，必须得要使用this</li><li>在同类当中，实例方法的调用，前面其实是有this，可以省略</li><li>可以把this做为参数传递</li><li>可以当做返回值返回</li><li><strong>static不能和this一起使用</strong></li><li>构造器的重载互调，this ( )；此时this代表是构造器名，<strong>必须写到第一行</strong></li></ol><h4 id="继承思想"><a href="#继承思想" class="headerlink" title="继承思想"></a>继承思想</h4><p>老师、学生、员工这些类都有一些相同的变量：比如姓名、年龄，还有相同的方法比如吃<br>代码出现重复，可以通过继承来解决这个问题</p><p>父类：存放共同的状态和行为被继承的类我们称为父类或超类、基类、拓展类。<br>子类：存放自己特有的状态和行为</p><p>继承是一种从一般到特殊的关系，是一种“is a ”的关系，即子类是对父类的派生，是一种特殊的父类<br>比如：狗是动物的一种特殊情况，狗属于动物。</p><p>一般的，在开发工程中先编写多个自定义类，写完之后，发现多个类之间存在共同的代码，此时可以抽去出一个父类</p><p>如果父类中的成员使用protected修饰，子类也继承，不同包也能继承<br>父类的构造器，子类也不能继承，因为构造器必须和当前的类名相同</p><h4 id="继承方法的覆盖"><a href="#继承方法的覆盖" class="headerlink" title="继承方法的覆盖"></a>继承方法的覆盖</h4><p>子类你扩展了父类，就获得了父类当中的方法和成员变量，可是父类当中的某一些方法，不适合子类本身<br>不适合子类的方法，可以覆盖，重新定义这个方法</p><p>运行一个方法会在子类中找，有就调用，没有去父类中查找</p><p>覆盖方法的原则：</p><ol><li>必须得要跟父类当中的方法签名相同（签名：方法的名称+参数）</li><li>返回值类型必须得要和父类一样</li><li>访问权限不能比父类的还小</li></ol><p>判断是否是覆写方法：@Override标签,写在重写方法前一行，如果不是重写的方法编译会报错</p><h4 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h4><p>方法重载 Overload</p><ul><li>作用：解决了同一个类中，相同功能的方法名不同的问题</li><li>规则：同类中，<strong>方法名相同，方法参数列表不同</strong></li></ul><p>方法重写 Override</p><ul><li>作用：解决子类继承父类之后，可能父类的某一个方法不满足子类的具体特征，需要重新在子类中定义该方法，并重写方法体</li><li>规则：<strong>父类和子类的方法签名是相同的</strong></li></ul><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>代表是父类对象，到父类当中去找指定的方法</p><p>内存分析：<br>在类加载字节码时，会先判断有没有父类，如果有，会先把父类加载成字节码放到内存当中，然后再去把自己加载到内存（方法区）</p><p>如果一个类有父类的，会在构造器当中，默认调用父类的构造器（<strong>子类构造器第一句默认super( );</strong> ）</p><p>super( ) 调用父类构造方法 必须放在第一行<br>凡是子类的构造方法当中都会有super( );<br>this()和super() 构造方法不能一起使用，因为两个都要求放第一行<br>父类中定义了带参构造（就不会生成无参构造），子类一定要手动调用父类的带参构造器，不调用就报错</p><p>super不能直接打印</p><h4 id="字段隐藏"><a href="#字段隐藏" class="headerlink" title="字段隐藏"></a>字段隐藏</h4><ol><li>this.字段或方法先到本类当中去找指定的内容，如果没有，再去到父当中去找<br>如果父类有，再去看一下父类允不允许继承，如果允许就使用父类的</li></ol><p>super直接到父类当中去找，使用super可以访问父类被隐藏的字段</p><ol start="2"><li><strong>方法的隐藏</strong>：子类和父类当中有相同的静态方法（<strong>不是静态就是方法覆盖</strong>）<br>因为是静态，所以用对象名调用的本质还是用类名调用</li></ol><ul><li>用子类对象调用，就是执行子类的静态方法</li><li>用父类对象调用，就是执行子类的静态方法</li></ul><ol start="3"><li>本类隐藏：方法参数和本类字段名相同<br>用this.字段<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="string">"al"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//本类隐藏，用this关键字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object类是Java语言的根类，要么是一个类的直接父类，要么就是一个类的间接父类<br>Object提供方法</p><ul><li>hasCode( )</li><li>equals( ) //判断两个对象地址是否相等</li><li>getClass() //获取当前对象的真实类型</li><li>toString( )//打印对象地址值<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(对象名.toString);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">System.out.print(对象名)</span><br></pre></td></tr></table></figure></code></pre>可以用Eclipse自动生成重写这些方法</li></ul><h4 id="多态思想"><a href="#多态思想" class="headerlink" title="多态思想"></a>多态思想</h4><p>一个对象有多种形态 就称它是多态<br>一个表示自己的类，一个表示自己父类的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog dog =<span class="keyword">new</span> Dog( );</span><br><span class="line">Animal dog =<span class="keyword">new</span> Dog( );</span><br></pre></td></tr></table></figure><p>多态特点：把子类对象赋给父类变量，在运行时期会表现出具体的<strong>子类特征</strong></p><p>多态优点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有多种动物，要定义多种feed类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多态做法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog =<span class="keyword">new</span> Dog();</span><br><span class="line">        Cat cat =<span class="keyword">new</span> Cat();</span><br><span class="line">        </span><br><span class="line">        Person p=<span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">//一般做法</span></span><br><span class="line">        p.feedCat(cat);</span><br><span class="line">        p.feedDog(dog);</span><br><span class="line">        <span class="comment">//多态做法</span></span><br><span class="line">        p.feedAnimal(cat);</span><br><span class="line">        p.feedAnimal(dog);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多态作用</p><ul><li>当把不同的子类对象都当作父类类型来看待，可以屏蔽不同子类对象之间的实现差异</li><li>从而写出通用的代码达到通用编程，以适应需求的不断变化</li><li>在这里使用了多态后，只需要写一个方法就能达到相同的功能（子类没有这个方法，会到父类种找）</li></ul><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>类的强制类型转换：把父类对象赋值给子类类型<br>判断一个对象是否是指定的类，如果是返回true不是，就返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">Dog dog = (Dog) animal;<span class="comment">// 把Animal强制成Dog</span></span><br><span class="line">dog.eat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">Cat cat = (Cat) animal;</span><br><span class="line">cat.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    Animal cat =<span class="keyword">new</span> Cat();</span><br><span class="line">    Animal dog =<span class="keyword">new</span> Dog();</span><br><span class="line">    p.feed(cat);</span><br><span class="line">    p.feed(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态中字段的注意点"><a href="#多态中字段的注意点" class="headerlink" title="多态中字段的注意点"></a>多态中字段的注意点</h4><p><strong>方法存在多态，字段不存在多态</strong><br><strong>字段前面对象是什么类型，就调用谁的</strong>，<strong>在编译的时候，就已经确定要去调用谁的</strong></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/28/java-note-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-面向对象1</title>
      <link>https://aaronlinv.github.io/2019/12/25/java-note-2/</link>
      <guid>https://aaronlinv.github.io/2019/12/25/java-note-2/</guid>
      <pubDate>Wed, 25 Dec 2019 13:15:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;面向过程与面向对象&quot;&gt;&lt;a href=&quot;#面向过程与面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向过程与面向对象&quot;&gt;&lt;/a&gt;面向过程与面向对象&lt;/h4&gt;&lt;p&gt;如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h4><p>如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写好，而面向对象就像是去饭店吃饭，告诉服务员吃什么就好了，而不用考虑菜是怎么做的，只要吃就好了</p><ul><li>面向过程<ul><li>面向过程性能比面向对象高，面向对象调用类需要实例化，资源开销大，而面向对象则不需要</li></ul></li><li>面向对象<ul><li>易维护、易复用、易扩展，可以设计出低耦合的系统</li></ul></li></ul><p>面向对象就像是盖浇饭，饭和菜分离可维护性好，耦合程度低，可根据需求更改饭或者菜，而不像蛋炒饭，蛋和饭杂糅在一起，想替换其中某一个都非常困难</p><h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>封装：去饭店吃饭，你并不知道饭菜的具体做法，但是你可以通过服务员来点菜，得到点的饭菜<br>继承：父亲有钱，儿子可以继承父亲的财产<br>多态：亲戚结婚，邀请函上写的是你的父亲的名字，但实际上可以是你或你的妹妹去参加</p><ul><li>封装：封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能</li><li>继承：当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员</li><li>多态：多态是可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征</li></ul><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>对象：可以是一个人，具有特性如：身高、体重，有行为如：跑、跳<br>类：把具有共同特征的对象抽象出一个类，张三李四都属于人类<br>实例化：就是根据某一个类的特征去塑造一个该类的对象</p><ul><li>对象（object）定义：包含特性和行为的一个实体，对象也称为实例（instance）</li><li>类：把具有相同“特性”和“行为”的多个对象的抽象就是类</li><li>实例化：把类具体到某一个对象上面，该对象有具体的什么的状态特征和什么行为</li></ul><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>注意点</p><ol><li>若类使用public修饰，则当前所在的文件名必须和类名相同</li><li>类型必须符合标识符的命名规范（使用名词，每个单词首字母都大写）</li></ol><h4 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h4><p>JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器</p><ul><li>方法区：存放程序中唯一的元素：class字节码文件、static变量</li><li>栈：每调用一个函数，就创建一个栈帧，加入虚拟机栈，调用结束就出栈</li><li>堆：所有new出来的东西</li></ul><h4 id="方法栈帧"><a href="#方法栈帧" class="headerlink" title="方法栈帧"></a>方法栈帧</h4><p>栈特点：先进后出（类似弹夹）<br>写一个sum方法（在main函数外，和main函数在同一个类），再写一个main方法，在main中调用sum方法<br>执行过程：</p><ul><li>执行main方法，main方法对应一个栈帧入栈，里面包含main的成员变量</li><li>调用sum方法，sum方法栈帧入栈，里面包含sum的成员变量</li><li>调用sum方法结束，sum方法出栈，sum方法成员变量清除</li><li>main方法结束，main方法出栈，程序执行结束</li></ul><h4 id="堆与数组初始化"><a href="#堆与数组初始化" class="headerlink" title="堆与数组初始化"></a>堆与数组初始化</h4><p>main方法栈帧入栈</p><ol><li>声明int类型的数组ages：int[]ages；</li><li>在堆中初始化数组： new int[]{10，20，30}；</li><li>把被初始数组的地址赋值给ages变量<br>main方法栈帧出栈</li></ol><p>GC垃圾回收机制：Java自动垃圾回收机制<br>如果给一个数组变量赋了新的数组，就是把新数组的地址赋值给变量<br>原来堆中的数组，就没被引用，等待被回收</p><h4 id="对象堆内存分析"><a href="#对象堆内存分析" class="headerlink" title="对象堆内存分析"></a>对象堆内存分析</h4><p>方法区：存放类的class字节码文件（包括方法，常量，static变量类的描述信息）<br>Person类内存分析</p><ul><li>Person.class 存放在方法区</li><li>main方法栈帧入栈</li><li>new一个具体Person，堆里有了一个Person对象</li><li>将堆里的Person对象地址值赋值给main方法栈帧中的Person变量</li><li>main方法结束 main方法栈帧出栈</li></ul><p>堆里面都有初始值，基本类型为 0 引用类型为 null</p><ul><li>byte short int 0</li><li>long 0L</li><li>float 0.0f</li><li>double 0.0d</li><li>char ‘/u0000’  空值，打印为空格</li><li>boolean false</li></ul><p>基本数据类型：<br>    只有一块存储空间，在栈中，存放的是具体的值<br>引用数据类型：<br>    引用数据类型有两块存储空间：一个在栈（Stack）中，一个在堆（heap）中<br>    5种引用类型：类、接口、数组、枚举、注解</p><p>基本数据类型：值传递<br>引用数据类型：地址传递</p><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>匿名对象：创建一个对象，没有把它赋值给任何一个变量，匿名对象只能使用一次<br>一个对象没有任何人指向时，就会成为垃圾，等待垃圾回收器回收</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器：在创建对象时，自动调用的方法</p><ol><li>和类名相同</li><li>不能定义返回值类型</li><li>不能returen（实际上返回的是创建对象的地址）<br>默认构造器是无参构造，如果类用public修饰，默认构造器也用public修饰</li></ol><p>自己定义了构造器，编译器就不会帮你再生成构造器（需要无参构造就要自己写）</p><p>构造器重载：和方法重载一样，方法名相同，参数不一样</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>在字段和方法前添加了static，那么这个字段或方法它<strong>就属于类</strong><br>状态和行为有： <strong>类和对象之分</strong></p><table><thead><tr><th align="left">分类</th><th align="center">状态</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">对象</td><td align="center">姓名</td><td align="left">死亡</td></tr><tr><td align="left">类</td><td align="center">人口总数</td><td align="left">毁灭</td></tr></tbody></table><ol><li>static修饰的内容随类的加载而加载，JVM把字节码加载到虚拟机中，static修饰的成员自动被加载到方法区</li><li><strong>static修饰的内容优先于对象</strong></li><li>static修饰的内容该类所有对象共享</li><li>static修饰的内容可以通过类名调用(可以通过对象名调用，但编译了本质还是用类名调用)</li></ol><p><strong>类成员</strong>：static修饰的成员<br><strong>实例成员</strong>：非static修饰的成员</p><p>在static方法中只能调用static成员：例如main方法调用的方法就必须是是static方法<br>非static方法可以访问静态成员也可以访问非静态成员：static</p><p>运行：加载class字节码文件，加载static成员（变量、方法）到方法区</p><p>static成员，被所有对象共享时，节省空间，没必须每个对象都存储一份，可以直接使用类名调用，生命周期长，虚拟机停止才消失</p><p>总结：<br>static的作用就是方便在不创建对象的情况下，进行调用方法或变量<br>static方法不能调用非static成员，因为非static成员必须依赖具体对象才能被调用</p><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><ol><li>成员变量：直接定义在类中的变量(也称全局变量或字段，不能称为属性)</li></ol><ul><li>类成员变量：static修饰的成员变量</li><li>实例成员变量：没有static修饰的成员变量，注意：在方法当中不能定义static变量，包括main方法</li></ul><p><strong>有初始值，可以直接用</strong></p><ol start="2"><li>局部变量：定义在方法当中的变量（方法的参数，和内部定的变量,代码块）</li></ol><p><strong>必须初始化才能用</strong></p><p><img src="/2019/12/25/java-note-2/1.png" alt="高新强"></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a><br><a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a><br><a href="https://www.jianshu.com/p/68ddb5484ca2" target="_blank" rel="noopener">什么是多态？实现多态的机制是什么？</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/25/java-note-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-基础</title>
      <link>https://aaronlinv.github.io/2019/12/23/java-note-1/</link>
      <guid>https://aaronlinv.github.io/2019/12/23/java-note-1/</guid>
      <pubDate>Mon, 23 Dec 2019 02:52:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h2&gt;&lt;h4 id=&quot;常量（6种）&quot;&gt;&lt;a href=&quot;#常量（6种）&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h4 id="常量（6种）"><a href="#常量（6种）" class="headerlink" title="常量（6种）"></a>常量（6种）</h4><ul><li>整数<ul><li>二进制   0b 0B （Java7的新特性）（这个是数字零，而不是字母O） </li><li>八进制   0</li><li>十六进制 0x 0X </li></ul></li><li>浮点数</li><li>字符</li><li>字符串</li><li>布尔型</li><li>null</li></ul><h4 id="数据类型（Java是强类型语言）"><a href="#数据类型（Java是强类型语言）" class="headerlink" title="数据类型（Java是强类型语言）"></a>数据类型（Java是强类型语言）</h4><ul><li>基本数据类型（4类8种）<ul><li>整数<ul><li>byte 1字节 </li><li>short 2字节</li><li>int 4字节</li><li>long 8字节 </li></ul></li><li>浮点数<ul><li>float 4字节</li><li>double 8字节</li></ul></li><li>字符 <ul><li>char 2字节</li></ul></li><li>布尔<ul><li>boolean 1字节</li></ul></li><li>注意点<ul><li>整数默认int，浮点数默认double </li><li>long后缀用L标记，float用F标记<ul><li>浮点数默认是double，所以把浮点数赋值给float会报错，应该在浮点数后面加F</li></ul></li><li>科学计数法：3.14e2， 3.14E2 返回double</li><li>float和double都不能精确表示小数</li></ul></li><li>自动转化<ul><li>一个算术表达式中包含多个基本数据类型(boolean除外),不同类型的数据先转化为同一类型，然后进行运算。</li><li>byte,short,char –&gt; int –&gt; long –&gt; float  –&gt; double<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">byte</span> s2=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> s=s1+s2;报错</span><br><span class="line"><span class="keyword">int</span> s=s1+s2;  <span class="comment">//正确 </span></span><br><span class="line"><span class="comment">//自动转化为int类型就像：</span></span><br><span class="line"><span class="keyword">int</span> s = (<span class="keyword">int</span>)s1 +(<span class="keyword">int</span>)s2; </span><br><span class="line"><span class="comment">//或者强转 </span></span><br><span class="line"><span class="keyword">short</span> s=(<span class="keyword">short</span>) (s1+s2);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>引用数据类型<ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>算术运算<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">'a'</span> + <span class="number">1</span>); <span class="comment">//98</span></span><br><span class="line">System.out.println(<span class="string">"a"</span> + <span class="number">2</span>); <span class="comment">//a2 字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(100 /0); 报错</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">100.0</span> / <span class="number">0</span>);<span class="comment">//Infinity </span></span><br><span class="line">System.out.println(-<span class="number">100.0</span> / <span class="number">0</span>);<span class="comment">//-Infinity </span></span><br><span class="line"><span class="comment">//0自动转化为double 0.0 一个数除以很无限接近0的数，就无限大 </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">0.0</span> / <span class="number">0.0</span>);<span class="comment">//NaN  not a number</span></span><br><span class="line"></span><br><span class="line">System.out.println(-<span class="number">10</span> % -<span class="number">3</span>);<span class="comment">//   -3 模除符号只取决于第一个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//s = s + 1; 报错 结果为int不能赋值给short</span></span><br><span class="line">s += <span class="number">5</span>; <span class="comment">//自动强转为short类型</span></span><br></pre></td></tr></table></figure></li><li>逻辑运算符的短路</li></ul><h4 id="流程语句"><a href="#流程语句" class="headerlink" title="流程语句"></a>流程语句</h4><ul><li>switch<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> A值:</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> B值:</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>表达式支持 byte , short , char , int (没有long)，从Java7开始支持String类型</li><li>一旦符合找到匹配的case就开始往下执行（不管后面的case是否匹配）–穿透，除非遇到break或return</li><li>找不到匹配的case，执行default，一般放在最后，放在其他位置，也会穿透</li></ol></li><li>for<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outter:<span class="keyword">for</span>()&#123;</span><br><span class="line">  <span class="keyword">for</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">break</span> outter; <span class="comment">//直接退出外层循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>return <ul><li>结束循环所在的方法</li></ul></li></ul><h4 id="方法与数组"><a href="#方法与数组" class="headerlink" title="方法与数组"></a>方法与数组</h4><ul><li>注意点<ul><li>一个方法前面有static 调用的方法也应该有static</li><li>遵循标识符的规范，多个单词用驼峰表示法：myName</li></ul></li><li>方法签名<ul><li>方法签名:方法名称  +  方法参数列表;</li><li>在同一个类中,方法签名是唯一的,否则编译报</li></ul></li><li>增强for （foreach） 语法糖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] arrays=<span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> array:arrays) &#123;</span><br><span class="line">  System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>方法的可变参数 语法糖<ul><li>可变参数就是,方法的数组参数的一种简写 ( 会自动把… 转成数组 )</li><li>可变参数必须作为方法的最后一个参数</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/23/java-note-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java学习计划</title>
      <link>https://aaronlinv.github.io/2019/12/23/java-plan/</link>
      <guid>https://aaronlinv.github.io/2019/12/23/java-plan/</guid>
      <pubDate>Mon, 23 Dec 2019 01:52:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;写在最前&quot;&gt;&lt;a href=&quot;#写在最前&quot; class=&quot;headerlink&quot; title=&quot;写在最前&quot;&gt;&lt;/a&gt;写在最前&lt;/h2&gt;&lt;p&gt;前一段时间把一些零零碎碎的事都解决了，现在可以沉下心做一件事&lt;/p&gt;
&lt;p&gt;以往我都在纠结自己杂乱地学了很多的东西，后悔自己
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>前一段时间把一些零零碎碎的事都解决了，现在可以沉下心做一件事</p><p>以往我都在纠结自己杂乱地学了很多的东西，后悔自己随波逐流地选择了很多，没有系统地学一项技能</p><p>和一些从事相关行业的前辈聊天后，消除了自己很多的焦虑，在这个阶段，迷茫很正常，但是不能踌躇不前</p><p>这一年，遇到一个在专业上给我很大帮助的学长</p><p>以前有个误区：学过就学会了<br>到现在才越发觉得，只有不断的复习和运用才能巩固学到的东西，知易行难，要努力</p><p>重拾Java，先把Java基础重新过了一遍，一些零碎的知识太久没接触忘记了，查缺补漏</p><h2 id="学习线路"><a href="#学习线路" class="headerlink" title="学习线路"></a>学习线路</h2><p>12.21 Java基础<br>12.23 面向对象<br>12.28 总结复习 基础和面向对象1<br>12.30 总结复习 面向对象2-5</p><hr><p>2020.1.6 结束了面向对象<br>1.7 ~ 1.8 完成一个HRMIS的小项目，巩固自己所学的Java基础<br>1.9 ~ 1.10 HTML<br>1.11 MySQL数据库基础<br>1.11 梳理复习 MySQL数据库基础</p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/23/java-plan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我理解的前端</title>
      <link>https://aaronlinv.github.io/2019/11/20/front-end/</link>
      <guid>https://aaronlinv.github.io/2019/11/20/front-end/</guid>
      <pubDate>Wed, 20 Nov 2019 15:30:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;故事开始&quot;&gt;&lt;a href=&quot;#故事开始&quot; class=&quot;headerlink&quot; title=&quot;故事开始&quot;&gt;&lt;/a&gt;故事开始&lt;/h2&gt;&lt;p&gt;这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家</p><p>也是因为这个契机，我开始了解前端，通过这段时间的学习，我对前端有了更为具体的认识</p><p>数据库老师应该是我遇到最好的专业课老师，他讲的课融入了很多他自己的项目实践经验，他平易近人，很乐意并且有能力解决我们的问题，也鼓励我们主动学习。基本上每个老师都在提倡主动学习，但是真正愿意花时间引导学生去主动学习的老师少之又少</p><h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>在我看刚开始尝试去了解前端的时候，这些资料对我理解前端有很大帮助，所以强烈推荐你也看看，或许有不同的收获</p><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a></p><h2 id="前端是做什么的"><a href="#前端是做什么的" class="headerlink" title="前端是做什么的"></a>前端是做什么的</h2><p>前端主要的两个重点</p><ul><li>界面展示</li><li>用户交互</li></ul><p>看到的一个例子比较形象：如果把网页比喻成汽车，那么前端就是看得见摸得着的内饰、方向盘、油门、刹车，而不容易直接看见但对汽车也很重要的则是后端，比如引擎</p><h2 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h2><p>既然提到网页，那就不得不说说浏览器，浏览器有两种引擎</p><p><img src="/2019/11/20/front-end/1.png" alt="浏览器引擎"></p><p><img src="/2019/11/20/front-end/2.png" alt="浏览器引擎介绍"></p><p>渲染引擎：负责渲染网页的HTML和CSS，随着JS解释引擎越来越独立，现在一般也把渲染引擎称为 <strong>浏览器内核</strong></p><p>比较值得一提的是：苹果的Webkit是开源的，谷歌的Blink是Webkit的分支，但可能是谷歌Chrome浏览器市场占有率比较高，很多人会误以为Webkit是Chrome的内核</p><p>Chromium：是谷歌的一个开源项目（Chromium相当于Chrome的工程版），国内的QQ浏览器、360极速浏览器、搜狗浏览器还有微软新推出的Edge都是基于这个项目开发的</p><p><img src="/2019/11/20/front-end/3.png" alt="JS解释引擎"><br>JS解释引擎：负责解释网页的Javascript，不同的浏览器使用的JS解释引擎也不尽相同，这里先提一下大名鼎鼎的 <strong>Chrome V8</strong> </p><h2 id="前端发展"><a href="#前端发展" class="headerlink" title="前端发展"></a>前端发展</h2><p>不同的参考资料会把前端划分成几个不同的阶段，这里我也简单分了几个阶段，可能不太准确，但是希望能帮助你大概梳理前端的发展过程</p><ul><li>静态页面配合Jsp等服务端混合开发</li><li>Ajax JQuery等技术诞生</li><li>前端框架</li></ul><h2 id="静态页面配合Jsp等服务端混合开发"><a href="#静态页面配合Jsp等服务端混合开发" class="headerlink" title="静态页面配合Jsp等服务端混合开发"></a>静态页面配合Jsp等服务端混合开发</h2><p>最开始的网页都是静态的，使用前端三大基础技术（HTML+CSS+JavaScript）开发，但是随着时代的发展，静态网页不能满足需求，网站需要为不同用户显示不同的网页内容</p><p>这个时候就需要动态网页，就有了Jsp( Java Server Pages )这类技术，可以对不同的用户动态生成不同的网页，它的原理就是在传统的网页HTML文件中插入Java程序段和JSP标记</p><p>虽然可以实现动态页面，但是这项技术也有很明显的缺点，就是在前后端都写好各自的代码之后需要将JSP代码插入到HTML，这就要求整合代码的工程师比必须前后端都懂，而且前后端代码杂糅在一起，也不利于维护</p><h2 id="Ajax-JQuery等技术诞生"><a href="#Ajax-JQuery等技术诞生" class="headerlink" title="Ajax JQuery等技术诞生"></a>Ajax JQuery等技术诞生</h2><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>Ajax使得不需要刷新网页，就可以实现网页部分内容的更新，最常见的例子就是各种网页划到最后，网页会继续加载后面的内容，而这个过程，网页没有刷新</p><p>Ajax的出现，可以让前后端工程师以Ajax接口为分界点进行前后端分离，根据规定好的交互接口，分头工作</p><h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><p>JQuery是一套JavaScript的库，简化了JavaScript开发的复杂性</p><p>简化了原生JavaScript代码，举个例获取id为content的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).value　　　　　　　　　　</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery：</span></span><br><span class="line">$(<span class="string">'# content'</span>).val()</span><br></pre></td></tr></table></figure><p>同时JQuery也屏蔽了浏览器兼容性问题。在IE678的时代，不同浏览器存在很多兼容问题，其中IE就不识别很多标准的JavaScript方法和对象。但是JQuery屏蔽了这些问题，开发者可以用JQuery开发而不用考虑兼容问题</p><p>JQuery还允许开发者定制插件，大量优秀的jQuery插件与UI库不断涌现，使得前端开发者可以直接使用这些插件进行开发，极大提高的开发效率，就比如下面的全屏滚动插件 fullPage.js 和粒子插件，点击图片可以访问对应网站</p><p><a href="https://alvarotrigo.com/fullPage/zh/#page1" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/4.png" alt="fullPage.js"></a></p><p><a href="https://vincentgarreau.com/particles.js" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/5.png" alt="particle.js"></a></p><h4 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h4><p>2008年Google丹麦开发了 <strong>Chrome V8</strong> ，把JavaScript编译成机器码，还使用了其他方法提高性能，使得JavaScript在V8引擎下运行速度非常快，可以媲美二进制程序</p><p>有一个组织：Node，发现既然V8运行效率这么高，那么有没有其他的可能呢，所以他们基于 Chrome V8 引擎，加入系统级API，开发了Node.js，这是一个 JavaScript 运行环境</p><p>Noce.js的本质：允许开发者像使用C 或者C++那样程序去使用JS程序，性能还差不多，至此JavaScript已经不仅仅只局限在写网页特性了，还可以写服务器、虚拟机内核等等的，开发者就可以借助node开发各种自动化工具</p><p>2010年10月，Google推出 Angular JS ，这是一款 JavaScript 框架，用来开发浏览器应用，但是 Angular JS缺陷挺多，所以谷歌后来推出 Angular 框架(这两个是独立的产品)</p><p>基于 Angular 思路成功 就有了 Vue 和 React ，就有了前端框架三足鼎立的局面。前端工程师就可以组件化开发模式利用了JS的智能可编程性来管理HTML和CSS<br>工程文件结构</p><p>有了 node ，我可以调用操作系统的资源，我们就可以规定一些语法和文件，就像定义一些模板，让 node 帮我们去生成 HTML ,CSS 和JavaScript ，我们就可以不必去写这些代码，代码管理性、可复用性、工程性就越来越好</p><h4 id="不一样的JavaScript"><a href="#不一样的JavaScript" class="headerlink" title="不一样的JavaScript"></a>不一样的JavaScript</h4><p>在了解前端的发展之前，我对于 JavaScript 的理解还停留在只能写写网页特效的层面，但是现在我才意识到得益于 Chrome V8 和Node ，使得 JavaScript 展现出不一样的活力，可以用来写服务器、内核，还有各种跨平台的应用</p><p>Cordova：Adobe 发起的项目原名叫 PhoneGap，后来贡献给 Apache 基金会，<br>Cordova是一个框架，允许开发者用 HTML ,CSS 和JavaScript 开发可以跨平台在安卓,IOS,Windows上的程序</p><p>Electron：允许开发者用 HTML ,CSS 和JavaScript 开发运行在Windows,Linux,Mac 上的程序。VScode ,微信Linux , Atom , Github客户端都使用这个框架开发</p><p><img src="/2019/11/20/front-end/6.png" alt="VScdoe"><br><img src="/2019/11/20/front-end/7.png" alt="WeChat"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a><br><a href="https://www.bilibili.com/video/av52669035​" target="_blank" rel="noopener">WEB前端——浏览器内核 </a><br><a href="https://cloud.tencent.com/developer/article/1333686​" target="_blank" rel="noopener">web的发展</a><br><a href="https://www.bilibili.com/video/av61920847/" target="_blank" rel="noopener">【网页设计】30年发展史1990-2019 （中英字幕1080P）​</a><br><a href="https://zhuanlan.zhihu.com/p/84054729​" target="_blank" rel="noopener">erverless——前端的3.0时代 </a><br><a href="https://segmentfault.com/a/1190000016269636" target="_blank" rel="noopener">《从零构建前后分离web项目》：开篇 - 纵观WEB历史演变 </a><br><a href="https://cloud.tencent.com/developer/article/1028964​" target="_blank" rel="noopener">学前端，我们要学的是什么 </a><br><a href="https://www.bilibili.com/video/av27151150" target="_blank" rel="noopener">【WEB全能课】第一讲：初识前端  </a><br><a href="https://juejin.im/post/58ed0a938d6d8100580a45b0​" target="_blank" rel="noopener">Web简史 </a><br><a href="https://www.zhihu.com/question/21923056/answer/804820546​​​" target="_blank" rel="noopener">到底什么是前端、后端、后台啊？ - 科普小民工的回答 - 知乎 </a><br><a href="https://zhuanlan.zhihu.com/p/68030183​" target="_blank" rel="noopener">前端开发 20 年变迁史 </a><br><a href="https://www.itsource.cn/web/news/1892.html​" target="_blank" rel="noopener">程序员和准程序员必看：Web技术的发展历史和未来趋势  </a><br><a href="https://zhuanlan.zhihu.com/p/30704540​" target="_blank" rel="noopener">Query真的过时了! </a><br><a href="https://www.cnblogs.com/leftJS/p/11073481.html​" target="_blank" rel="noopener">MD、CMD规范 </a><br><a href="https://www.uisdc.com/brief-history-of-web-design" target="_blank" rel="noopener">涨姿势！写给网页设计师的网页设计简史 </a><br><a href="https://www.zhihu.com/question/304757674/answer/546374749" target="_blank" rel="noopener">前端三大框架以及jquery与bootstrap这种框架有什么（概念上、范畴上的）区别？ - 陈龙的回答 - 知乎</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/11/20/front-end/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
