<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Aaron Lin</title>
    <link>https://aaronlinv.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 28 Dec 2019 15:01:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java笔记-面向对象</title>
      <link>https://aaronlinv.github.io/2019/12/25/java-note-2/</link>
      <guid>https://aaronlinv.github.io/2019/12/25/java-note-2/</guid>
      <pubDate>Wed, 25 Dec 2019 13:15:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;面向过程与面向对象&quot;&gt;&lt;a href=&quot;#面向过程与面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向过程与面向对象&quot;&gt;&lt;/a&gt;面向过程与面向对象&lt;/h4&gt;&lt;p&gt;如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h4 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h4><p>如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写好，而面向对象就像是去饭店吃饭，告诉服务员吃什么就好了，而不用考虑菜是怎么做的，只要吃就好了</p><ul><li>面向过程<ul><li>面向过程性能比面向对象高，面向对象调用类需要实例化，资源开销大，而面向对象则不需要</li></ul></li><li>面向对象<ul><li>易维护、易复用、易扩展，可以设计出低耦合的系统</li></ul></li></ul><p>面向对象就像是盖浇饭，饭和菜分离可维护性好，耦合程度低，可根据需求更改饭或者菜，而不像蛋炒饭，蛋和饭杂糅在一起，想替换其中某一个都非常困难</p><h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>封装：去饭店吃饭，你并不知道饭菜的具体做饭，但是你可以通过服务员来点菜，得到点的饭菜<br>继承：父亲有钱，儿子可以继承父亲的财产<br>多态：亲戚结婚，邀请函上写的是你的父亲的名字，但实际上可以是你或你的妹妹去参加</p><ul><li>封装：封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能</li><li>继承：当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员</li><li>多态：多态是可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征</li></ul><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>对象：可以是一个人，具有特性如：身高、体重，有行为如：跑、跳<br>类：把不同的人都归并到一个类中，张三李四都是人类<br>实例化：就是根据某一个类的特征去塑造一个该类对象</p><ul><li>对象（object）定义：包含特性和行为的一个实体，对象也称为实例（instance）</li><li>类：把具有相同“特性”和“行为”的多个对象的抽象就是类</li><li>实例化：把类具体到某一个对象上面，该对象有具体的什么的状态特征和什么行为</li></ul><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>注意点</p><ol><li>若类使用public修饰，则当前所在的文件名必须和类名相同</li><li>类型必须符合标识符的命名规范（使用名词，首字母大写）</li></ol><h4 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h4><p>JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器</p><ul><li>方法区：存放程序中唯一的元素：class字节码文件、static变量</li><li>栈：每调用一个函数，就创建一个栈帧，加入虚拟机栈，调用结束就出栈</li><li>堆：所有new出来的东西</li></ul><h4 id="方法栈帧"><a href="#方法栈帧" class="headerlink" title="方法栈帧"></a>方法栈帧</h4><p>栈特点：先进后出（类似弹夹）<br>写一个sum方法，再写一个main方法，在main中调用sum方法<br>执行过程：</p><ul><li>执行main方法，main方法对应一个栈帧入栈，里面包含main的成员变量</li><li>调用sum方法，sum方法栈帧入栈，里面包含sum的成员变量</li><li>调用sum方法结束，sum方法出栈，sum方法成员变量清除</li><li>main方法结束，main方法出栈，程序执行结束</li></ul><h4 id="堆与数组初始化"><a href="#堆与数组初始化" class="headerlink" title="堆与数组初始化"></a>堆与数组初始化</h4><p>main方法栈帧入栈</p><ol><li>声明int类型的数组ages int[]ages；</li><li>在堆中初始化数组 new int[]{10，20，30}；</li><li>把被初始数组的地址赋值给ages变量<br>main方法栈帧出栈</li></ol><p>GC垃圾回收机制：Java自动垃圾回收机制<br>如果给一个数组变量赋了新的数组，就是把新数组的地址赋值给变量<br>原来堆中的数组，就没被引用，等待被回收</p><h4 id="对象堆内存分析"><a href="#对象堆内存分析" class="headerlink" title="对象堆内存分析"></a>对象堆内存分析</h4><p>方法区：存放类的class字节码文件（包括方法，常量，static变量类的描述信息）<br>Person类内存分析</p><ul><li>Person.class 存放在方法区</li><li>main方法栈帧入栈</li><li>new一个具体Person，堆里有了一个Person对象</li><li>将堆里的Person对象地址值赋值给main方法栈帧中的Person变量</li><li>main方法结束 main方法栈帧出栈</li></ul><p>堆里面都有初始值，基本类型为 0 引用类型为 null</p><ul><li>byte short int 0</li><li>long 0L</li><li>float 0.0f</li><li>double 0.0d</li><li>char ‘/u0000’  空值，打印为空格</li><li>boolean false</li></ul><p>基本数据类型：<br>    只有一块存储空间，在栈中，存放的是具体的值<br>引用数据类型：<br>    引用数据类型有两块存储空间：一个在栈（Stack）中，一个在堆（heap）中<br>    5种引用类型：类、接口、数组、枚举、注解</p><p>基本数据类型：值传递<br>引用数据类型：地址传递</p><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>匿名对象：创建一个对象，没有把它赋值给任何一个变量，匿名对象只能使用一次<br>一个对象没有任何人指向时，就会成为垃圾，等待垃圾回收器回收</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器：在创建对象时，自动调用的方法</p><ol><li>和类名相同</li><li>不能定义返回值类型</li><li>不能returen（实际上返回的是创建对象的地址）<br>默认构造器是无参构造，如果类用public修饰，默认构造器也用public修饰</li></ol><p>自己定义了构造器，编译器就不会帮你再生成构造器（需要无参构造就要自己写）</p><p>构造器重载：和方法重载一样，方法名相同，参数不一样</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>在字段和方法前添加了static，那么这个字段或方法它<strong>就属于类</strong><br>状态和行为有： <strong>类和对象之分</strong></p><table><thead><tr><th align="left">分类</th><th align="center">状态</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">对象</td><td align="center">姓名</td><td align="left">死亡</td></tr><tr><td align="left">类</td><td align="center">人口总数</td><td align="left">毁灭</td></tr></tbody></table><ol><li>static修饰的内容随类的加载而加载，JVM把字节码加载到虚拟机中，static修饰的成员自动被加载到方法区</li><li><strong>static修饰的内容优先于对象</strong></li><li>static修饰的内容该类所有对象共享</li><li>static修饰的内容可以通过类名调用(可以通过对象名调用，但编译了本质还是用类名调用)</li></ol><p><strong>类成员</strong>：static修饰的成员<br><strong>实例成员</strong>：非static修饰的成员</p><p>在static方法中只能调用static成员：例如main方法调用的方法就必须是是static方法<br>非static方法可以访问静态成员也可以访问非静态成员：static</p><p>运行：加载class字节码文件，加载static成员（变量、方法）到方法区</p><p>static成员，被所有对象共享时，节省空间，没必须每个对象都存储一份，可以直接使用类名调用，生命周期长，虚拟机停止才消失</p><p>总结：<br>static的作用就是方便在不创建对象的情况下，进行调用方法或变量<br>static方法不能调用非static成员，因为非static成员必须依赖具体对象才能被调用</p><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><ol><li>成员变量：直接定义在类中的变量(也称全局变量或字段，不能称为属性)</li></ol><ul><li>类成员变量：static修饰的成员变量</li><li>实例成员变量：没有static修饰的成员变量，注意：在方法当中不能定义static变量</li></ul><p><strong>有初始值，可以直接用</strong></p><ol><li>局部变量：定义在方法当中的变量（方法的参数，和内部定的变量,代码块）</li></ol><p><strong>必须初始化才能用</strong></p><p><img src="/2019/12/25/java-note-2/1.png" alt="高新强"></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a><br><a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a><br><a href="https://www.jianshu.com/p/68ddb5484ca2" target="_blank" rel="noopener">什么是多态？实现多态的机制是什么？</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/25/java-note-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java笔记-基础</title>
      <link>https://aaronlinv.github.io/2019/12/23/java-note-1/</link>
      <guid>https://aaronlinv.github.io/2019/12/23/java-note-1/</guid>
      <pubDate>Mon, 23 Dec 2019 02:52:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;写在最前&quot;&gt;&lt;a href=&quot;#写在最前&quot; class=&quot;headerlink&quot; title=&quot;写在最前&quot;&gt;&lt;/a&gt;写在最前&lt;/h2&gt;&lt;p&gt;前一段时间把一些零零碎碎的事都解决了，现在可以沉下心做一件事&lt;/p&gt;
&lt;p&gt;以往我都在纠结自己杂乱地学了很多的东西，后悔自己
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>前一段时间把一些零零碎碎的事都解决了，现在可以沉下心做一件事</p><p>以往我都在纠结自己杂乱地学了很多的东西，后悔自己随波逐流地选择了很多，没有系统地学一项技能</p><p>和一些从事相关行业的前辈聊天后，消除了自己很多的焦虑，在这个阶段，迷茫很正常，但是不能踌躇不前</p><p>这一年，遇到一个在专业上给我很大帮助的学长</p><p>以前有个误区：学过就学会了<br>到现在才越发觉得，只有不断的复习和运用才能巩固学到的东西，知易行难，要努力</p><p>重拾Java，先把Java基础重新过了一遍，一些零碎的知识太久没接触忘记了，查缺补漏</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h4 id="常量（6种）"><a href="#常量（6种）" class="headerlink" title="常量（6种）"></a>常量（6种）</h4><ul><li>整数<ul><li>二进制   0b 0B （Java7的新特性）（这个是数字零，而不是字母O） </li><li>八进制   0</li><li>十六进制 0x 0X </li></ul></li><li>浮点数</li><li>字符</li><li>字符串</li><li>布尔型</li><li>null</li></ul><h4 id="数据类型（Java是强类型语言）"><a href="#数据类型（Java是强类型语言）" class="headerlink" title="数据类型（Java是强类型语言）"></a>数据类型（Java是强类型语言）</h4><ul><li>基本数据类型（4类8种）<ul><li>整数<ul><li>byte 1字节 </li><li>short 2字节</li><li>int 4字节</li><li>long 8字节 </li></ul></li><li>浮点数<ul><li>float 4字节</li><li>double 8字节</li></ul></li><li>字符 <ul><li>char 2字节</li></ul></li><li>布尔<ul><li>boolean 1字节</li></ul></li><li>注意点<ul><li>整数默认int，浮点数默认double </li><li>long后缀用L标记，float用F标记<ul><li>浮点数默认是double，所以把浮点数赋值给float会报错，应该在浮点数后面加F</li></ul></li><li>科学计数法：3.14e2， 3.14E2 返回double</li><li>float和double都不能精确表示小数</li></ul></li><li>自动自动转化<ul><li>一个算术表达式中包含多个基本数据类型(boolean除外),不同类型的数据先转化为同一类型，然后进行运算。</li><li>byte,short,char –&gt; int –&gt; long –&gt; float  –&gt; double<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">byte</span> s2=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> s=s1+s2;报错</span><br><span class="line"><span class="keyword">int</span> s=s1+s2;  <span class="comment">//正确 </span></span><br><span class="line"><span class="comment">//自动转化为int类型就像：</span></span><br><span class="line"><span class="keyword">int</span> s = (<span class="keyword">int</span>)s1 +(<span class="keyword">int</span>)s2; </span><br><span class="line"><span class="comment">//或者强转 </span></span><br><span class="line"><span class="keyword">short</span> s=(<span class="keyword">short</span>) (s1+s2);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>引用数据类型<ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>算术运算<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">'a'</span> + <span class="number">1</span>); <span class="comment">//98</span></span><br><span class="line">System.out.println(<span class="string">"a"</span> + <span class="number">2</span>); <span class="comment">//a2 字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(100 /0); 报错</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">100.0</span> / <span class="number">0</span>);<span class="comment">//Infinity </span></span><br><span class="line">System.out.println(-<span class="number">100.0</span> / <span class="number">0</span>);<span class="comment">//-Infinity </span></span><br><span class="line"><span class="comment">//0自动转化为double 0.0 一个数除以很无限接近0的数，就无限大 </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">0.0</span> / <span class="number">0.0</span>);<span class="comment">//NaN  not a number</span></span><br><span class="line"></span><br><span class="line">System.out.println(-<span class="number">10</span> / -<span class="number">3</span>);<span class="comment">//   -3 模除符号只取决于第一个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//s = s + 1; 报错 结果为int不能赋值给short</span></span><br><span class="line">s += <span class="number">5</span>; <span class="comment">//自动强转为short类型</span></span><br></pre></td></tr></table></figure></li><li>逻辑运算符的短路</li></ul><h4 id="流程语句"><a href="#流程语句" class="headerlink" title="流程语句"></a>流程语句</h4><ul><li>switch<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> A值:</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> B值:</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>表达式支持 byte , short , char , int (没有long)，从Java7开始支持String类型</li><li>一旦符合找到匹配的case就开始往下执行（不管后面的case是否匹配）–穿透，除非遇到break或return</li><li>找不到匹配的case，执行default，一般放在最后，放在其他位置，也会穿透</li></ol></li><li>for<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outter:<span class="keyword">for</span>()&#123;</span><br><span class="line">  <span class="keyword">for</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">break</span> outter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>return <ul><li>结束循环所在的方法</li></ul></li></ul><h4 id="方法与数组"><a href="#方法与数组" class="headerlink" title="方法与数组"></a>方法与数组</h4><ul><li>注意点<ul><li>一个方法前面有static 调用的方法也应该有static</li><li>遵循标识符的规范，多个单词用驼峰表示法：myName</li></ul></li><li>方法签名<ul><li>方法签名:方法名称  +  方法参数列表;</li><li>在同一个类中,方法签名是唯一的,否则编译报</li></ul></li><li>增强for （foreach） 语法糖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> [] arrays=<span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> array:arrays) &#123;</span><br><span class="line">     System.out.println(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>方法的可变参数 语法糖<ul><li>可变参数就是,方法的数组参数的一种简写. ( 会自动把… 转成数组 )</li><li>可变参数必须作为方法的最后一个参数</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/12/23/java-note-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我理解的前端</title>
      <link>https://aaronlinv.github.io/2019/11/20/front-end/</link>
      <guid>https://aaronlinv.github.io/2019/11/20/front-end/</guid>
      <pubDate>Wed, 20 Nov 2019 15:30:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;故事开始&quot;&gt;&lt;a href=&quot;#故事开始&quot; class=&quot;headerlink&quot; title=&quot;故事开始&quot;&gt;&lt;/a&gt;故事开始&lt;/h2&gt;&lt;p&gt;这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>这篇博客源于我在数据库课堂上的分享。数据库刚开课时候，老师就鼓励我们探索自己感兴趣的计算机方向，再把自己的收获分享给大家</p><p>也是因为这个契机，我开始了解前端，通过这段时间的学习，我对前端有了更为具体的认识</p><p>数据库老师应该是我遇到最好的专业课老师，他讲的课融入了很多他自己的项目实践经验，他平易近人，很乐意并且有能力解决我们的问题，也鼓励我们主动学习。基本上每个老师都在提倡主动学习，但是真正愿意花时间引导学生去主动学习的老师少之又少</p><h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>在我看刚开始尝试去了解前端的时候，这些资料对我理解前端有很大帮助，所以强烈推荐你也看看，或许有不同的收获</p><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a></p><h2 id="前端是做什么的"><a href="#前端是做什么的" class="headerlink" title="前端是做什么的"></a>前端是做什么的</h2><p>前端主要的两个重点</p><ul><li>界面展示</li><li>用户交互</li></ul><p>看到的一个例子比较形象：如果把网页比喻成汽车，那么前端就是看得见摸得着的内饰、方向盘、油门、刹车，而不容易直接看见但对汽车也很重要的则是后端，比如引擎</p><h2 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h2><p>既然提到网页，那就不得不说说浏览器，浏览器有两种引擎</p><p><img src="/2019/11/20/front-end/1.png" alt="浏览器引擎"></p><p><img src="/2019/11/20/front-end/2.png" alt="浏览器引擎介绍"></p><p>渲染引擎：负责渲染网页的HTML和CSS，随着JS解释引擎越来越独立，现在一般也把渲染引擎称为 <strong>浏览器内核</strong></p><p>比较值得一提的是：苹果的Webkit是开源的，谷歌的Blink是Webkit的分支，但可能是谷歌Chrome浏览器市场占有率比较高，很多人会误以为Webkit是Chrome的内核</p><p>Chromium：是谷歌的一个开源项目（Chromium相当于Chrome的工程版），国内的QQ浏览器、360极速浏览器、搜狗浏览器还有微软新推出的Edge都是基于这个项目开发的</p><p><img src="/2019/11/20/front-end/3.png" alt="JS解释引擎"><br>JS解释引擎：负责解释网页的Javascript，不同的浏览器使用的JS解释引擎也不尽相同，这里先提一下大名鼎鼎的 <strong>Chrome V8</strong> </p><h2 id="前端发展"><a href="#前端发展" class="headerlink" title="前端发展"></a>前端发展</h2><p>不同的参考资料会把前端划分成几个不同的阶段，这里我也简单分了几个阶段，可能不太准确，但是希望能帮助你大概梳理前端的发展过程</p><ul><li>静态页面配合Jsp等服务端混合开发</li><li>Ajax JQuery等技术诞生</li><li>前端框架</li></ul><h2 id="静态页面配合Jsp等服务端混合开发"><a href="#静态页面配合Jsp等服务端混合开发" class="headerlink" title="静态页面配合Jsp等服务端混合开发"></a>静态页面配合Jsp等服务端混合开发</h2><p>最开始的网页都是静态的，使用前端三大基础技术（HTML+CSS+JavaScript）开发，但是随着时代的发展，静态网页不能满足需求，网站需要为不同用户显示不同的网页内容</p><p>这个时候就需要动态网页，就有了Jsp( Java Server Pages )这类技术，可以对不同的用户动态生成不同的网页，它的原理就是在传统的网页HTML文件中插入Java程序段和JSP标记</p><p>虽然可以实现动态页面，但是这项技术也有很明显的缺点，就是在前后端都写好各自的代码之后需要将JSP代码插入到HTML，这就要求整合代码的工程师比必须前后端都懂，而且前后端代码杂糅在一起，也不利于维护</p><h2 id="Ajax-JQuery等技术诞生"><a href="#Ajax-JQuery等技术诞生" class="headerlink" title="Ajax JQuery等技术诞生"></a>Ajax JQuery等技术诞生</h2><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>Ajax使得不需要刷新网页，就可以实现网页部分内容的更新，最常见的例子就是各种网页划到最后，网页会继续加载后面的内容，而这个过程，网页没有刷新</p><p>Ajax的出现，可以让前后端工程师以Ajax接口为分界点进行前后端分离，根据规定好的交互接口，分头工作</p><h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><p>JQuery是一套JavaScript的库，简化了JavaScript开发的复杂性</p><p>简化了原生JavaScript代码，举个例获取id为content的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).value　　　　　　　　　　</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery：</span></span><br><span class="line">$(<span class="string">'# content'</span>).val()</span><br></pre></td></tr></table></figure><p>同时JQuery也屏蔽了浏览器兼容性问题。在IE678的时代，不同浏览器存在很多兼容问题，其中IE就不识别很多标准的JavaScript方法和对象。但是JQuery屏蔽了这些问题，开发者可以用JQuery开发而不用考虑兼容问题</p><p>JQuery还允许开发者定制插件，大量优秀的jQuery插件与UI库不断涌现，使得前端开发者可以直接使用这些插件进行开发，极大提高的开发效率，就比如下面的全屏滚动插件 fullPage.js 和粒子插件，点击图片可以访问对应网站</p><p><a href="https://alvarotrigo.com/fullPage/zh/#page1" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/4.png" alt="fullPage.js"></a></p><p><a href="https://vincentgarreau.com/particles.js" target="_blank" rel="noopener"><img src="/2019/11/20/front-end/5.png" alt="particle.js"></a></p><h4 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h4><p>2008年Google丹麦开发了 <strong>Chrome V8</strong> ，把JavaScript编译成机器码，还使用了其他方法提高性能，使得JavaScript在V8引擎下运行速度非常快，可以媲美二进制程序</p><p>有一个组织：Node，发现既然V8运行效率这么高，那么有没有其他的可能呢，所以他们基于 Chrome V8 引擎，加入系统级API，开发了Node.js，这是一个 JavaScript 运行环境</p><p>Noce.js的本质：允许开发者像使用C 或者C++那样程序去使用JS程序，性能还差不多，至此JavaScript已经不仅仅只局限在写网页特性了，还可以写服务器、虚拟机内核等等的，开发者就可以借助node开发各种自动化工具</p><p>2010年10月，Google推出 Angular JS ，这是一款 JavaScript 框架，用来开发浏览器应用，但是 Angular JS缺陷挺多，所以谷歌后来推出 Angular 框架(这两个是独立的产品)</p><p>基于 Angular 思路成功 就有了 Vue 和 React ，就有了前端框架三足鼎立的局面。前端工程师就可以组件化开发模式利用了JS的智能可编程性来管理HTML和CSS<br>工程文件结构</p><p>有了 node ，我可以调用操作系统的资源，我们就可以规定一些语法和文件，就像定义一些模板，让 node 帮我们去生成 HTML ,CSS 和JavaScript ，我们就可以不必去写这些代码，代码管理性、可复用性、工程性就越来越好</p><h4 id="不一样的JavaScript"><a href="#不一样的JavaScript" class="headerlink" title="不一样的JavaScript"></a>不一样的JavaScript</h4><p>在了解前端的发展之前，我对于 JavaScript 的理解还停留在只能写写网页特效的层面，但是现在我才意识到得益于 Chrome V8 和Node ，使得 JavaScript 展现出不一样的活力，可以用来写服务器、内核，还有各种跨平台的应用</p><p>Cordova：Adobe 发起的项目原名叫 PhoneGap，后来贡献给 Apache 基金会，<br>Cordova是一个框架，允许开发者用 HTML ,CSS 和JavaScript 开发可以跨平台在安卓,IOS,Windows上的程序</p><p>Electron：允许开发者用 HTML ,CSS 和JavaScript 开发运行在Windows,Linux,Mac 上的程序。VScode ,微信Linux , Atom , Github客户端都使用这个框架开发</p><p><img src="/2019/11/20/front-end/6.png" alt="VScdoe"><br><img src="/2019/11/20/front-end/7.png" alt="WeChat"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av31440465" target="_blank" rel="noopener">简述前后端分离架构：HTML写的不是网页之 - 前端应用发展简史 </a><br><a href="https://zhuanlan.zhihu.com/p/74546693" target="_blank" rel="noopener">前端入门框架前的几个大坑（小白向） - 汪小黑的文章 - 知乎 </a><br><a href="https://www.bilibili.com/video/av52669035​" target="_blank" rel="noopener">WEB前端——浏览器内核 </a><br><a href="https://cloud.tencent.com/developer/article/1333686​" target="_blank" rel="noopener">web的发展</a><br><a href="https://www.bilibili.com/video/av61920847/" target="_blank" rel="noopener">【网页设计】30年发展史1990-2019 （中英字幕1080P）​</a><br><a href="https://zhuanlan.zhihu.com/p/84054729​" target="_blank" rel="noopener">erverless——前端的3.0时代 </a><br><a href="https://segmentfault.com/a/1190000016269636" target="_blank" rel="noopener">《从零构建前后分离web项目》：开篇 - 纵观WEB历史演变 </a><br><a href="https://cloud.tencent.com/developer/article/1028964​" target="_blank" rel="noopener">学前端，我们要学的是什么 </a><br><a href="https://www.bilibili.com/video/av27151150" target="_blank" rel="noopener">【WEB全能课】第一讲：初识前端  </a><br><a href="https://juejin.im/post/58ed0a938d6d8100580a45b0​" target="_blank" rel="noopener">Web简史 </a><br><a href="https://www.zhihu.com/question/21923056/answer/804820546​​​" target="_blank" rel="noopener">到底什么是前端、后端、后台啊？ - 科普小民工的回答 - 知乎 </a><br><a href="https://zhuanlan.zhihu.com/p/68030183​" target="_blank" rel="noopener">前端开发 20 年变迁史 </a><br><a href="https://www.itsource.cn/web/news/1892.html​" target="_blank" rel="noopener">程序员和准程序员必看：Web技术的发展历史和未来趋势  </a><br><a href="https://zhuanlan.zhihu.com/p/30704540​" target="_blank" rel="noopener">Query真的过时了! </a><br><a href="https://www.cnblogs.com/leftJS/p/11073481.html​" target="_blank" rel="noopener">MD、CMD规范 </a><br><a href="https://www.uisdc.com/brief-history-of-web-design" target="_blank" rel="noopener">涨姿势！写给网页设计师的网页设计简史 </a><br><a href="https://www.zhihu.com/question/304757674/answer/546374749" target="_blank" rel="noopener">前端三大框架以及jquery与bootstrap这种框架有什么（概念上、范畴上的）区别？ - 陈龙的回答 - 知乎</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/11/20/front-end/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hadoop大数据平台搭建</title>
      <link>https://aaronlinv.github.io/2019/11/08/big-data/</link>
      <guid>https://aaronlinv.github.io/2019/11/08/big-data/</guid>
      <pubDate>Fri, 08 Nov 2019 04:16:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在网上看到的一张图片，很真实的描述了学习大数据前后对大数据的看法 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/08/big-dat
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在网上看到的一张图片，很真实的描述了学习大数据前后对大数据的看法 </p><p><img src="/2019/11/08/big-data/1.jpg" alt="大数据"></p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li>大数据</li></ul><blockquote><p> 维基的解释是在传统数据处理应用软件不足以处理的大或复杂的数据集</p><p>大数据有四个特点(4个” V “)：数据量大(Volume)、数据类型繁多(Variety)、处理速度快(Velocity)、价值密度低(Value)</p><p>我自己的理解就是在以前对很多数据没有办法进行筛选、存储、分析等操作，但随着技术的发展，现在有很多技术可以完成这些工作，从而使得我们可以得到很多蕴含在这些数据之间的信息。例如网购的订单，最开始电商平台可能只能存储这些订单信息，还没有进行分析，随着技术的发展，就可以分析这些订单之间的联系，从而实现针对性的商品推荐等功能</p></blockquote><ul><li>云计算</li></ul><blockquote><p>通过网络提供可伸缩的、廉价的分布式计算能力。云计算使得计算资源像自来水一样，可以方便取用。有这几种服务类型</p></blockquote><blockquote><p>基础设施即服务 IaaS (Infrastructure as a Service) 提供了基础设施，CPU、内存、网络、存储等，客户需要自己配置环境，然后运行自己的服务</p><p>平台即服务 PasS (Platform as a Service) 提供了服务器平台或者开发环境，客户可以在这个平台上部署自己的服务</p><p>软件即服务 SaaS (Software as a Service) 提供的就是软件成品，客户可以按需购买，就像购买一些邮件服务，即开即用，不需要关心它运行在什么平台或者是运行在什么硬件上</p></blockquote><ul><li>物联网</li></ul><blockquote><p>利用通信技术把传感器、机器、控制器、人员、物连接在一起，实现彼此间的通信、收集和传输数据。最常见的应用就是一些智能可穿戴设备、智能家居、智能交通</p></blockquote><ul><li>相互的联系</li></ul><blockquote><p>大数据、云计算、物联网之间既有区别也有联系<br>云计算为大数据提供了技术基础<br>物联网是大数据的重要来源</p></blockquote><h2 id="Hadoop开源分布计算式计算平台"><a href="#Hadoop开源分布计算式计算平台" class="headerlink" title="Hadoop开源分布计算式计算平台"></a>Hadoop开源分布计算式计算平台</h2><p>Hadoop是Apache软件基金会旗下的一个开源分布计算式计算平台，Hadoop的核心是HDFS(Hadoop Distributed File System)和MapReduce</p><p>HDFS是面向普通硬件环境的分布式文件系统，MapReduce是开发并行应用的程序</p><h2 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h2><p>我是参考厦门大学林子雨老师的<a href="http://dblab.xmu.edu.cn/blog/285/" target="_blank" rel="noopener">大数据处理架构Hadoop安装教程</a>，这个教程提供了多种不同安装方式的详细指导</p><p>我选择的是VMware虚拟机中安装Ubuntu，伪分布式安装Hadoop2.7.1，建议使用这个教程提供的系统和各种软件，遇到需要输入或者起名的步骤尽量和教程保持一致，这样可以规避一些奇奇怪怪的问题。在学习一个技术的初期，如果因为软件配置、兼容性等问题而浪费大量时间会非常闹心</p><p>解压Hadoop后，如果是是单机模式，无需配置，直接开始使用就好了。如果选择伪分布式，需要配置core-site.xml和hdfs-site.xml即可，需要特别注意的是：配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。同时也指定 dfs.namenode.name.dir 和dfs.datanode.data.dir 避免出错。</p><p>配置好后就要格式化NameNode(在Hadoop目录下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format <span class="comment">#格式化NameNode</span></span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/big-data/2.png" alt="Namenode format"></p><p>看到 successfully formatted 和 Exitting with status 0 就表示格式化成功，然后可以启动所有进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-all.sh <span class="comment">#启动所有进程</span></span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/big-data/3.png" alt="star-all.sh"></p><p>进程启动后可以用jps来查看所有的Java进程，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>如果没有这些进程，可以尝试先停止所有进程，然后再启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-all.sh <span class="comment">#先执行关闭所有进程</span></span><br><span class="line"></span><br><span class="line">./sbin/stop-all.sh <span class="comment">#所有进程都关闭后，再启动所有进程</span></span><br></pre></td></tr></table></figure><h2 id="HDFS-Shell命令"><a href="#HDFS-Shell命令" class="headerlink" title="HDFS Shell命令"></a>HDFS Shell命令</h2><p>HDFS是一个分布式文件系统，所以我们可以对HDFS中的文件进行上传、下载、复制等文件操作。可以用shell命名完成这些操作</p><p>对于文件操作这个功能，HDFS有三种命令标记，如果用来操作HDFS这三中貌似用起来是一模一样的</p><ul><li>hadoop fs  适用于本地系统和HDFS系统</li><li>hadoop dfs 只能操作HDFS文件系统，已经Deprecated(不推荐使用)，推荐使用第三个hdfs dfs</li><li>hdfs dfs 只能操作HDFS文件系统</li></ul><p>实际上很多命令和Linux的shell差不多，不过要注意格式，用ls(显示目录下的文件信息)命令举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls / <span class="comment">#这里用hdfs dfs 用其他两个效果是一样的</span></span><br></pre></td></tr></table></figure><blockquote><p>命令前面一定要加- 如：-ls</p></blockquote><blockquote><p>命令之后一定要指定目录 如：/     (左斜杆就是代表HDFS目录的根)</p></blockquote><p>例举一些常用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls / <span class="comment">#ls 查看更目录下的文件信息</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –mkdir –p /user/hadoop <span class="comment">#mkdir 新建文件夹 -p 递归操作</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –rm –r /input <span class="comment">#rm 删除目录 -r 递归删除</span></span><br><span class="line"></span><br><span class="line">hdfs dfs -cp /myLocalFile.txt /user/hadoop/ <span class="comment">#cp 在HDFS复制文件 复制根目录下的myLocalFile.txt到/user/hadoop/</span></span><br><span class="line"></span><br><span class="line">hdfs dfs –cat /myLocalFile.txt <span class="comment"># cat 查看文件内容 </span></span><br><span class="line"></span><br><span class="line">hdfs dfs -put /home/hadoop/myLocalFile.txt  / <span class="comment">#put 上传文件到HDFS 将本地的myLocalFile.txt文件上传到HDFS的根目录下</span></span><br><span class="line">hdfs dfs -put /home/hadoop/myLocalFile.txt  /test.txt <span class="comment">#将本地的myLocalFile.txt文件上传到HDFS的根目录下,并且重命名为test.txt</span></span><br><span class="line"></span><br><span class="line">hdfs dfs -get /myLocalFile.txt  /home/hadoop/ <span class="comment"># get 下载文件到本地 下载HDFS根目录下的myLocalFile.txt文件到本地的/home/hadoop/</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">IaaS，PaaS，SaaS 的区别 作者： 阮一峰</a></p><p> <a href="https://www.zhihu.com/question/19751763" target="_blank" rel="noopener">什么是物联网？其发展前景如何？</a></p><p> <a href="http://dblab.xmu.edu.cn/blog/install-hadoop-in-centos/" target="_blank" rel="noopener">Hadoop安装教程_伪分布式配置_CentOS6.4/Hadoop2.6.0</a></p><p> <a href="https://blog.csdn.net/pipisorry/article/details/51340838" target="_blank" rel="noopener">Hadoop：hadoop fs、hadoop dfs与hdfs dfs命令的区别</a></p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/11/08/big-data/#disqus_thread</comments>
    </item>
    
    <item>
      <title>爬虫是咋回事</title>
      <link>https://aaronlinv.github.io/2019/10/31/python-web-spider/</link>
      <guid>https://aaronlinv.github.io/2019/10/31/python-web-spider/</guid>
      <pubDate>Thu, 31 Oct 2019 08:46:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前零零碎碎接触过几次爬虫，有的是公开课，有的是实体课。老师都是偏实践，对于理论的部分都是一笔带过，所以对于那些库都是一知半解。自己也想写一
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前零零碎碎接触过几次爬虫，有的是公开课，有的是实体课。老师都是偏实践，对于理论的部分都是一笔带过，所以对于那些库都是一知半解。自己也想写一些东西，尽可能在吸收那些大佬的总结的同时，加入一些自己的理解。把大佬一越而过，而我们要挣扎很久的坑铺平。</p><p>这样学的知识更像是一盘散沙，我会简单地使用这些函数去实现一些功能，但却不清楚它们之间的关系，遇到一些复杂的问题就很难去处理。系统地学习虽然比较耗时，但是会对整个体系有个了解，而这在你遇到一些问题的时候会发挥重要作用。</p><p>网上教程的质量参差不齐，而且代码案例爬取的网站的结构也可能随着时间的推移而改变，对于初学者来说是个不小的挑战。</p><p>我看的是嵩天老师的<a href="https://www.icourse163.org/learn/BIT-1001870001" target="_blank" rel="noopener">Python网络爬虫与信息提取</a>，嵩天老师讲的比较通俗易懂，不需要有特别扎实的Python基础也能听懂。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>爬取网页，程序没有反应：可能是网络连接问题，可以用通用代码架构来提高爬虫的可靠性</li><li>F12开发者工具-Network选项卡里可以看的文本但是爬取的文本却没有：网站防爬机制，可以定义Headers,Cookie等解决</li></ul><h2 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h2><p>对于非异步加载的网站，一般都可以通过requests库和BeautifulSoup库爬取信息</p><ol><li>获取网页的源代码：通过Requests库，来获取网页的HTML代码</li><li>解析网页代码获得期望的数据：通过BeautifulSoup库解析网页源代码，把我们需要的信息按照一定规则提取出来<h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2>requests库有7个主要方法，后6个方法都是对request方法的封装（使用更方便）</li></ol><p><img src="/2019/10/31/python-web-spider/1.png" alt="嵩天"></p><p>6个方法对应的就是HTTP协议对资源的操作</p><p><img src="/2019/10/31/python-web-spider/2.png" alt="嵩天"></p><p>HTTP请求状态：status_code 200表示成功，返回其他值说明连接出现问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url) <span class="comment">#url传入爬取的网址</span></span><br><span class="line">print(r.status_code)  <span class="comment">#200表示连接成功</span></span><br></pre></td></tr></table></figure><p>爬虫通用框架：网络连接可能出现各种异常，所以我们可以用try-except处理异常，增强代码可靠性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，用于获得网页源代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>) <span class="comment"># 设置超时时间为30毫秒</span></span><br><span class="line">        r.raise_for_status() <span class="comment"># 这个方法就是判断status_code是否为200，否的话引发HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text <span class="comment"># 返回爬取到的文本</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br></pre></td></tr></table></figure><p>编码：如果header没有chartset指定编码，默认就是ISO-8859-1，这个编码不能解析中文，可能会出现乱码，而apparent_encoding会根据内容猜测编码，所以我们一般把编码设置为apparent_encoding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.encoding = r.apparent_encoding</span><br></pre></td></tr></table></figure><h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>BeautifulSoup使用pip安装要注意，如果没有加末尾的4，实际安装的是BeautifulSoup3 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip insatll beautifulsoup4</span><br></pre></td></tr></table></figure><p>在import的时候也要注意，从bs4库(beautifulsoup4)中引入BeautifulSoup这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#注意B和S是大写</span></span><br></pre></td></tr></table></figure><p>创建一个BeautifulSoup对象，传入的一个参数是需要解析的HTML或者XML文档，第二个参数是使用的解析器，这里需要lxml，需要安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><p>BeautifulSoup类的基本元素：</p><ul><li>Tag：标签，HTML中由&lt;&gt;和&lt;/&gt;构成的那些标签</li><li>Name：就是标签的名字，a标签、p标签</li><li>Attributes：标签的属性</li><li>NavigableString：标签的&lt;&gt;和&lt;/&gt;之间的文字</li><li>Comment：HTML中的注释 </li></ul><p>爬取数据需要先找到数据对应Tag标签，而Name,Attributes,NavigableString,Comment就是围绕着Tag标签，Comment相对来说用的少</p><p>HTML标签树遍历：</p><ul><li>下行遍历：.contents  .children  .descendants</li><li>上行遍历：.parent  .parents</li><li>平行遍历：.next_sibling  .next_siblings  .previous_sibling  .previous_sibling</li></ul><p>有复数含义的属性返回的都是列表，而像.parent .next_sibling  .previous_sibling 这些都是返回一个Tag标签节点 &lt;class ‘bs4.element.Tag’&gt; 或者是一个字符串节点（有可能是\n）,在遍历这些列表的时候如果没有判断类型，使用的时候可能会报错</p><blockquote><p>TypeError: ‘NavigableString’ object is not callable</p></blockquote><p>find_all( )方法：</p><ul><li>可检索标签名、标签属性、标签内的字符串，返回一个列表</li><li>还有find( ),find_parent( ),find_parents( )等方法</li><li>因为dind_all比较常用，所以对象是Tag或者是soup都可以省略find_all,<tag>find_all(…)等价于<tag>(…),soup.find_all(..)等价于soup(…)<h2 id="爬取大学排名实例"><a href="#爬取大学排名实例" class="headerlink" title="爬取大学排名实例"></a>爬取大学排名实例</h2>爬取最好大学网的大学排名数据，将排名、学校名称、地区输出到屏幕</tag></tag></li></ul><p><img src="/2019/10/31/python-web-spider/3.png" alt="爬取大学排名效果"></p><h3 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul><li>遍历每个tr获取每个大学信息，出现object is not callable</li><li>输出到屏幕排版问题</li></ul><h3 id="分析网页结构"><a href="#分析网页结构" class="headerlink" title="分析网页结构"></a>分析网页结构</h3><p>Chrome浏览器打开<a href="http://zuihaodaxue.com/zuihaodaxuepaiming2019.html" target="_blank" rel="noopener">最好大学网的网页</a>，按F12打开开发者工具</p><p><img src="/2019/10/31/python-web-spider/4.png" alt="Chrome开发者工具"></p><p>需要刷新一下网页才会显示，双击这个document文件</p><p><img src="/2019/10/31/python-web-spider/5.png" alt="Document文件"></p><p>选择Response选项卡就可以看到HTML代码，全选复制到编辑器里</p><p><img src="/2019/10/31/python-web-spider/6.png" alt="VScode"></p><p>排名的信息在tbody标签里，每一个tr标签里面都是一所大学的信息，每一个td标签就是每所大学具体的信息。我们可以遍历tbody里面的每个tr标签，然后把每所大学的信息都保存在list里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            <span class="comment"># import bs4 才能使用对应的标签定义</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)  <span class="comment"># 查询tr 中的td标签</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">2</span>].string])</span><br></pre></td></tr></table></figure><p>在遍历的时候报错,会遇到一个问题：</p><blockquote><p>发生异常: TypeError’NavigableString’ object is not callable</p></blockquote><p><img src="/2019/10/31/python-web-spider/7.png" alt="comment"></p><p>原因是：HTML代码tbody标签中最后有一段Comment,而Comment对象和NavigableString对象不能像Tag对象一样被调用，所以我们在遍历时需要对类型进行判断，判断是否为：bs4.element.Tag</p><h3 id="排版问题"><a href="#排版问题" class="headerlink" title="排版问题"></a>排版问题</h3><p>在输出时候中文排版会出现一些小问题<br><img src="/2019/10/31/python-web-spider/8.png" alt="排版错误"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>原因就是我们在使用format方法在我们定义好的布局里填充大学信息的时候，排版默认使用西文的空格，这样会导致排版错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="comment"># 使用中文空格填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="comment"># print(u)</span></span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure><p>我们可以使用中文空格来进行填充，这样可以解决排版问题，chr(12288)就是中文空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个tplt就是我们定义每行的模板，&#123;&#125;里面就是要填充的内容</span></span><br><span class="line"><span class="comment"># 冒号前面是填充内容的索引号，^10 ^的表居中对齐10代表宽度为10</span></span><br><span class="line"><span class="comment"># \t 表示一个制表符，在冒号后面是填充字符，不指定默认使用西文空格</span></span><br><span class="line"><span class="comment"># 这里我们指定&#123;3&#125;,就是使用索引为3的 chr(12288) 来填充</span></span><br></pre></td></tr></table></figure><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>先把大体的框架写完</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://zuihaodaxue.com/zuihaodaxuepaiming2019.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>)  <span class="comment"># 爬取前20名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>再填充每个具体的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(ulist, html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr, bs4.element.Tag):</span><br><span class="line">            <span class="comment"># import bs4 才能使用对应的标签定义</span></span><br><span class="line">            tds = tr(<span class="string">'td'</span>)  <span class="comment"># 查询tr 中的td标签</span></span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">2</span>].string])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def printUnivList(ulist, num):</span></span><br><span class="line"><span class="comment">#     print("&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;".format("排名", "学校名称", "总分"))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     for i in range(num):</span></span><br><span class="line"><span class="comment">#         u = ulist[i]</span></span><br><span class="line"><span class="comment">#         print("&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;".format(u[0], u[1], u[2]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(ulist, num)</span>:</span></span><br><span class="line">    tplt = <span class="string">"&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span></span><br><span class="line">    print(tplt.format(<span class="string">"排名"</span>, <span class="string">"学校名称"</span>, <span class="string">"总分"</span>, chr(<span class="number">12288</span>)))</span><br><span class="line">    <span class="comment"># 使用中文空格填充</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="comment"># print(u)</span></span><br><span class="line">        print(tplt.format(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], chr(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">'http://zuihaodaxue.com/zuihaodaxuepaiming2019.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/10/31/python-web-spider/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://aaronlinv.github.io/2019/10/23/hello-world/</link>
      <guid>https://aaronlinv.github.io/2019/10/23/hello-world/</guid>
      <pubDate>Wed, 23 Oct 2019 12:23:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;过往&quot;&gt;&lt;a href=&quot;#过往&quot; class=&quot;headerlink&quot; title=&quot;过往&quot;&gt;&lt;/a&gt;过往&lt;/h2&gt;&lt;p&gt;前一段时间发生了很多事，经历了一些变动，让我开始重新审视自己&lt;/p&gt;
&lt;p&gt;大一大二似乎都在随波逐流，做着那些“优秀”的人都在做的事&lt;/p&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="过往"><a href="#过往" class="headerlink" title="过往"></a>过往</h2><p>前一段时间发生了很多事，经历了一些变动，让我开始重新审视自己</p><p>大一大二似乎都在随波逐流，做着那些“优秀”的人都在做的事</p><p>到头来不过只是在重复地做着某些领域最简单的事</p><h2 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h2><p>走出舒适圈，和不同的人交流，了解不同的观点</p><p>一点一点地积累，用博客改变自己，也用博客记录自己的改变</p><p>希望自己能坚持下去，不管是写博客，还是其他喜欢的事</p><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><blockquote><p>写博客是一种“写作式学习”</p><p>只要你坚持写下去几年，写Blog给你带来的收益超乎想象，这是积累的力量。</p><p>引用自 <a href="http://www.read.org.cn/html/2005-xie-bo-ke-shi-yi-zhong-xie-zuo-shi-xue-xi.html" target="_blank" rel="noopener">写博客是一种“写作式学习”</a></p></blockquote><p>搭这个博客的初心就是激励自己，多把时间花在有意义的事情上，深入地学习一些东西</p><p>用的是Hexo + Github Pages，相对那些即开即用的博客，我更享受折腾带来的乐趣</p>]]></content:encoded>
      
      <comments>https://aaronlinv.github.io/2019/10/23/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
