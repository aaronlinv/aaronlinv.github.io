<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>重拾 iptables | Aaron Lin</title>
<meta name=keywords content><meta name=description content='iptables 是一个常看常忘的命令，本文试图从应用的角度理解它
iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发
一些常用的场景
1. 禁止 ip 访问后端 IP
在 192.168.64.6 上增加规则：
# -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量
# -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP
# -d 192.168.64.6: 指定目标 IP 地址，即后端 IP
# -j DROP: 表示丢弃匹配的流量
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP

# -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT

# -p 指定协议类型为 TCP
# --dport 指定目标端口
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT

# 看当前的 iptables 规则
# -L "list"，列出当前的规则
# -n "numeric"，即使用数字 IP 地址和端口号而不是主机名和服务名
# -v "verbose"，显示详细信息
iptables -L -n -v
# 列出带编号的规则
iptables -L --line-numbers
# 删除 INPUT 链中的第 1 条规则
# 注意！删除成功后序号会改变，需要重新查询序号
iptables -D INPUT 1
# 清除 INPUT 链所有规则
iptables -F INPUT  

# 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则
# 等同于 iptables -F -t filter
iptables -F
2. 端口转发
默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 net.ipv4.ip_forward'><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-iptables/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-iptables/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-iptables/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="重拾 iptables"><meta property="og:description" content='iptables 是一个常看常忘的命令，本文试图从应用的角度理解它
iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发
一些常用的场景 1. 禁止 ip 访问后端 IP 在 192.168.64.6 上增加规则：
# -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量 # -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP # -d 192.168.64.6: 指定目标 IP 地址，即后端 IP # -j DROP: 表示丢弃匹配的流量 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP # -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT # -p 指定协议类型为 TCP # --dport 指定目标端口 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT # 看当前的 iptables 规则 # -L "list"，列出当前的规则 # -n "numeric"，即使用数字 IP 地址和端口号而不是主机名和服务名 # -v "verbose"，显示详细信息 iptables -L -n -v # 列出带编号的规则 iptables -L --line-numbers # 删除 INPUT 链中的第 1 条规则 # 注意！删除成功后序号会改变，需要重新查询序号 iptables -D INPUT 1 # 清除 INPUT 链所有规则 iptables -F INPUT # 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则 # 等同于 iptables -F -t filter iptables -F 2. 端口转发 默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 net.ipv4.ip_forward'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-27T08:31:33+08:00"><meta property="article:modified_time" content="2024-12-27T08:31:33+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="重拾 iptables"><meta name=twitter:description content='iptables 是一个常看常忘的命令，本文试图从应用的角度理解它
iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发
一些常用的场景
1. 禁止 ip 访问后端 IP
在 192.168.64.6 上增加规则：
# -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量
# -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP
# -d 192.168.64.6: 指定目标 IP 地址，即后端 IP
# -j DROP: 表示丢弃匹配的流量
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP

# -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT

# -p 指定协议类型为 TCP
# --dport 指定目标端口
iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT

# 看当前的 iptables 规则
# -L "list"，列出当前的规则
# -n "numeric"，即使用数字 IP 地址和端口号而不是主机名和服务名
# -v "verbose"，显示详细信息
iptables -L -n -v
# 列出带编号的规则
iptables -L --line-numbers
# 删除 INPUT 链中的第 1 条规则
# 注意！删除成功后序号会改变，需要重新查询序号
iptables -D INPUT 1
# 清除 INPUT 链所有规则
iptables -F INPUT  

# 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则
# 等同于 iptables -F -t filter
iptables -F
2. 端口转发
默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 net.ipv4.ip_forward'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"重拾 iptables","item":"https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-iptables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"重拾 iptables","name":"重拾 iptables","description":"iptables 是一个常看常忘的命令，本文试图从应用的角度理解它\niptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发\n一些常用的场景 1. 禁止 ip 访问后端 IP 在 192.168.64.6 上增加规则：\n# -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量 # -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP # -d 192.168.64.6: 指定目标 IP 地址，即后端 IP # -j DROP: 表示丢弃匹配的流量 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP # -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT # -p 指定协议类型为 TCP # --dport 指定目标端口 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT # 看当前的 iptables 规则 # -L \u0026#34;list\u0026#34;，列出当前的规则 # -n \u0026#34;numeric\u0026#34;，即使用数字 IP 地址和端口号而不是主机名和服务名 # -v \u0026#34;verbose\u0026#34;，显示详细信息 iptables -L -n -v # 列出带编号的规则 iptables -L --line-numbers # 删除 INPUT 链中的第 1 条规则 # 注意！删除成功后序号会改变，需要重新查询序号 iptables -D INPUT 1 # 清除 INPUT 链所有规则 iptables -F INPUT # 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则 # 等同于 iptables -F -t filter iptables -F 2. 端口转发 默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 net.ipv4.ip_forward\n","keywords":[],"articleBody":"iptables 是一个常看常忘的命令，本文试图从应用的角度理解它\niptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发\n一些常用的场景 1. 禁止 ip 访问后端 IP 在 192.168.64.6 上增加规则：\n# -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量 # -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP # -d 192.168.64.6: 指定目标 IP 地址，即后端 IP # -j DROP: 表示丢弃匹配的流量 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP # -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT # -p 指定协议类型为 TCP # --dport 指定目标端口 iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport 80 -j REJECT # 看当前的 iptables 规则 # -L \"list\"，列出当前的规则 # -n \"numeric\"，即使用数字 IP 地址和端口号而不是主机名和服务名 # -v \"verbose\"，显示详细信息 iptables -L -n -v # 列出带编号的规则 iptables -L --line-numbers # 删除 INPUT 链中的第 1 条规则 # 注意！删除成功后序号会改变，需要重新查询序号 iptables -D INPUT 1 # 清除 INPUT 链所有规则 iptables -F INPUT # 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则 # 等同于 iptables -F -t filter iptables -F 2. 端口转发 默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 net.ipv4.ip_forward\n需要注意，上面的命令仅临时启用 IPv4 数据包。需要永久启用转发，需要修改 /etc/sysctl.conf 文件。 在该文件中添加或修改 net.ipv4.ip_forward=1 一行。 然后运行 sudo sysctl -p 应用更改\ncat /proc/sys/net/ipv4/ip_forward sudo sysctl -w net.ipv4.ip_forward=1 将本机的 8080 端口转发到 80 端口 iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 80 # curl 127.0.0.1:8080 # curl 192.168.64.6:8080 # curl: (7) Failed to connect to 127.0.0.1 port 8080 after 1 ms: Couldn't connect to server # 非本机访问 ok # curl 192.168.64.6:8080 PREROUTING 链修改的是从外部连接过来时的转发，所以上面的方式本机 curl 127.0.0.1:8080 会提示：Couldn’t connect to server\n如果本机连接到本机的转发，需要修改为 OUTPUT 链：\n# 清除已有 nat 规则 # iptables -F -t nat iptables -t nat -A OUTPUT -p tcp --dport 8080 -j REDIRECT --to-port 80 # 非本机访问失败： # curl 192.168.64.6:8080 # curl: (7) Failed to connect to 192.168.64.6 port 8080 after 1 ms: Connection refused # 本机访问 ok # curl 192.168.64.6:8080 # curl 127.0.0.1:8080 转发内网 IP 在 192.168.64.6 上增加规则：\n# 清除已有 nat 规则 # iptables -F -t nat iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.64.7:80 iptables -t nat -A POSTROUTING -p tcp -d 192.168.64.7 --dport 80 -j SNAT --to-source 192.168.64.6 转发公网的 IP 和端口 # 清除已有 nat 规则 # iptables -F -t nat iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 106.55.113.110:80 # --to-source 使用公网地址会无法访问 iptables -t nat -A POSTROUTING -p tcp -d 106.55.113.110 --dport 80 -j SNAT --to-source 192.168.64.6 需要注意的是 SNAT 的 --to-source 需要设置为连接公网的网卡对应的内网 IP（通过 ip ad 查询），如果设置为公网 IP，数据包可能被丢弃\n3. 内部 IP 共享上网 NAT 目的是为了解决 IPv4 公网 IP 不足的问题：\n当私有网络中的设备发送数据包到公共网络时，NAT 设备会将数据包的 源IP地址（内网 IP）从私有地址转换为 公共IP地址，并维护一个转换表，记录所有的地址转换关系 NAT 设备接收数据包时，会根据转换表将数据包的目标 IP 地址转换为内部设备的内网 IP，并将其发送到内部网络 包含的操作：\nSNAT (Source Network Address Translation)：修改数据包的源 IP 地址 DNAT (Destination Network Address Translation)：修改数据包的目的 IP 地址 MASQUERADE：和 SNAT 类似，但是对每个包都会动态获取指定输出接口（网卡）的 IP，因此如果接口的 IP 地址发送了变化，MASQUERADE 规则不受影响 举个 NAT 的例子：村民张三需要写信给河南的李四，写完后他在信封上写上，寄件人地址：勤劳村 8 号，收件人地址：河南省孟津县陈倪路 20 号。然后就把这封信投递到村里的邮局。邮递员拿到信件一看，这信要是寄出去，收件人通过 勤劳村 8 号 这个回信肯定没办法寄回村里，于是就将信封上寄件人地址修改为：四川省兴文县勤劳村邮局，再将信件发出，同时在本子上记录发往河南的这封信对应的是 勤劳村 8 号。 李四收到信件就按照信件上的信息编写信封，寄件人地址：河南省孟津县陈倪路 20 号，收件人地址：四川省兴文县勤劳村邮局，这样这封回信就寄到了村里的邮局，邮递员一看到这封信是来自河南，对着笔记本就知道这封信是送往 勤劳村 8 号，于是将收件人地址修改为了 勤劳村 8 号，这样邮递员派件的时候就可以把回信送到张三家\n详细 NAT 原理可以参考这篇文章：[译] NAT 穿透是如何工作的：技术原理及企业级实践\n实践 我是按着 使用iptables将ubuntu配置为路由器 进行操作，最后的效果：客户端可以通过连接一台配置了 SNAT 或者 MASQUERADE 的机器访问公网\n注意：给网关和客户端指定 vmnet15 后还需要手动配置一下 虚拟网络：\n网关 IP 配置：\nnetwork: version: 2 ethernets: ens33: # WAN 接口 dhcp4: true ens34: # LAN 接口 dhcp4: no addresses: [10.1.2.1/24] 客户端配置：\nnetwork: version: 2 ethernets: ens33: dhcp4: no addresses: [10.1.2.2/24] gateway4: 10.1.2.1 # 网关 nameservers: addresses: [114.114.114.114] 在网关机器上进行 iptables 的配置：\nsudo sysctl -w net.ipv4.ip_forward=1 # 将 10.1.2.0/24 网络中的所有主机伪装成 192.168.184.131 这个公网IP地址，以便它们可以访问外部网络 # -o ens33: 匹配通过 ens33 接口出站的数据包 iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o ens33 -j SNAT --to-source 192.168.184.131 这条命令允许内部网络的设备通过网关访问互联网。内部设备的 IP 地址在数据包离开网关时被替换为网关的公共 IP 地址，从而使外部网络只看到网关的 IP 地址，除了 SNAT 还可以使用 MASQUERADE，二者效果类似\niptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j MASQUERADE 理解 iptables 表:\nfilter 表: 这是默认表，用于过滤数据包，决定是否允许数据包通过 nat 表: 用于网络地址转换 (Network Address Translation, NAT)。它主要用于修改数据包的源地址或目标地址，例如将私有 IP 地址转换为公有 IP 地址 mangle 表: 用于修改数据包的头部信息，例如修改 TTL (Time To Live) 值、TOS (Type of Service) 值等 raw 表: 用于在连接跟踪之前处理数据包，主要用于控制连接跟踪是否启用 security 表: (较新版本) 用于安全策略的实施，例如 SELinux 链：\nPREROUTING INPUT FORWARD OUTPUT POSTROUTING 数据包的不同场景：\n收到的、目的是本机的包：PRETOUTING -\u003e INPUT 收到的、目的是其他主机的包：PRETOUTING -\u003e FORWARD -\u003e POSTROUTING 本地产生的包：OUTPUT -\u003e POSTROUTING 图片来自：从零开始认识 iptables\n表包含若干个链：\nfilter 表包含三个链：INPUT, FORWARD, OUTPUT nat 表包含三个链：PREROUTING, POSTROUTING, OUTPUT mangle 表五个链都包含 raw 表包含两个链：PREROUTING, OUTPUT 看到这些排列组合，可能已经凌乱了，可以看下面的这张图，conntrack 理解为 raw 表，来自：Netfilter Kernel (Packet) Traversal\nNetfilter 内核数据包遍历就像保卫萝卜（塔防游戏）一样，数据包就像游戏中的怪物，会按照特定的路径移动，链就像在特定位置安置的炮塔，当数据包经过某个链时，链就会对数据包进行一些操作，链中包含若干条规则\n既然已经有了链，可以在数据包的不同阶段执行特定操作，为什么还需要表呢？原因是不同规则的执行顺序可能会影响结果。比如，有两条规则：\n对数据包执行 SNAT 对数据包的源 IP 进行过滤 如果先执行 SNAT，过滤操作会基于 SNAT 修改后的 IP 和端口进行匹配。但如果先执行过滤，数据包可能在 SNAT 应用之前就被过滤掉了。每个表的操作结果都会影响后续表的处理，所以 表的作用是将规则按照功能进行分类，避免执行顺序导致规则失效。表的处理顺序：raw -\u003e mangle -\u003e nat -\u003e filter\n注意：相同表中相同链中如果多个规则匹配同一个数据包，则只有第一个匹配的规则会被执行\n需要注意的是，在使用 iptables 命令时，如果没有指定表，默认表是 filter（最后处理的那个表）\n# 手动指定 -t 为 nat 表 iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 80 持久化 iptables 规则存储在内存中，系统重启后规则会丢失，可以安装 iptables-persistent 来持久化规则，规则保存在 /etc/iptables/rules.v4\nsudo apt update sudo apt install iptables-persistent 配置好 iptables 规则后，需要手动运行以下命令持久化规则：\nsudo netfilter-persistent save 误改规则，通过该命令将规则恢复到持久化存储的状态：\nsudo netfilter-persistent reload 参考资料 iptables - wiki iptables的四表五链与NAT工作原理 iptables做TCP/UDP端口转发【转】 通过iptables实现端口转发和内网共享上网 iptables error: unknown option –dport How iptables tables and chains are traversed [译] NAT - 网络地址转换（2016） [译] 深入理解 iptables 和 netfilter 架构 VMware实现iptables NAT及端口映射\n","wordCount":"727","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-12-27T08:31:33+08:00","dateModified":"2024-12-27T08:31:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-iptables/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">重拾 iptables</h1><div class=post-meta><span title='2024-12-27 08:31:33 +0800 +0800'>December 27, 2024</span></div></header><div class=post-content><p>iptables 是一个常看常忘的命令，本文试图从应用的角度理解它</p><p>iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发</p><h2 id=一些常用的场景>一些常用的场景<a hidden class=anchor aria-hidden=true href=#一些常用的场景>#</a></h2><h3 id=1-禁止-ip-访问后端-ip>1. 禁止 ip 访问后端 IP<a hidden class=anchor aria-hidden=true href=#1-禁止-ip-访问后端-ip>#</a></h3><p>在 <code>192.168.64.6</code> 上增加规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># -A INPUT: 将规则添加到 INPUT 链，表示处理进入的流量</span>
</span></span><span class=line><span class=cl><span class=c1># -s 192.168.64.7: 指定源 IP 地址，即要阻止的 IP</span>
</span></span><span class=line><span class=cl><span class=c1># -d 192.168.64.6: 指定目标 IP 地址，即后端 IP</span>
</span></span><span class=line><span class=cl><span class=c1># -j DROP: 表示丢弃匹配的流量</span>
</span></span><span class=line><span class=cl>iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j DROP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># -j REJECT: 丢弃流量的同时向源 IP 返回一个拒绝消息。请求方直接提示：Connection refused</span>
</span></span><span class=line><span class=cl>iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># -p 指定协议类型为 TCP</span>
</span></span><span class=line><span class=cl><span class=c1># --dport 指定目标端口</span>
</span></span><span class=line><span class=cl>iptables -A INPUT -s 192.168.64.7 -d 192.168.64.6 -p tcp --dport <span class=m>80</span> -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 看当前的 iptables 规则</span>
</span></span><span class=line><span class=cl><span class=c1># -L &#34;list&#34;，列出当前的规则</span>
</span></span><span class=line><span class=cl><span class=c1># -n &#34;numeric&#34;，即使用数字 IP 地址和端口号而不是主机名和服务名</span>
</span></span><span class=line><span class=cl><span class=c1># -v &#34;verbose&#34;，显示详细信息</span>
</span></span><span class=line><span class=cl>iptables -L -n -v
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 列出带编号的规则</span>
</span></span><span class=line><span class=cl>iptables -L --line-numbers
</span></span><span class=line><span class=cl><span class=c1># 删除 INPUT 链中的第 1 条规则</span>
</span></span><span class=line><span class=cl><span class=c1># 注意！删除成功后序号会改变，需要重新查询序号</span>
</span></span><span class=line><span class=cl>iptables -D INPUT <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># 清除 INPUT 链所有规则</span>
</span></span><span class=line><span class=cl>iptables -F INPUT  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 清除当前活跃的表（未指定默认是 filter 表）的所有 iptables 规则</span>
</span></span><span class=line><span class=cl><span class=c1># 等同于 iptables -F -t filter</span>
</span></span><span class=line><span class=cl>iptables -F
</span></span></code></pre></div><h3 id=2-端口转发>2. 端口转发<a hidden class=anchor aria-hidden=true href=#2-端口转发>#</a></h3><p>默认情况下，Linux 系统不会转发目的 IP 地址不是本地网络的 IPv4 数据包。这是出于安全考虑，防止系统意外成为恶意流量的转发表。要启用 IPv4 数据包转发功能，需要修改内核参数 <code>net.ipv4.ip_forward</code></p><p>需要注意，上面的命令仅临时启用 IPv4 数据包。需要永久启用转发，需要修改 <code>/etc/sysctl.conf</code> 文件。 在该文件中添加或修改 <code>net.ipv4.ip_forward=1</code> 一行。 然后运行 <code>sudo sysctl -p</code> 应用更改</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat /proc/sys/net/ipv4/ip_forward
</span></span><span class=line><span class=cl>sudo sysctl -w net.ipv4.ip_forward<span class=o>=</span><span class=m>1</span>
</span></span></code></pre></div><h4 id=将本机的-8080-端口转发到-80-端口>将本机的 8080 端口转发到 80 端口<a hidden class=anchor aria-hidden=true href=#将本机的-8080-端口转发到-80-端口>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>iptables -t nat -A PREROUTING -p tcp --dport <span class=m>8080</span> -j REDIRECT --to-port <span class=m>80</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># curl 127.0.0.1:8080</span>
</span></span><span class=line><span class=cl><span class=c1># curl 192.168.64.6:8080</span>
</span></span><span class=line><span class=cl><span class=c1># curl: (7) Failed to connect to 127.0.0.1 port 8080 after 1 ms: Couldn&#39;t connect to server</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 非本机访问 ok</span>
</span></span><span class=line><span class=cl><span class=c1># curl 192.168.64.6:8080</span>
</span></span></code></pre></div><p>PREROUTING 链修改的是从外部连接过来时的转发，所以上面的方式本机 <code>curl 127.0.0.1:8080</code> 会提示：Couldn&rsquo;t connect to server</p><p>如果本机连接到本机的转发，需要修改为 OUTPUT 链：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 清除已有 nat 规则</span>
</span></span><span class=line><span class=cl><span class=c1># iptables -F -t nat</span>
</span></span><span class=line><span class=cl>iptables -t nat -A OUTPUT -p tcp --dport <span class=m>8080</span> -j REDIRECT --to-port <span class=m>80</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 非本机访问失败：</span>
</span></span><span class=line><span class=cl><span class=c1># curl 192.168.64.6:8080</span>
</span></span><span class=line><span class=cl><span class=c1># curl: (7) Failed to connect to 192.168.64.6 port 8080 after 1 ms: Connection refused</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 本机访问 ok</span>
</span></span><span class=line><span class=cl><span class=c1># curl 192.168.64.6:8080</span>
</span></span><span class=line><span class=cl><span class=c1># curl 127.0.0.1:8080</span>
</span></span></code></pre></div><h4 id=转发内网-ip>转发内网 IP<a hidden class=anchor aria-hidden=true href=#转发内网-ip>#</a></h4><p>在 <code>192.168.64.6</code> 上增加规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 清除已有 nat 规则</span>
</span></span><span class=line><span class=cl><span class=c1># iptables -F -t nat</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>iptables -t nat -A PREROUTING -p tcp --dport <span class=m>8080</span> -j DNAT --to-destination 192.168.64.7:80
</span></span><span class=line><span class=cl>iptables -t nat -A POSTROUTING -p tcp -d 192.168.64.7 --dport <span class=m>80</span> -j SNAT --to-source 192.168.64.6
</span></span></code></pre></div><h4 id=转发公网的-ip-和端口>转发公网的 IP 和端口<a hidden class=anchor aria-hidden=true href=#转发公网的-ip-和端口>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 清除已有 nat 规则</span>
</span></span><span class=line><span class=cl><span class=c1># iptables -F -t nat</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>iptables -t nat -A PREROUTING -p tcp --dport <span class=m>8080</span> -j DNAT --to-destination 106.55.113.110:80
</span></span><span class=line><span class=cl><span class=c1># --to-source 使用公网地址会无法访问</span>
</span></span><span class=line><span class=cl>iptables -t nat -A POSTROUTING -p tcp -d 106.55.113.110 --dport <span class=m>80</span> -j SNAT --to-source 192.168.64.6
</span></span></code></pre></div><p>需要注意的是 <code>SNAT</code> 的 <code>--to-source</code> 需要设置为连接公网的网卡对应的内网 IP（通过 ip ad 查询），如果设置为公网 IP，数据包可能被丢弃</p><h3 id=3-内部-ip-共享上网>3. 内部 IP 共享上网<a hidden class=anchor aria-hidden=true href=#3-内部-ip-共享上网>#</a></h3><p>NAT 目的是为了解决 IPv4 公网 IP 不足的问题：</p><ul><li>当私有网络中的设备发送数据包到公共网络时，NAT 设备会将数据包的 源IP地址（内网 IP）从私有地址转换为 公共IP地址，并维护一个转换表，记录所有的地址转换关系</li><li>NAT 设备接收数据包时，会根据转换表将数据包的目标 IP 地址转换为内部设备的内网 IP，并将其发送到内部网络</li></ul><p>包含的操作：</p><ul><li>SNAT (Source Network Address Translation)：修改数据包的源 IP 地址</li><li>DNAT (Destination Network Address Translation)：修改数据包的目的 IP 地址</li><li>MASQUERADE：和 SNAT 类似，但是对每个包都会动态获取指定输出接口（网卡）的 IP，因此如果接口的 IP 地址发送了变化，MASQUERADE 规则不受影响</li></ul><p>举个 NAT 的例子：村民张三需要写信给河南的李四，写完后他在信封上写上，寄件人地址：<code>勤劳村 8 号</code>，收件人地址：<code>河南省孟津县陈倪路 20 号</code>。然后就把这封信投递到村里的邮局。邮递员拿到信件一看，这信要是寄出去，收件人通过 <code>勤劳村 8 号</code> 这个回信肯定没办法寄回村里，于是就将信封上寄件人地址修改为：<code>四川省兴文县勤劳村邮局</code>，再将信件发出，同时在本子上记录发往河南的这封信对应的是 <code>勤劳村 8 号</code>。 李四收到信件就按照信件上的信息编写信封，寄件人地址：<code>河南省孟津县陈倪路 20 号</code>，收件人地址：<code>四川省兴文县勤劳村邮局</code>，这样这封回信就寄到了村里的邮局，邮递员一看到这封信是来自河南，对着笔记本就知道这封信是送往 <code>勤劳村 8 号</code>，于是将收件人地址修改为了 <code>勤劳村 8 号</code>，这样邮递员派件的时候就可以把回信送到张三家</p><p>详细 NAT 原理可以参考这篇文章：<a href=https://arthurchiao.art/blog/how-nat-traversal-works-zh/>[译] NAT 穿透是如何工作的：技术原理及企业级实践</a></p><h4 id=实践>实践<a hidden class=anchor aria-hidden=true href=#实践>#</a></h4><p>我是按着 <a href=https://zu1k.com/posts/linux/ubuntu-iptables-nat/>使用iptables将ubuntu配置为路由器</a> 进行操作，最后的效果：客户端可以通过连接一台配置了 SNAT 或者 MASQUERADE 的机器访问公网</p><p><img loading=lazy src=../%E9%87%8D%E6%8B%BEiptables/1.png></p><p>注意：给网关和客户端指定 <code>vmnet15</code> 后还需要手动配置一下 <code>虚拟网络</code>：</p><p><img loading=lazy src=../%E9%87%8D%E6%8B%BEiptables/2.png></p><p>网关 IP 配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>network</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ethernets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ens33</span><span class=p>:</span><span class=w> </span><span class=c># WAN 接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dhcp4</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ens34</span><span class=p>:</span><span class=w> </span><span class=c># LAN 接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dhcp4</span><span class=p>:</span><span class=w> </span><span class=kc>no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>addresses: [10.1.2.1/24]</span><span class=w>
</span></span></span></code></pre></div><p>客户端配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>network</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ethernets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ens33</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dhcp4</span><span class=p>:</span><span class=w> </span><span class=kc>no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>addresses</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=m>10.1.2.2</span><span class=l>/24]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>gateway4</span><span class=p>:</span><span class=w> </span><span class=m>10.1.2.1</span><span class=w> </span><span class=c># 网关</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>nameservers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>addresses: [114.114.114.114]</span><span class=w>
</span></span></span></code></pre></div><p>在网关机器上进行 iptables 的配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo sysctl -w net.ipv4.ip_forward<span class=o>=</span><span class=m>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 将 10.1.2.0/24 网络中的所有主机伪装成 192.168.184.131 这个公网IP地址，以便它们可以访问外部网络</span>
</span></span><span class=line><span class=cl><span class=c1># -o ens33: 匹配通过 ens33 接口出站的数据包</span>
</span></span><span class=line><span class=cl>iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o ens33 -j SNAT --to-source 192.168.184.131
</span></span></code></pre></div><p>这条命令允许内部网络的设备通过网关访问互联网。内部设备的 IP 地址在数据包离开网关时被替换为网关的公共 IP 地址，从而使外部网络只看到网关的 IP 地址，除了 SNAT 还可以使用 MASQUERADE，二者效果类似</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j MASQUERADE
</span></span></code></pre></div><h2 id=理解-iptables>理解 iptables<a hidden class=anchor aria-hidden=true href=#理解-iptables>#</a></h2><p>表:</p><ol><li>filter 表: 这是默认表，用于过滤数据包，决定是否允许数据包通过</li><li>nat 表: 用于网络地址转换 (Network Address Translation, NAT)。它主要用于修改数据包的源地址或目标地址，例如将私有 IP 地址转换为公有 IP 地址</li><li>mangle 表: 用于修改数据包的头部信息，例如修改 TTL (Time To Live) 值、TOS (Type of Service) 值等</li><li>raw 表: 用于在连接跟踪之前处理数据包，主要用于控制连接跟踪是否启用</li><li>security 表: (较新版本) 用于安全策略的实施，例如 SELinux</li></ol><p>链：</p><ol><li>PREROUTING</li><li>INPUT</li><li>FORWARD</li><li>OUTPUT</li><li>POSTROUTING</li></ol><p>数据包的不同场景：</p><ul><li>收到的、目的是本机的包：PRETOUTING -> INPUT</li><li>收到的、目的是其他主机的包：PRETOUTING -> FORWARD -> POSTROUTING</li><li>本地产生的包：OUTPUT -> POSTROUTING</li></ul><p><a href=../%E9%87%8D%E6%8B%BEiptables/3.png></a></p><p>图片来自：<a href=https://morven.life/posts/iptables-wiki/>从零开始认识 iptables</a></p><p>表包含若干个链：</p><ol><li>filter 表包含三个链：INPUT, FORWARD, OUTPUT</li><li>nat 表包含三个链：PREROUTING, POSTROUTING, OUTPUT</li><li>mangle 表五个链都包含</li><li>raw 表包含两个链：PREROUTING, OUTPUT</li></ol><p>看到这些排列组合，可能已经凌乱了，可以看下面的这张图，<code>conntrack</code> 理解为 <code>raw</code> 表，来自：<a href=http://linux-ip.net/pages/diagrams.html#netfilter-kernel-packet-traversal>Netfilter Kernel (Packet) Traversal</a></p><p><a href=../%E9%87%8D%E6%8B%BEiptables/4.png></a></p><p>Netfilter 内核数据包遍历就像保卫萝卜（塔防游戏）一样，数据包就像游戏中的怪物，会按照特定的路径移动，链就像在特定位置安置的炮塔，<strong>当数据包经过某个链时，链就会对数据包进行一些操作</strong>，链中包含若干条规则</p><p>既然已经有了链，可以在数据包的不同阶段执行特定操作，为什么还需要表呢？原因是不同规则的执行顺序可能会影响结果。比如，有两条规则：</p><ol><li>对数据包执行 SNAT</li><li>对数据包的源 IP 进行过滤</li></ol><p>如果先执行 SNAT，过滤操作会基于 SNAT 修改后的 IP 和端口进行匹配。但如果先执行过滤，数据包可能在 SNAT 应用之前就被过滤掉了。每个表的操作结果都会影响后续表的处理，所以 <strong>表的作用是将规则按照功能进行分类，避免执行顺序导致规则失效</strong>。表的处理顺序：<code>raw -> mangle -> nat -> filter</code></p><p>注意：<strong>相同表中相同链中如果多个规则匹配同一个数据包，则只有第一个匹配的规则会被执行</strong></p><p>需要注意的是，在使用 iptables 命令时，如果没有指定表，默认表是 filter（最后处理的那个表）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 手动指定 -t 为 nat 表</span>
</span></span><span class=line><span class=cl>iptables -t nat -A PREROUTING -p tcp --dport <span class=m>8080</span> -j REDIRECT --to-port <span class=m>80</span>
</span></span></code></pre></div><h2 id=持久化>持久化<a hidden class=anchor aria-hidden=true href=#持久化>#</a></h2><p>iptables 规则存储在内存中，<strong>系统重启后规则会丢失</strong>，可以安装 <code>iptables-persistent</code> 来持久化规则，规则保存在 <code>/etc/iptables/rules.v4</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo apt update
</span></span><span class=line><span class=cl>sudo apt install iptables-persistent
</span></span></code></pre></div><p>配置好 iptables 规则后，需要手动运行以下命令持久化规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo netfilter-persistent save
</span></span></code></pre></div><p>误改规则，通过该命令将规则恢复到持久化存储的状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo netfilter-persistent reload
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://zh.wikipedia.org/wiki/Iptables>iptables - wiki</a>
<a href=https://tinychen.com/20200414-iptables-principle-introduction/>iptables的四表五链与NAT工作原理</a>
<a href=https://www.cnblogs.com/paul8339/p/14688156.html>iptables做TCP/UDP端口转发【转】</a>
<a href=https://xstarcd.github.io/wiki/Linux/iptables_forward_internetshare.html>通过iptables实现端口转发和内网共享上网</a>
<a href=https://serverfault.com/a/563036>iptables error: unknown option &ndash;dport</a>
<a href=https://unix.stackexchange.com/a/189906>How iptables tables and chains are traversed</a>
<a href=https://arthurchiao.art/blog/nat-zh/>[译] NAT - 网络地址转换（2016）</a>
<a href=https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/>[译] 深入理解 iptables 和 netfilter 架构</a>
<a href=https://cloud.tencent.com/developer/article/1718100>VMware实现iptables NAT及端口映射</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-ssh%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/><span class=title>« Prev</span><br><span>重拾 SSH：从基础到安全加固</span>
</a><a class=next href=https://aaronlinv.github.io/posts/mysql-%E6%97%B6%E5%8C%BA%E4%B8%8E-servertimezone/><span class=title>Next »</span><br><span>MySQL 时区与 serverTimezone</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>