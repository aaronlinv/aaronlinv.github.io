<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer | Aaron Lin</title><meta name=keywords content><meta name=description content='上一节：SpringBoot 测试实践 - 2：单元测试与集成测试


编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写
@MockBean
@MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率
@SpringBootTest
@RunWith(SpringRunner.class)
public class MyServiceTest {
    @MockBean
    private ExternalDependency externalDependency;

    @Autowired
    private MyService myService;

    @Test
    public void testSomeMethod() {
        // 定义外部依赖的行为
        Mockito.when(externalDependency.someMethod()).thenReturn("Mocked Result");

        // 调用被测试类的方法
        // 被测方法内部调用了 ExternalDependency 的 someMethod 方法
        String result = myService.someMethod();

        // 验证外部依赖的方法是否被调用
        Mockito.verify(externalDependency).someMethod();

        // 断言结果
        assertEquals("Mocked Result", result);
    }
}
需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null'><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><script defer src=https://cloud.umami.is/script.js data-website-id=2afa0ef0-b9a4-4bc7-b673-b5a2e2da51e3></script><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer"><meta property="og:description" content='上一节：SpringBoot 测试实践 - 2：单元测试与集成测试
编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写
@MockBean @MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率
@SpringBootTest @RunWith(SpringRunner.class) public class MyServiceTest { @MockBean private ExternalDependency externalDependency; @Autowired private MyService myService; @Test public void testSomeMethod() { // 定义外部依赖的行为 Mockito.when(externalDependency.someMethod()).thenReturn("Mocked Result"); // 调用被测试类的方法 // 被测方法内部调用了 ExternalDependency 的 someMethod 方法 String result = myService.someMethod(); // 验证外部依赖的方法是否被调用 Mockito.verify(externalDependency).someMethod(); // 断言结果 assertEquals("Mocked Result", result); } } 需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-24T08:40:33+08:00"><meta property="article:modified_time" content="2023-08-24T08:40:33+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer"><meta name=twitter:description content='上一节：SpringBoot 测试实践 - 2：单元测试与集成测试


编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写
@MockBean
@MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率
@SpringBootTest
@RunWith(SpringRunner.class)
public class MyServiceTest {
    @MockBean
    private ExternalDependency externalDependency;

    @Autowired
    private MyService myService;

    @Test
    public void testSomeMethod() {
        // 定义外部依赖的行为
        Mockito.when(externalDependency.someMethod()).thenReturn("Mocked Result");

        // 调用被测试类的方法
        // 被测方法内部调用了 ExternalDependency 的 someMethod 方法
        String result = myService.someMethod();

        // 验证外部依赖的方法是否被调用
        Mockito.verify(externalDependency).someMethod();

        // 断言结果
        assertEquals("Mocked Result", result);
    }
}
需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer","item":"https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer","name":"SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer","description":"上一节：SpringBoot 测试实践 - 2：单元测试与集成测试\n编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写\n@MockBean @MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率\n@SpringBootTest @RunWith(SpringRunner.class) public class MyServiceTest { @MockBean private ExternalDependency externalDependency; @Autowired private MyService myService; @Test public void testSomeMethod() { // 定义外部依赖的行为 Mockito.when(externalDependency.someMethod()).thenReturn(\u0026#34;Mocked Result\u0026#34;); // 调用被测试类的方法 // 被测方法内部调用了 ExternalDependency 的 someMethod 方法 String result = myService.someMethod(); // 验证外部依赖的方法是否被调用 Mockito.verify(externalDependency).someMethod(); // 断言结果 assertEquals(\u0026#34;Mocked Result\u0026#34;, result); } } 需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null\n","keywords":[],"articleBody":"上一节：SpringBoot 测试实践 - 2：单元测试与集成测试\n编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写\n@MockBean @MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率\n@SpringBootTest @RunWith(SpringRunner.class) public class MyServiceTest { @MockBean private ExternalDependency externalDependency; @Autowired private MyService myService; @Test public void testSomeMethod() { // 定义外部依赖的行为 Mockito.when(externalDependency.someMethod()).thenReturn(\"Mocked Result\"); // 调用被测试类的方法 // 被测方法内部调用了 ExternalDependency 的 someMethod 方法 String result = myService.someMethod(); // 验证外部依赖的方法是否被调用 Mockito.verify(externalDependency).someMethod(); // 断言结果 assertEquals(\"Mocked Result\", result); } } 需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null\n@SpyBean @SpyBean 是 Spring Boot Test 提供的另一个注解，与 @MockBean 作用相似，但是它创建的是部分模拟对象，未指定方法行为时，将执行被模拟对象的真实实现，返回实际方法的执行结果\n常见的情况是：测试依赖外部资源（例如数据库、文件系统等）的方法，我们要在测试中模拟其中一部分方法的行为，同时保留对外部资源的实际访问，那么可以使用 @SpyBean\n@SpringBootTest public class MyServiceTest { @Autowired private MyService myService; @SpyBean private MyRepository myRepository; @Test public void testMyService() { // 使用 doReturn 方法模拟调用 myRepository 的方法，并返回指定的值 Mockito.doReturn(new MyEntity()).when(myRepository).findById(1L); MyResult result = myService.doSomething(1L); Assertions.assertEquals(\"success\", result.getMessage()); } } 这里有一个很重要的点是：@SpyBean 使用 doReturn 而不是 thenReturn，因为 Spy 对象是基于实例创建的，而 thenReturn 方法会调用实例方法并返回模拟结果，这可能会导致实例状态发生变化，从而影响后续的测试步骤。换而言之如果 Spy 对象使用 doReturn 就像这样：Mockito.when(myRepository.findById(1L)).thenReturn(new MyEntity());这段代码我们本意是指定这个 Spy 对象的 findById(1L) 的行为，但是实际上 when 语句中 myRepository.findById(1L) 已经执行了了实际的逻辑，这可能影响整个测试\n简化 Spring Context 提升测试运行速度 SpringBoot 测试实践 - 2：单元测试与集成测试 中提到了单元测试用到的 @MybatisTest 以及集成测试用到的 @SpringBootTest。@SpringBootTest 加载整个 Spring Boot 应用程序的上下文，就像启动了整个 SpringBoot 应用，而 @MybatisTest 只配置了用于测试 MyBatis 的组件，速度就非常快。完整的项目有大量的测试用例，如果每个测试都重新加载 Spring Context 这样就非常耗时，所以要尽量减少 @SpringBootTest\n一般业务代码都会注入外部依赖，如果只在测试方法上使用 @Test 注解，这样运行测试就会抛出空指针异常，需要在类上使用 @ExtendWith(SpringExtension.class) 将 Spring 的测试支持集成到 JUnit 5 中，这样就可以在测试类中获得 Spring 容器的支持，以便进行依赖注入、加载配置文件、使用 Spring Bean 等。仅加上这个注解是不够的，Spring 容器内依然没有我们需要的依赖，我们还需要使用 @ContextConfiguration() 指定要加载的配置文件、配置类或其他资源\n如果说 @SpringBootTest 是初始化好所有项目中用到的 Bean 的话，那 @ExtendWith(SpringExtension.class) 就是按需取用，所以必须保证被测的类用到的所有依赖对象都装配进 Spring 的 IoC 容器里，否则就会抛出这样的异常：\njava.lang.IllegalStateException: Failed to load ApplicationContext Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.test.ConfigurationRepository#0': Unsatisfied dependency expressed through field 'configurationRepository'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.test.ConfigurationRepository' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 我们可以通过 @ContextConfiguration() 来指定配置类或者是类 class。对于被测方法没有使用某些依赖也可以直接用 @MockBean 配置一个Mock 对象，保证测试能正常运行\n@ExtendWith(SpringExtension.class) // 指定加载的两个类：RestTemplate.class 和 ExecutorConfig.class // ExecutorConfig.class 一个自定义的配置类，包含线程池配置 @ContextConfiguration(classes = {RestTemplate.class, ExecutorConfig.class}) class UserServiceTest { // 注入被测对象 @Autowired private UserService userService; // 使用 Mock 代替容器加载依赖 @MockBean private ConfigurationRepository configurationRepository; // 通过 @ContextConfiguration，确保 Spring Context 中会包含 RestTemplate 的相关配置 @Autowired private RestTemplate restTemplate; } 避免 ApplicationContext 复用 默认情况下，运行测试 ApplicationContext 会被复用，以加快测试的运行速度。但是在某些情况下，比如：多个测试类继承同一个抽象类，这可能会导致测试运行失败。可以在抽象类或每个子类中使用 @DirtiesContext，让 Spring 在测试这些类后重置 ApplicationContext\n@DirtiesContext 默认的 classMode 参数为ClassMode.AFTER_CLASS 该模式会在 整个测试类运行完毕后重新加载 Spring 测试上下文。如果希望每次测试方法运行后都重新加载 ApplicationContext 可以使用 @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)\n@DirtiesContext 也可以用于方法级别，在方法运行前或运行后标记为需要重新加载 ApplicationContext\n@SpringBootTest @TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class CacheIntegrationTest { @Autowired private CacheService cacheService; @Test @Order(1) @DirtiesContext(methodMode = DirtiesContext.MethodMode.AFTER_METHOD) public void testCacheEviction() { // 模拟缓存数据，缓存实际为 HashMap cacheService.addToCache(\"key1\", \"value1\"); cacheService.addToCache(\"key2\", \"value2\"); } @Test @Order(2) public void testCacheLookup() { // 从缓存中查找数据 // 因为使用了 @DirtiesContext(methodMode = DirtiesContext.MethodMode.AFTER_METHOD) ApplicationContext 重置，故缓存为空 String value1 = cacheService.getFromCache(\"key1\"); String value2 = cacheService.getFromCache(\"key2\"); } } Testcontainer 为了不影响测试环境的数据，涉及数据层修改的测试，我们可以使用 H2 数据库或者是像上一节：SpringBoot 测试实践 - 2：单元测试与集成测试 这样的，直接使用专门的测试数据库。还有一种方式是用 Docker 启动一个全新的数据库供测试环境使用。而 Testcontainer 的目标就是简化了整个流程：通过代码的方式指定镜像，测试一启动 Testcontainer 将完成初始化工作，自动拉取镜像并创建容器，测试结束后将关闭对应的容器\n一些 CI 广泛地使用 TestContainer 保证测试环境的一致性。但是如果本地运行，Testcontainer依赖本地的 Docker Daemon 或是 Testcontainers Cloud 这样的方案。Windows 本地部署 Docker 也会更麻烦一些\nTestContainer 需要与容器运行时进行交互，第一次要拉取镜像，所以速度上相对慢一些，但是得益于 Docker，TestContainer 几乎可以启动任何服务，无论是数据库、缓存或者是 MQ 等等的，可以保证外部环境的一致性\n教程可以参考官方的实践：\nTestcontainer Java 官方实践\nTestcontainer SpringBootTest 案例\n上一节：SpringBoot 测试实践 - 2：单元测试与集成测试\n参考资料 Context Management and Caching Pitfalls on Testing with Spring Boot A Quick Guide to @DirtiesContext Modern Best Practices for Testing in Java Testing :: Spring Framework Protect REST APIs with Spring Security Reactive and JWT Spring - Testing\n","wordCount":"455","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-08-24T08:40:33+08:00","dateModified":"2023-08-24T08:40:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer</h1><div class=post-meta><span title='2023-08-24 08:40:33 +0800 +0800'>August 24, 2023</span></div></header><div class=post-content><p>上一节：<a href=https://www.cnblogs.com/aaronlinv/p/17645803.html>SpringBoot 测试实践 - 2：单元测试与集成测试</a></p><hr><p>编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 <code>@MockBean</code> 和 <code>@SpyBean</code> 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写</p><h2 id=mockbean>@MockBean<a hidden class=anchor aria-hidden=true href=#mockbean>#</a></h2><p><code>@MockBean</code> 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RunWith</span><span class=p>(</span><span class=n>SpringRunner</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyServiceTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@MockBean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ExternalDependency</span><span class=w> </span><span class=n>externalDependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>MyService</span><span class=w> </span><span class=n>myService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testSomeMethod</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 定义外部依赖的行为</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Mockito</span><span class=p>.</span><span class=na>when</span><span class=p>(</span><span class=n>externalDependency</span><span class=p>.</span><span class=na>someMethod</span><span class=p>()).</span><span class=na>thenReturn</span><span class=p>(</span><span class=s>&#34;Mocked Result&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 调用被测试类的方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 被测方法内部调用了 ExternalDependency 的 someMethod 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myService</span><span class=p>.</span><span class=na>someMethod</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 验证外部依赖的方法是否被调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Mockito</span><span class=p>.</span><span class=na>verify</span><span class=p>(</span><span class=n>externalDependency</span><span class=p>).</span><span class=na>someMethod</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 断言结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>assertEquals</span><span class=p>(</span><span class=s>&#34;Mocked Result&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>需要注意的是：使用了 <code>@MockBean</code>，会创建完全模拟的对象，它<strong>完全替代</strong>了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 <code>null</code></p><h2 id=spybean>@SpyBean<a hidden class=anchor aria-hidden=true href=#spybean>#</a></h2><p><code>@SpyBean</code> 是 Spring Boot Test 提供的另一个注解，与 <code>@MockBean</code> 作用相似，但是它创建的是部分模拟对象，未指定方法行为时，将执行被模拟对象的<strong>真实实现</strong>，返回实际方法的执行结果</p><p>常见的情况是：测试依赖外部资源（例如数据库、文件系统等）的方法，我们要在测试中模拟其中一部分方法的行为，同时保留对外部资源的实际访问，那么可以使用 <code>@SpyBean</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyServiceTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>MyService</span><span class=w> </span><span class=n>myService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@SpyBean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>MyRepository</span><span class=w> </span><span class=n>myRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testMyService</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 使用 doReturn 方法模拟调用 myRepository 的方法，并返回指定的值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Mockito</span><span class=p>.</span><span class=na>doReturn</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>MyEntity</span><span class=p>()).</span><span class=na>when</span><span class=p>(</span><span class=n>myRepository</span><span class=p>).</span><span class=na>findById</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>MyResult</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myService</span><span class=p>.</span><span class=na>doSomething</span><span class=p>(</span><span class=n>1L</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Assertions</span><span class=p>.</span><span class=na>assertEquals</span><span class=p>(</span><span class=s>&#34;success&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>.</span><span class=na>getMessage</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这里有一个很重要的点是：<code>@SpyBean</code> 使用 <code>doReturn</code> 而不是 <code>thenReturn</code>，因为 Spy 对象是基于实例创建的，而 thenReturn 方法会调用实例方法并返回模拟结果，这可能会导致实例状态发生变化，从而影响后续的测试步骤。换而言之如果 Spy 对象使用 <code>doReturn</code> 就像这样：<code>Mockito.when(myRepository.findById(1L)).thenReturn(new MyEntity());</code>这段代码我们本意是指定这个 Spy 对象的 <code>findById(1L)</code> 的行为，但是实际上 when 语句中 <code>myRepository.findById(1L)</code> 已经执行了了实际的逻辑，这可能影响整个测试</p><h2 id=简化-spring-context-提升测试运行速度>简化 Spring Context 提升测试运行速度<a hidden class=anchor aria-hidden=true href=#简化-spring-context-提升测试运行速度>#</a></h2><p><a href=https://www.cnblogs.com/aaronlinv/p/17645803.html>SpringBoot 测试实践 - 2：单元测试与集成测试</a> 中提到了单元测试用到的 <code>@MybatisTest</code> 以及集成测试用到的 <code>@SpringBootTest</code>。<code>@SpringBootTest</code> 加载整个 Spring Boot 应用程序的上下文，就像启动了整个 SpringBoot 应用，而 <code>@MybatisTest</code> 只配置了用于测试 MyBatis 的组件，速度就非常快。完整的项目有大量的测试用例，如果每个测试都重新加载 Spring Context 这样就非常耗时，所以要尽量减少 <code>@SpringBootTest</code></p><p>一般业务代码都会注入外部依赖，如果只在测试方法上使用 <code>@Test</code> 注解，这样运行测试就会抛出空指针异常，需要在类上使用 <code>@ExtendWith(SpringExtension.class)</code> 将 Spring 的测试支持集成到 JUnit 5 中，这样就可以在测试类中获得 Spring 容器的支持，以便进行依赖注入、加载配置文件、使用 Spring Bean 等。仅加上这个注解是不够的，Spring 容器内依然没有我们需要的依赖，我们还需要使用 <code>@ContextConfiguration()</code> 指定要加载的配置文件、配置类或其他资源</p><p>如果说 <code>@SpringBootTest</code> 是初始化好所有项目中用到的 Bean 的话，那 <code>@ExtendWith(SpringExtension.class)</code> 就是按需取用，所以必须保证被测的<strong>类</strong>用到的<strong>所有依赖对象</strong>都装配进 Spring 的 IoC 容器里，否则就会抛出这样的异常：</p><pre tabindex=0><code class=language-log data-lang=log>java.lang.IllegalStateException: Failed to load ApplicationContext

Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: 
Error creating bean with name &#39;com.test.ConfigurationRepository#0&#39;: 
Unsatisfied dependency expressed through field &#39;configurationRepository&#39;; 
nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type &#39;com.test.ConfigurationRepository&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: 
{@org.springframework.beans.factory.annotation.Autowired(required=true)}
</code></pre><p>我们可以通过 <code>@ContextConfiguration()</code> 来指定配置类或者是类 class。对于被测方法没有使用某些依赖也可以直接用 <code>@MockBean</code> 配置一个Mock 对象，保证测试能正常运行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ExtendWith</span><span class=p>(</span><span class=n>SpringExtension</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 指定加载的两个类：RestTemplate.class 和 ExecutorConfig.class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ExecutorConfig.class 一个自定义的配置类，包含线程池配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ContextConfiguration</span><span class=p>(</span><span class=n>classes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=n>RestTemplate</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>ExecutorConfig</span><span class=p>.</span><span class=na>class</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>UserServiceTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注入被测对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 使用 Mock 代替容器加载依赖</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@MockBean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ConfigurationRepository</span><span class=w> </span><span class=n>configurationRepository</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 通过 @ContextConfiguration，确保 Spring Context 中会包含 RestTemplate 的相关配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>RestTemplate</span><span class=w> </span><span class=n>restTemplate</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=避免-applicationcontext-复用>避免 ApplicationContext 复用<a hidden class=anchor aria-hidden=true href=#避免-applicationcontext-复用>#</a></h2><p>默认情况下，运行测试 <code>ApplicationContext</code> 会被复用，以加快测试的运行速度。但是在某些情况下，比如：多个测试类继承同一个抽象类，这可能会导致测试运行失败。可以在抽象类或每个子类中使用 @DirtiesContext，让 Spring 在测试这些类后重置 <code>ApplicationContext</code></p><p><code>@DirtiesContext</code> 默认的 <code>classMode</code> 参数为<code>ClassMode.AFTER_CLASS</code> 该模式会在 整个测试类运行完毕后重新加载 Spring 测试上下文。如果希望每次测试方法运行后都重新加载 <code>ApplicationContext</code> 可以使用 <code>@DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)</code></p><p>@DirtiesContext 也可以用于方法级别，在方法运行前或运行后标记为需要重新加载 <code>ApplicationContext</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@TestMethodOrder</span><span class=p>(</span><span class=n>MethodOrderer</span><span class=p>.</span><span class=na>OrderAnnotation</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CacheIntegrationTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>CacheService</span><span class=w> </span><span class=n>cacheService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Order</span><span class=p>(</span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@DirtiesContext</span><span class=p>(</span><span class=n>methodMode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>DirtiesContext</span><span class=p>.</span><span class=na>MethodMode</span><span class=p>.</span><span class=na>AFTER_METHOD</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testCacheEviction</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 模拟缓存数据，缓存实际为 HashMap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cacheService</span><span class=p>.</span><span class=na>addToCache</span><span class=p>(</span><span class=s>&#34;key1&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;value1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cacheService</span><span class=p>.</span><span class=na>addToCache</span><span class=p>(</span><span class=s>&#34;key2&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;value2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Order</span><span class=p>(</span><span class=n>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testCacheLookup</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 从缓存中查找数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 因为使用了 @DirtiesContext(methodMode = DirtiesContext.MethodMode.AFTER_METHOD) ApplicationContext 重置，故缓存为空</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>value1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cacheService</span><span class=p>.</span><span class=na>getFromCache</span><span class=p>(</span><span class=s>&#34;key1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>value2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cacheService</span><span class=p>.</span><span class=na>getFromCache</span><span class=p>(</span><span class=s>&#34;key2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=testcontainer>Testcontainer<a hidden class=anchor aria-hidden=true href=#testcontainer>#</a></h2><p>为了不影响测试环境的数据，涉及数据层修改的测试，我们可以使用 H2 数据库或者是像上一节：<a href=https://www.cnblogs.com/aaronlinv/p/17645803.html>SpringBoot 测试实践 - 2：单元测试与集成测试</a> 这样的，直接使用专门的测试数据库。还有一种方式是用 Docker 启动一个全新的数据库供测试环境使用。而 <a href=https://testcontainers.com/getting-started/>Testcontainer</a> 的目标就是简化了整个流程：通过代码的方式指定镜像，测试一启动 <code>Testcontainer</code> 将完成初始化工作，自动拉取镜像并创建容器，测试结束后将关闭对应的容器</p><p>一些 CI 广泛地使用 <code>TestContainer</code> 保证测试环境的一致性。但是如果本地运行，<code>Testcontainer</code>依赖本地的 Docker Daemon 或是 <a href=https://testcontainers.com/cloud/>Testcontainers Cloud</a> 这样的方案。Windows 本地部署 Docker 也会更麻烦一些</p><p><code>TestContainer</code> 需要与容器运行时进行交互，第一次要拉取镜像，所以速度上相对慢一些，但是得益于 Docker，<code>TestContainer</code> 几乎可以启动任何服务，无论是数据库、缓存或者是 MQ 等等的，可以保证外部环境的一致性</p><p>教程可以参考官方的实践：</p><p><a href=https://github.com/testcontainers/testcontainers-java/tree/main/examples>Testcontainer Java 官方实践</a></p><p><a href=https://github.com/testcontainers/testcontainers-java/tree/main/examples/spring-boot/src/test/java/com/example>Testcontainer SpringBootTest 案例</a></p><hr><p>上一节：<a href=https://www.cnblogs.com/aaronlinv/p/17645803.html>SpringBoot 测试实践 - 2：单元测试与集成测试</a></p><hr><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://docs.spring.io/spring-framework/reference/testing/integration.html#testing-ctx-management>Context Management and Caching</a>
<a href=https://www.baeldung.com/spring-boot-testing-pitfalls>Pitfalls on Testing with Spring Boot</a>
<a href=https://www.baeldung.com/spring-dirtiescontext>A Quick Guide to @DirtiesContext</a>
<a href=https://phauer.com/2019/modern-best-practices-testing-java/#mock-remote-service>Modern Best Practices for Testing in Java</a>
<a href=https://docs.spring.io/spring-framework/reference/testing.html>Testing :: Spring Framework</a>
<a href=https://medium.com/zero-equals-false/protect-rest-apis-with-spring-security-reactive-and-jwt-7b209a0510f1>Protect REST APIs with Spring Security Reactive and JWT</a>
<a href=https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing>Spring - Testing</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronlinv.github.io/posts/idea-%E4%BB%BB%E6%84%8F-jetbrains-ide%E6%8B%86%E5%88%86%E5%85%88%E5%89%8D-commit/><span class=title>« Prev</span><br><span>IDEA （任意 JetBrains IDE）拆分先前 commit</span>
</a><a class=next href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/><span class=title>Next »</span><br><span>SpringBoot 测试实践 - 2：单元测试与集成测试</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>