<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dockerfile 实践及梳理 | Aaron Lin</title>
<meta name=keywords content><meta name=description content='上一节：Docker 实践及命令梳理
下一节：IDEA 配合 Dockerfile 部署 SpringBoot 工程

Dockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像
文档
Best practices for writing Dockerfiles
Reference
Dockerfile 指令详解
简单上手
使用 Dockerfile 构建SpringBoot 工程的镜像

新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping

@RestController
public class HelloController {
    @GetMapping("hello")
    public String hello() {
        return "hello world!";
    }
}
启动项目，访问 http://localhost:8080/hello 测试

打 jar 包
注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
#打包
mvn package
target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar
在 Linux 新建 ~/springboot 文件夹，并将 jar 包上传到这个文件夹下'><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/dockerfile-%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%A2%B3%E7%90%86/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/dockerfile-%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%A2%B3%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/dockerfile-%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%A2%B3%E7%90%86/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="Dockerfile 实践及梳理"><meta property="og:description" content='上一节：Docker 实践及命令梳理 下一节：IDEA 配合 Dockerfile 部署 SpringBoot 工程
Dockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像
文档 Best practices for writing Dockerfiles
Reference
Dockerfile 指令详解
简单上手 使用 Dockerfile 构建SpringBoot 工程的镜像
新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping @RestController public class HelloController { @GetMapping("hello") public String hello() { return "hello world!"; } } 启动项目，访问 http://localhost:8080/hello 测试
打 jar 包 注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性 <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> #打包 mvn package target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar 在 Linux 新建 ~/springboot 文件夹，并将 jar 包上传到这个文件夹下'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-01T09:15:33+08:00"><meta property="article:modified_time" content="2021-09-01T09:15:33+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Dockerfile 实践及梳理"><meta name=twitter:description content='上一节：Docker 实践及命令梳理
下一节：IDEA 配合 Dockerfile 部署 SpringBoot 工程

Dockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像
文档
Best practices for writing Dockerfiles
Reference
Dockerfile 指令详解
简单上手
使用 Dockerfile 构建SpringBoot 工程的镜像

新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping

@RestController
public class HelloController {
    @GetMapping("hello")
    public String hello() {
        return "hello world!";
    }
}
启动项目，访问 http://localhost:8080/hello 测试

打 jar 包
注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
#打包
mvn package
target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar
在 Linux 新建 ~/springboot 文件夹，并将 jar 包上传到这个文件夹下'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Dockerfile 实践及梳理","item":"https://aaronlinv.github.io/posts/dockerfile-%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%A2%B3%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dockerfile 实践及梳理","name":"Dockerfile 实践及梳理","description":"上一节：Docker 实践及命令梳理 下一节：IDEA 配合 Dockerfile 部署 SpringBoot 工程\nDockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像\n文档 Best practices for writing Dockerfiles\nReference\nDockerfile 指令详解\n简单上手 使用 Dockerfile 构建SpringBoot 工程的镜像\n新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping @RestController public class HelloController { @GetMapping(\u0026#34;hello\u0026#34;) public String hello() { return \u0026#34;hello world!\u0026#34;; } } 启动项目，访问 http://localhost:8080/hello 测试\n打 jar 包 注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; #打包 mvn package target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar 在 Linux 新建 ~/springboot 文件夹，并将 jar 包上传到这个文件夹下\n","keywords":[],"articleBody":"上一节：Docker 实践及命令梳理 下一节：IDEA 配合 Dockerfile 部署 SpringBoot 工程\nDockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像\n文档 Best practices for writing Dockerfiles\nReference\nDockerfile 指令详解\n简单上手 使用 Dockerfile 构建SpringBoot 工程的镜像\n新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping @RestController public class HelloController { @GetMapping(\"hello\") public String hello() { return \"hello world!\"; } } 启动项目，访问 http://localhost:8080/hello 测试\n打 jar 包 注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性 org.springframework.boot spring-boot-maven-plugin #打包 mvn package target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar 在 Linux 新建 ~/springboot 文件夹，并将 jar 包上传到这个文件夹下\n新建 Dockerfile 在这个文件下新建 Dockerfile 文件 # 基于 openjdk:8-jre 这个基础镜像进行构建 FROM openjdk:8-jre # 这里的 demo-0.0.1- SNAPSHOT.jar 要对应上传的 jar 包名称 # 将 本地 jar包 复制到容器内 COPY demo-0.0.1-SNAPSHOT.jar app.jar # 开放 8080 端口 EXPOSE 8080 # 运行命令、参数 ENTRYPOINT [\"java\",\"-jar\"] CMD [\"app.jar\"] 保存文件，退出编辑器\n编译 Docker 镜像 # build 是构建 Docker 镜像的命令 # -t 指定镜像的 tag # 名称：demo 版本：v1.0 # 最后的 . 表示 build context 目录为当前目录，目的是为了找到 所需的 jar 包 docker build -t demo:v1.0 . 启动容器 # 前台启动刚构建的 SpringBoot 容器 # -p 映射容器8080端口 到宿主机的 8080 上 docker run -p 8080:8080 demo:v1.0 测试 访问 Linux 的8080 端口，注意替换为自己的 Linux 的地址，并开放 8080 端口 http://192.168.43.161:8080/hello\nbuild context Dockerfile 默认会使用它自己所在的目录作为 context，通过 docker 执行构建命令后，Docker daemon 会拷贝 context 目录下的所有文件，所以 context 目录不要放置项目无关的文件，或者可以使用 .dockerignore 定义忽略文件，也可以指定 context 路径\n# build 命令通过 Dockerfile 构建镜像 # 指定 ~/dockerfile 为 build context docker build ~/dockerfile # 不需要添加文件到 context 可以使用 - docker build - 可以通过 stdin 的方式，避免生产 Dockerfile 文件，直接 build 镜像\ndocker build -t myimage:latest -\u003c","wordCount":"502","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-09-01T09:15:33+08:00","dateModified":"2021-09-01T09:15:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/dockerfile-%E5%AE%9E%E8%B7%B5%E5%8F%8A%E6%A2%B3%E7%90%86/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Dockerfile 实践及梳理</h1><div class=post-meta><span title='2021-09-01 09:15:33 +0800 +0800'>September 1, 2021</span></div></header><div class=post-content><p>上一节：<a href=https://www.cnblogs.com/aaronlinv/p/15130730.html>Docker 实践及命令梳理</a>
下一节：<a href=https://www.cnblogs.com/aaronlinv/p/15228488.html>IDEA 配合 Dockerfile 部署 SpringBoot 工程</a></p><hr><p>Dockerfile 是一个文本文件，我们可以通过组合一条条的指令 (Instruction)，来构建满足我们需求的 Docker 镜像</p><h2 id=文档>文档<a hidden class=anchor aria-hidden=true href=#文档>#</a></h2><p><a href=https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>Best practices for writing Dockerfiles</a></p><p><a href=https://docs.docker.com/engine/reference/builder/>Reference</a></p><p><a href=https://yeasy.gitbook.io/docker_practice/image/dockerfile>Dockerfile 指令详解</a></p><h2 id=简单上手>简单上手<a hidden class=anchor aria-hidden=true href=#简单上手>#</a></h2><p>使用 Dockerfile 构建SpringBoot 工程的镜像</p><ol><li>新建 SpringBoot 项目，默认的端口是 8080 ，新建 Controller 和 Mapping</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>HelloController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GetMapping</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>hello</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;hello world!&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>启动项目，访问 http://localhost:8080/hello 测试</p><ol start=2><li>打 jar 包
注意，需要在 pom 中添加 spring-boot-maven-plugin 插件，否则运行 jar 包时会提示：没有主清单属性</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl>    <span class=nt>&lt;build&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;plugins&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;groupId&gt;</span>org.springframework.boot<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;/plugin&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;/plugins&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/build&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#打包</span>
</span></span><span class=line><span class=cl>mvn package
</span></span></code></pre></div><p>target 目录下就可以找到 .jar 文件，我这里的文件名为：demo-0.0.1-SNAPSHOT.jar
在 Linux 新建 <code>~/springboot</code> 文件夹，并将 jar 包上传到这个文件夹下</p><ol start=3><li>新建 Dockerfile
在这个文件下新建 Dockerfile 文件</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 基于 openjdk:8-jre 这个基础镜像进行构建</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> openjdk:8-jre</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 这里的 demo-0.0.1- SNAPSHOT.jar 要对应上传的 jar 包名称</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 将 本地 jar包 复制到容器内</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> demo-0.0.1-SNAPSHOT.jar  app.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 开放 8080 端口</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 8080</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 运行命令、参数</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;java&#34;</span><span class=p>,</span><span class=s2>&#34;-jar&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;app.jar&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>保存文件，退出编辑器</p><ol start=4><li>编译 Docker 镜像</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># build 是构建 Docker 镜像的命令</span>
</span></span><span class=line><span class=cl><span class=c1># -t 指定镜像的 tag</span>
</span></span><span class=line><span class=cl><span class=c1># 名称：demo 版本：v1.0</span>
</span></span><span class=line><span class=cl><span class=c1># 最后的 . 表示 build context 目录为当前目录，目的是为了找到 所需的 jar 包</span>
</span></span><span class=line><span class=cl>docker build -t demo:v1.0 .
</span></span></code></pre></div><ol start=5><li>启动容器</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 前台启动刚构建的 SpringBoot 容器</span>
</span></span><span class=line><span class=cl><span class=c1># -p 映射容器8080端口 到宿主机的 8080 上</span>
</span></span><span class=line><span class=cl>docker run -p 8080:8080 demo:v1.0
</span></span></code></pre></div><ol start=6><li>测试
访问 Linux 的8080 端口，注意替换为自己的 Linux 的地址，并开放 8080 端口</li></ol><p>http://192.168.43.161:8080/hello</p><h2 id=build-context>build context<a hidden class=anchor aria-hidden=true href=#build-context>#</a></h2><p>Dockerfile 默认会使用它自己所在的目录作为 context，通过 docker 执行构建命令后，Docker daemon 会拷贝 context 目录下的<code>所有文件</code>，所以 context 目录不要放置项目无关的文件，或者可以使用 <code>.dockerignore</code> 定义忽略文件，也可以指定 context 路径</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># build 命令通过 Dockerfile 构建镜像</span>
</span></span><span class=line><span class=cl><span class=c1># 指定 ~/dockerfile 为 build context</span>
</span></span><span class=line><span class=cl>docker build ~/dockerfile
</span></span><span class=line><span class=cl><span class=c1># 不需要添加文件到 context 可以使用 -</span>
</span></span><span class=line><span class=cl>docker build -
</span></span></code></pre></div><p>可以通过 stdin 的方式，避免生产 Dockerfile 文件，直接 build 镜像</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t myimage:latest -<span class=s>&lt;&lt;EOF
</span></span></span><span class=line><span class=cl><span class=s>FROM busybox
</span></span></span><span class=line><span class=cl><span class=s>RUN echo &#34;hello world&#34;
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div><p>除了可以指定 context外，还可以通过-f 指定 Dockerfile 所在的路径</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build  -f dockerfiles/Dockerfile .
</span></span></code></pre></div><h2 id=最佳实践>最佳实践<a hidden class=anchor aria-hidden=true href=#最佳实践>#</a></h2><p>非常推荐官方的 Dockerfile最佳实践：<a href=https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>Best practices for writing Dockerfiles</a></p><ol><li>每个容器单一职责，有利于横向拓展和复用</li><li>旧版强调减少层数以提高性能，现在只有 RUN, COPY, ADD 这几个命令会创建层，其他命令只会创建中间层。并且只有使用到资源最终会被拷贝到最终镜像</li><li>多个参数按字母顺序排列，并使用空格和 <code>\</code> 进行分割，提高可读性</li><li><code>--no-cache</code> 不使用缓存，默认 build 过程中如果检查到有可重用的镜像层则使用。从基础镜像开始，每一条命令逐一检查，如果命令不一样则缓存失效。使用 <code>ADD</code> 和 <code>COPY</code> 则会校验使用到的文件<code>校验和</code>是否相同，除了这两个命令，其他则不会通过文件变化来决定是否匹配缓存，而是仅通过命令本身是否一致来判断是否匹配缓存，比如：<code>RUN apt-get -y update</code>会改变容器内的文件，但是也只使用这个命令匹配缓存，而不会通过文件的变动。一旦缓存失效，后续都会产生新的镜像层</li></ol><h2 id=dockerfile-指令-instructions>Dockerfile 指令 (instructions)<a hidden class=anchor aria-hidden=true href=#dockerfile-指令-instructions>#</a></h2><h3 id=from>FROM<a hidden class=anchor aria-hidden=true href=#from>#</a></h3><p>Dockerfile 的第一个命令一般都是 FROM，通过这个指定该镜像的 Base Image，推荐基础镜像：<a href=https://hub.docker.com/_/alpine/>alpine</a>，因为它完整且轻量，如果不需要 Base Image 可以用 <code>FROM scratch</code>，代表该镜像基于一个空镜像进行构建</p><h3 id=run>RUN<a hidden class=anchor aria-hidden=true href=#run>#</a></h3><p>由于上面提到的缓存匹配原则，<code>RUN apt-get update</code> 命令可能会导致直接使用了原来缓存的镜像层，而没有执行该命令获取最新的软件列表，可以使用 <code>RUN apt-get update && apt-get install -y</code> 来使缓存失效
可以使用 <code>\</code> 分割，提高可读性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>RUN apt-get update <span class=o>&amp;&amp;</span> apt-get install -y <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    curl
</span></span></code></pre></div><h3 id=cmd>CMD<a hidden class=anchor aria-hidden=true href=#cmd>#</a></h3><p>指定容器启动时运行的命令，通常默认采用的格式：<code>CMD ["executable", "param1", "param2"…]</code>，如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;perl&#34;</span><span class=p>,</span> <span class=s2>&#34;-de0&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>这样使用 <code>docker run -it</code> 命令进入容器时，就会默认进入 shell 界面</p><h3 id=expose>EXPOSE<a hidden class=anchor aria-hidden=true href=#expose>#</a></h3><p>指定容器需要监听的端口</p><h3 id=env>ENV<a hidden class=anchor aria-hidden=true href=#env>#</a></h3><p>可以使用 ENV 更新 PATH 环境变量，例如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>PATH</span><span class=o>=</span>/usr/local/nginx/bin:<span class=nv>$PATH</span><span class=err>
</span></span></span></code></pre></div><p>注意！每一个 <code>ENV</code> 指令都会创建一个新的中间层 (intermediate layer)，如果使用 ENV 设置了变量，在未来的层 unset 了变量，那么它在 unset 之前依然是可用的。为了防止这种情况，我们应该用 RUN 进行环境变量的 设置和取消</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>ADMIN_USER</span><span class=o>=</span><span class=s2>&#34;mark&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=nv>$ADMIN_USER</span> &gt; ./mark<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>unset</span> ADMIN_USER<span class=err>
</span></span></span></code></pre></div><h3 id=add-or-copy>ADD or COPY<a hidden class=anchor aria-hidden=true href=#add-or-copy>#</a></h3><p>两个命令功能相似，优先使用COPY，它的作用只是将本地文件拷贝到容器内，而 ADD 则有其他特性，比如：自动将本地 tar 文件提取到镜像中、远程URL
如果多个步骤需要使用不同的文件，应该单独 COPY，而不是一次性 COPY，这样部分文件变化不会导致所有的缓存都失效
避免使用 ADD 通过 URL 获取包，可以使用 <code>curl</code> 或者 <code>wget</code>，这样可以在提取后删除文件，避免镜像多一层，还可以通过管道，就不需要再手动删除中间文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>RUN</span> mkdir -p /usr/src/things <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> curl -SL https://example.com/big.tar.xz <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=p>|</span> tar -xJC /usr/src/things <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> make -C /usr/src/things all<span class=err>
</span></span></span></code></pre></div><h3 id=entrypoint>ENTRYPOINT<a hidden class=anchor aria-hidden=true href=#entrypoint>#</a></h3><p>使用 ENTRYPOINT 设置主命令，还可以用 CMD 设置默认的可选参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;s3cmd&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;--help&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>运行编译镜像，指定名称为：s3cmd，运行容器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run s3cmd
</span></span></code></pre></div><p>默认会运行 <code>s3cmd</code> 并带上 <code>--help</code> 参数，即：显示该命令的帮助</p><p>运行下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run s3cmd ls s3://mybucket
</span></span></code></pre></div><p><code>ls s3://mybucket</code> 会覆盖默认可选参数 <code>--help</code></p><p>如果需要覆盖 ENTRYPOINT，需要使用 <code>--entrypoint</code> 参数</p><h3 id=volume>VOLUME<a hidden class=anchor aria-hidden=true href=#volume>#</a></h3><p>暴露镜像中可变和用户可修改的数据，比如：存储文件、配置文件，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>VOLUME</span><span class=s> /data</span><span class=err>
</span></span></span></code></pre></div><p>设置的目录会在容器运行时自动挂载为匿名卷，如果没有设置，就会写入容器存储层</p><h3 id=user>USER<a hidden class=anchor aria-hidden=true href=#user>#</a></h3><p>如果不需要使用 <code>sudo</code> ，可以通过 USER 切换到非 root 用户，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>RUN</span> groupadd -r postgres <span class=o>&amp;&amp;</span> useradd --no-log-init -r -g postgres postgres<span class=err>
</span></span></span></code></pre></div><h3 id=workdir>WORKDIR<a hidden class=anchor aria-hidden=true href=#workdir>#</a></h3><p>WORKDIR 指令可以来指定工作目录，不存在会自动创建
Dockerfile 不同于 Shell，下面的命令其实是不同的层，第一条的 <code>cd</code> 不会影响第二条命令，最终运行结束会导致在 /app 下找不到 world.txt 文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>RUN</span> <span class=nb>cd</span> /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span> &gt; world.txt<span class=err>
</span></span></span></code></pre></div><p>应该使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span> &gt; world.txt<span class=err>
</span></span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://yeasy.gitbook.io/docker_practice/image/build>使用 Dockerfile 定制镜像</a></p><p><a href=https://segmentfault.com/a/1190000018222648>利用构建缓存机制缩短Docker镜像构建时间</a></p><p><a href=https://zhuanlan.zhihu.com/p/30555962>Dockerfile: ENTRYPOINT和CMD的区别</a></p><hr><p>上一节：<a href=https://www.cnblogs.com/aaronlinv/p/15130730.html>Docker 实践及命令梳理</a>
下一节：<a href=https://www.cnblogs.com/aaronlinv/p/15228488.html>IDEA 配合 Dockerfile 部署 SpringBoot 工程</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronlinv.github.io/posts/idea-%E9%85%8D%E5%90%88-dockerfile-%E9%83%A8%E7%BD%B2-springboot-%E5%B7%A5%E7%A8%8B/><span class=title>« Prev</span><br><span>IDEA 配合 Dockerfile 部署 SpringBoot 工程</span>
</a><a class=next href=https://aaronlinv.github.io/posts/springboot-%E6%95%B4%E5%90%88-springsecurity-%E6%A2%B3%E7%90%86/><span class=title>Next »</span><br><span>SpringBoot 整合 SpringSecurity 梳理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>