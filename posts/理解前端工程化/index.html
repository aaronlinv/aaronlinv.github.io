<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>理解前端工程化 | Aaron Lin</title>
<meta name=keywords content><meta name=description content="最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题
TL;DR
工程化的目的：降低开发成本提高开发效率
方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS  等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码
模块化、包管理
分解聚合：拆分复杂任务，降低复杂度（分而治之）
模块化解决 问题：1. 全局污染 2. 依赖管理 等等
JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案）
实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持
包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等
JS 工具链
JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：

新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法
新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码

有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用："><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="理解前端工程化"><meta property="og:description" content="最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题
TL;DR 工程化的目的：降低开发成本提高开发效率 方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS 等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码
模块化、包管理 分解聚合：拆分复杂任务，降低复杂度（分而治之）
模块化解决 问题：1. 全局污染 2. 依赖管理 等等 JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案） 实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持
包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等
JS 工具链 JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：
新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法 新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码 有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-28T08:58:33+08:00"><meta property="article:modified_time" content="2024-04-28T08:58:33+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="理解前端工程化"><meta name=twitter:description content="最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题
TL;DR
工程化的目的：降低开发成本提高开发效率
方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS  等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码
模块化、包管理
分解聚合：拆分复杂任务，降低复杂度（分而治之）
模块化解决 问题：1. 全局污染 2. 依赖管理 等等
JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案）
实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持
包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等
JS 工具链
JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：

新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法
新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码

有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"理解前端工程化","item":"https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"理解前端工程化","name":"理解前端工程化","description":"最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题\nTL;DR 工程化的目的：降低开发成本提高开发效率 方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS 等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码\n模块化、包管理 分解聚合：拆分复杂任务，降低复杂度（分而治之）\n模块化解决 问题：1. 全局污染 2. 依赖管理 等等 JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案） 实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持\n包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等\nJS 工具链 JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：\n新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法 新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码 有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用：\n","keywords":[],"articleBody":"最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题\nTL;DR 工程化的目的：降低开发成本提高开发效率 方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS 等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码\n模块化、包管理 分解聚合：拆分复杂任务，降低复杂度（分而治之）\n模块化解决 问题：1. 全局污染 2. 依赖管理 等等 JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案） 实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持\n包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等\nJS 工具链 JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：\n新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法 新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码 有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用：\n// common js module.exports = { presets: [ // 预设名称 \u0026 配置 ['@babel/preset-env', { targets: { edge: '17', firefox: '60', chrome: '67', safari: '11.1' }, // 按需导入 polyfill，未使用的 API 不导入 useBuiltIns: 'usage', corejs: '3.37.0', }] ] // 插件的配置方式 // plugins: [ // '@babel/plugin-transform-optional-chaining' // ] } 有了这种思维之后，就可以通过 转换代码 的方式任意地增强 JS 的能力，就像：JSX 和 TypeScript ，它们最终还是会被编译为纯 JS 代码\nCSS 工具链 CSS 语法缺失（逻辑、函数等等），无法进行复杂的操作，所以就有了 CSS 预编译器：Less, Sass 等等的，与 JS 的处理方式一样，可以通过工具对其进行转换，转换为最朴素的 CSS，这样就没有兼容性的问题。解决了兼容性问题还需要解决 CSS 本身的问题：\n浏览器前缀 ( vendor prefixes )：类似 -webkit- 开头的样式 ，可以通过 autoprefixer 来自动添加浏览器前缀以确保网页在不同浏览器中的兼容性 压缩：减少 CSS 文件的大小，从而提高网页加载速度，相关的库 cssnano 剪枝：移除没有用到的 CSS，相关的库：purgecss 类名冲突：通过 css module 来实现，相关的库：postcss-modules 与处理 JS 的 Babel 类似，CSS 也有工具整合了上面这些工具，它就是PostCSS，安装需要的 依赖后，还需要配置 postcss.config.js。与 Babel 类似，它也可以开箱即用，需要安装依赖并配置 postcss-preset-env\nmodule.exports = { map: false, plugins: { tailwindcss: {}, 'postcss-preset-env': {}, }, }; 构建工具和脚手架 开发和运行的代码不一致，开发阶段我们希望工程代码可以方便地开发维护，而在对于生产运行的代码，我们则希望它兼容性强、文件小、加载快等等。这中间就需要打包工具来进行转换，常用的打包工具有：webpack，它的主要作用：\n模块化管理：使得项目结构清晰、依赖关系明确 打包编译：将各个模块按照其依赖关系进行打包编译，将它们转换为浏览器可识别的静态资源文件 资源优化：压缩 JavaScript、CSS、图片等文件，以减小文件体积，提高加载速度 代码分割：实现按需加载，提高页面加载性能 开发服务器：自动编译并运行服务（热更新），便于开发 Source Map：存储了编译后代码与源代码之间的映射关系，便于调试代码 与 Babel 和 PostCSS 相似，一旦有很多细碎的东西出现，就必然有工具可以进行整合并提供预设，对于整个代码工程来说，它就是脚手架：vue-cli, vite 等等，提供了交互式的界面辅助生成工程模版\n参考资料 ECMAScript 6 入门 - 阮一峰 工程化大师课 What is @babel/preset-env and why do I need it? postcss 结合 tailwindcss 前端技术的十八年风雨（2006-2024）\n","wordCount":"245","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-28T08:58:33+08:00","dateModified":"2024-04-28T08:58:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">理解前端工程化</h1><div class=post-meta><span title='2024-04-28 08:58:33 +0800 +0800'>April 28, 2024</span></div></header><div class=post-content><p>最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>工程化的目的：降低开发成本提高开发效率
方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 <code>Babel</code> 而 CSS 可以通过 <code>Sass</code>, <code>Less</code>, <code>PostCSS</code> 等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码</p><h2 id=模块化包管理>模块化、包管理<a hidden class=anchor aria-hidden=true href=#模块化包管理>#</a></h2><p>分解聚合：拆分复杂任务，降低复杂度（分而治之）</p><p>模块化解决 <strong>问题</strong>：1. 全局污染 2. 依赖管理 等等
JS 模块化<strong>标准</strong>（常用）：1. <code>CommonJS</code> （Node 标准）2. <code>ES modules</code>（JavaScript 官方标准模块化方案）
<strong>实现</strong>：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持</p><p>包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等</p><h2 id=js-工具链>JS 工具链<a hidden class=anchor aria-hidden=true href=#js-工具链>#</a></h2><p>JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都<strong>转换</strong>为向后兼容的老版本 JS 代码。前端的运行环境更多的是在<strong>用户</strong>这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：</p><ol><li>新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 <code>core-js</code> 库，就实现了 <code>Array</code> 的 <code>flatMap</code> 方法，这样在旧版本的 Node 环境，也可使用该方法</li><li>新语法：例如 <code>Promise</code>，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 <code>regenerator</code> 库可以将含有 <code>Promise</code> 的代码转换为向后兼容的代码</li></ol><p>有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 <a href=https://es6.ruanyifeng.com/#docs/intro#Babel-%E8%BD%AC%E7%A0%81%E5%99%A8>Babel</a>，可以通过 <code>Babel</code> 的插件整合这些转换代码的库，需要安装对应的 <code>Babel</code> 插件依赖 并在 <code>babel.config.js</code> 中配置 <code>plugins</code>。这样还是很麻烦，所以我们可以直接使用 <code>Babel</code> 的预设，其中最常用的就是：<code>@babel/preset-env</code>，安装依赖以后完成以下的 <code>babel.config.js</code> 配置，即可开箱即用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// common js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>presets</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 预设名称 &amp; 配置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>[</span><span class=s1>&#39;@babel/preset-env&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>targets</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>edge</span><span class=o>:</span> <span class=s1>&#39;17&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>firefox</span><span class=o>:</span> <span class=s1>&#39;60&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>chrome</span><span class=o>:</span> <span class=s1>&#39;67&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>safari</span><span class=o>:</span> <span class=s1>&#39;11.1&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 按需导入 polyfill，未使用的 API 不导入
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>useBuiltIns</span><span class=o>:</span> <span class=s1>&#39;usage&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>corejs</span><span class=o>:</span> <span class=s1>&#39;3.37.0&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>}]</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 插件的配置方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// plugins: [
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     &#39;@babel/plugin-transform-optional-chaining&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>有了这种思维之后，就可以通过 <strong>转换代码</strong> 的方式任意地增强 JS 的能力，就像：<code>JSX</code> 和 <code>TypeScript</code> ，它们最终还是会被编译为纯 JS 代码</p><h2 id=css-工具链>CSS 工具链<a hidden class=anchor aria-hidden=true href=#css-工具链>#</a></h2><p>CSS 语法缺失（逻辑、函数等等），无法进行复杂的操作，所以就有了 CSS 预编译器：Less, Sass 等等的，与 JS 的处理方式一样，可以通过工具对其进行<strong>转换</strong>，转换为最朴素的 CSS，这样就没有兼容性的问题。解决了兼容性问题还需要解决 CSS 本身的问题：</p><ol><li>浏览器前缀 ( vendor prefixes )：类似 <code>-webkit-</code> 开头的样式 ，可以通过 <a href=https://github.com/postcss/autoprefixer>autoprefixer</a> 来自动添加浏览器前缀以确保网页在不同浏览器中的兼容性</li><li>压缩：减少 CSS 文件的大小，从而提高网页加载速度，相关的库 <a href=https://github.com/cssnano/cssnano>cssnano</a></li><li>剪枝：移除没有用到的 CSS，相关的库：<a href=https://github.com/FullHuman/purgecss>purgecss</a></li><li>类名冲突：通过 css module 来实现，相关的库：<a href=https://www.npmjs.com/package/postcss-modules>postcss-modules</a></li></ol><p>与处理 JS 的 <code>Babel</code> 类似，CSS 也有工具整合了上面这些工具，它就是<a href=https://github.com/postcss/postcss>PostCSS</a>，安装需要的 依赖后，还需要配置 <code>postcss.config.js</code>。与 Babel 类似，它也可以开箱即用，需要安装依赖并配置 <a href=https://github.com/csstools/postcss-plugins/tree/main/plugin-packs/postcss-preset-env>postcss-preset-env</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>map</span><span class=o>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>plugins</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tailwindcss</span><span class=o>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;postcss-preset-env&#39;</span><span class=o>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=构建工具和脚手架>构建工具和脚手架<a hidden class=anchor aria-hidden=true href=#构建工具和脚手架>#</a></h2><p>开发和运行的代码<strong>不一致</strong>，开发阶段我们希望工程代码可以方便地开发维护，而在对于生产运行的代码，我们则希望它兼容性强、文件小、加载快等等。这中间就需要打包工具来进行转换，常用的打包工具有：<a href=https://webpack.js.org/>webpack</a>，它的主要作用：</p><ol><li>模块化管理：使得项目结构清晰、依赖关系明确</li><li>打包编译：将各个模块按照其依赖关系进行打包编译，将它们转换为浏览器可识别的静态资源文件</li><li>资源优化：压缩 JavaScript、CSS、图片等文件，以减小文件体积，提高加载速度</li><li>代码分割：实现按需加载，提高页面加载性能</li><li>开发服务器：自动编译并运行服务（热更新），便于开发</li><li>Source Map：存储了编译后代码与源代码之间的映射关系，便于调试代码</li></ol><p>与 <code>Babel</code> 和 <code>PostCSS</code> 相似，一旦有很多细碎的东西出现，就必然有工具可以进行整合并提供预设，对于整个代码工程来说，它就是脚手架：<a href=https://cli.vuejs.org/>vue-cli</a>, <a href=https://vitejs.dev/>vite</a> 等等，提供了交互式的界面辅助生成工程模版</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://es6.ruanyifeng.com/>ECMAScript 6 入门 - 阮一峰</a>
<a href=https://fe.duyiedu.com/p/t_pc/goods_pc_detail/goods_detail/course_2fRWGMzUV1NrSonwl0LUdco3Z7Q>工程化大师课</a>
<a href=https://blog.jakoblind.no/babel-preset-env/>What is @babel/preset-env and why do I need it?</a>
<a href=https://tailwindcss.com/docs/installation/using-postcss>postcss 结合 tailwindcss</a>
<a href=https://www.bilibili.com/video/BV1eC411p73m/>前端技术的十八年风雨（2006-2024）</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronlinv.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88-ai-%E6%97%B6%E4%BB%A3%E6%9B%B4%E5%BA%94%E8%AF%A5-learn-in-public/><span class=title>« Prev</span><br><span>为什么 AI 时代更应该 Learn in Public</span>
</a><a class=next href=https://aaronlinv.github.io/posts/javascript-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/><span class=title>Next »</span><br><span>JavaScript 事件循环 动画演示</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>