<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>简单的 Shell 脚本入门教程 | Aaron Lin</title>
<meta name=keywords content><meta name=description content="Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现
工具推荐
Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：

shellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 Shellman reborn 中写到了 Shellman 诞生的故事，挺有趣的
shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 shellcheck Installing，Mac OS 可以使用 brew install shellcheck，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示
shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F
Code Runner 脚本运行，右键 Run Code，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N

运行 shell 脚本
新建脚本：test.sh
#!/usr/bin/env bash

# 使用echo 打印字符串或者变量
echo 'hello world'
可以用 Code Runner 运行，就会输出：hello world"><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="简单的 Shell 脚本入门教程"><meta property="og:description" content="Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现
工具推荐 Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：
shellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 Shellman reborn 中写到了 Shellman 诞生的故事，挺有趣的 shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 shellcheck Installing，Mac OS 可以使用 brew install shellcheck，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示 shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F Code Runner 脚本运行，右键 Run Code，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N 运行 shell 脚本 新建脚本：test.sh
#!/usr/bin/env bash # 使用echo 打印字符串或者变量 echo 'hello world' 可以用 Code Runner 运行，就会输出：hello world"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-05T09:08:33+08:00"><meta property="article:modified_time" content="2022-01-05T09:08:33+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="简单的 Shell 脚本入门教程"><meta name=twitter:description content="Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现
工具推荐
Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：

shellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 Shellman reborn 中写到了 Shellman 诞生的故事，挺有趣的
shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 shellcheck Installing，Mac OS 可以使用 brew install shellcheck，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示
shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F
Code Runner 脚本运行，右键 Run Code，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N

运行 shell 脚本
新建脚本：test.sh
#!/usr/bin/env bash

# 使用echo 打印字符串或者变量
echo 'hello world'
可以用 Code Runner 运行，就会输出：hello world"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"简单的 Shell 脚本入门教程","item":"https://aaronlinv.github.io/posts/%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"简单的 Shell 脚本入门教程","name":"简单的 Shell 脚本入门教程","description":"Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现\n工具推荐 Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：\nshellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 Shellman reborn 中写到了 Shellman 诞生的故事，挺有趣的 shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 shellcheck Installing，Mac OS 可以使用 brew install shellcheck，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示 shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F Code Runner 脚本运行，右键 Run Code，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N 运行 shell 脚本 新建脚本：test.sh\n#!/usr/bin/env bash # 使用echo 打印字符串或者变量 echo \u0026#39;hello world\u0026#39; 可以用 Code Runner 运行，就会输出：hello world\n","keywords":[],"articleBody":"Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现\n工具推荐 Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：\nshellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 Shellman reborn 中写到了 Shellman 诞生的故事，挺有趣的 shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 shellcheck Installing，Mac OS 可以使用 brew install shellcheck，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示 shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F Code Runner 脚本运行，右键 Run Code，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N 运行 shell 脚本 新建脚本：test.sh\n#!/usr/bin/env bash # 使用echo 打印字符串或者变量 echo 'hello world' 可以用 Code Runner 运行，就会输出：hello world\n在 Shell脚本 的第一行一般会写 #!/bin/bash 这个是 Shebang，#! 后面是解释器的绝对路径，脚本将用该解释器执行。还有一种写法是：#!/usr/bin/env bash，/usr/bin/env 是 env 命令的绝对路径，而 env 命令用于显示系统中已存在的环境变量，其中包含了 $PATH ，会在 $PATH 包含的目录依次找 bash，常见的命令行解释器有：sh ,bash ,zsh(Mac OS 默认解释器)\n如果在 Linux 或 类Unix 下运行，有这么几种方式：\n先给脚本添加执行权限：chmod +x test.sh，然后运行脚本：./test.sh，这种方式执行会读取 Shebang，用指定的解释器执行脚本 sh test.sh，使用 sh 这个解释器执行脚本，当然也可以用其他执行，比如：bash test.sh。与第一种方式相同，当前的 shell 是父进程，生成一个子 shell 进程（子进程会继承父进程的环境变量），在子 shell 中执行脚本，脚本执行完毕，退出子 shell 回到当前 shell source 点命令方式：source test.sh 等效于 . test.sh。source 让脚本在当前 shell 执行，不生成新的子进程。使用 source 执行脚本，脚本中对于环境变量的修改会作用于当前 shell，这就是为什么我们在修改了一些配置如：~/.bashrc，执行 source ~/.bashrc 后配置就生效了 exec 方式：有需要先给脚本添加执行权限：chmod +x test.sh，执行 exec ./test.sh，也是让脚本在同一个进程上执行不生成新的子进程，与 source 的区别就是，在脚本执行完成后进程会被结束 基础命令 可以按照 [Bash Shell] Shell学习笔记 学习，这篇文章讲的非常详细，本篇博客也是在学习这篇文章后写下的\n获取输入 使用 read 命令，从标准输入流 (stdin) 获取输入\n#!/usr/bin/env bash read var echo \"${var}\" 运行脚本，输入任意字符，回车确认，输入的值会赋值给变量 var，并打印出该变量\n输出 #!/usr/bin/env bash var=1 # 输出变量 echo ${var} # 输出字符串 显示部分字符需要转义 echo \"\\\"hello world\\\"\" # \"hello world\" # 换行使用 -e 参数：使转义字符生效 # 使用 \\n 换行 echo -e \"newline\\n\" 也可以让 shell 输出不同颜色的字符，可以参考：shell脚本中echo显示内容带颜色\n#!/usr/bin/env bash echo -e \"\\033[30m 黑色字 \\033[0m\" echo -e \"\\033[31m 红色字 \\033[0m\" echo -e \"\\033[32m 绿色字 \\033[0m\" echo -e \"\\033[33m 黄色字 \\033[0m\" echo -e \"\\033[34m 蓝色字 \\033[0m\" echo -e \"\\033[35m 紫色字 \\033[0m\" echo -e \"\\033[36m 天蓝字 \\033[0m\" echo -e \"\\033[37m 白色字 \\033[0m\" 变量使用 # = 两边不能有空格 var=\"hello world\" num=100 # 在引用变量时，这种方式可以，但是推荐下面一种 echo $var # 推荐在使用字符串变量时，在两侧加上双引号，否则如果变量字符串中存在空格，则字符串会被切分 echo \"$var\" # 如果涉及字符串拼接，可以在变量名两侧加上花括号 echo \"变量为: ${var}.\" # 将变量设置为只读，再次修改会报错 readonly var # var=\"wolrd\" # 删除变量，不能删除 readonly 修饰的变量 unset num 变量赋值时，变量名命名规则和其他语言类似，注意变量赋值时 = 两边不能有空格\n使用时在变量名前加上 $，推荐所有的变量都使用 ${} 的方式使用变量\n运算 算术运算：Bash 原生不支持数学运算，可以使用 awk 和 expr\n注意乘号需要加上转义：\\*，而且运算符两侧必须空格\na=10 b=3 val=`expr $a + $b` echo \"a + b : $val\" val=`expr $a - $b` echo \"a - b : $val\" val=`expr $a \\* $b` echo \"a * b : $val\" val=`expr $b / $a` echo \"b / a : $val\" val=`expr $b % $a` echo \"b % a : $val\" 执行命令 $()与 ``（反引号）都可以用于执行命令，并会将执行的结果返回，shellcheck 推荐使用第一种 $() 的方式\n#!/usr/bin/env bash result=`date \"+%Y-%m-%d\"` echo \"${result}\" result=$(date \"+%Y-%m-%d\") echo \"${result}\" 运算符 关系运算符只支持数字，如果字符串为数字也可以，关系运算符包括：\n运算符 含义 -eq 等于 -ne 不等于 -gt 大于 -lt 小于 -ge 大等于 -le 小等于 条件表达式必须放在 [] 中，并且 [ 的右侧，和 ] 的左侧必须留有空格\n布尔运算符列表：\n运算符 含义 ! 非 -o 或 (or) -a 与 (and) #!/usr/bin/env bash a=\"10\" b=\"3\" c=1 if [ ${a} -ne ${b} ] then echo \"相同\" else echo \"不相同\" fi if [ ${a} -gt ${b} -a ${b} -gt ${c} ] then echo \"a \u003e b \u0026 b \u003e c\" fi 其他常用判断：\n直接在 [ ] 中放字符串变量 如 [ ${str} ] 则就是判断 str 这个字符串是否非空 -f 判断是否为普通文件，如：[ -f $file ] -d 判断是否为文件夹，如：[ -d $file ] 字符串截取 字符截取的格式：${string: start :length} 索引从 0 开始，可以省略 :length 这样就截取到最后，注意空格要空在 : 后，否则可能提示：bad substitution\n#!/usr/bin/env bash string=\"hello world\" echo ${string: 1 : 3} # ell # 截取到最后 echo ${string:1} # ello world 数组 #!/usr/bin/env bash # 1. 定义数组：使用括号声明，用“空格”分隔开，也可以换行隔开 arr=(1 2 3) strArr=( \"first\" \"second\" ) # 2. 读取数组：通过下标读取，下标从 0 开始计算 echo \"${arr[0]}\" # 使用 * 或者 @ 读取所有元素 echo ${arr[*]} echo ${arr[@]} # 读取数组长度 读取全部元素前面加上 # echo ${#arr[*]} echo ${#arr[@]} # 遍历下标 for(( i=0;i\u003c${#strArr[@]};i++)) do echo ${strArr[i]}; done; # for in 遍历元素 for element in ${strArr[*]} do echo $element done # 3. 修改数组元素 strArr[0]=\"modify\" echo ${strArr[0]} # 4. 删除元素 unset arr[1] echo ${#arr[*]} echo ${arr[*]} # 1 3 # ！使用 unset 要注意，这其实并不是真正删除了该元素，而只是将该元素置空，所以使用下标遍历会出问题，如下 echo \"数组遍历：\" for(( i=0;i\u003c${#arr[@]};i++)) do echo \"index ${i} -\u003e ${arr[i]}\"; done; # index 0 -\u003e 1 # index 1 -\u003e # 解决 unset 无法真正删除的方法：重新赋值给新的数组 echo \"数组遍历：\" arr=( \"${arr[@]}\" ) for(( i=0;i\u003c${#arr[@]};i++)) do echo \"index ${i} -\u003e ${arr[i]}\"; done; # index 0 -\u003e 1 # index 1 -\u003e 3 判断语句 使用 if 和 fi 定义判断的边界，使用 then , elif , else 定义条件\n#!/usr/bin/env bash #!/usr/bin/env bash a=10 b=20 if [ $a == $b ] then echo \"相等\" else echo \"不相等\" fi if [ $a == $b ] then echo \"相等\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"其他情况\" fi 函数 调用函数时，我们可以传入参数，可以通过 $n 来获取参数，这里的 n 表示 需要取的参数的索引，当n\u003e=10时，需要使用${n}来获取参数\n$# 传递给函数的参数个数，$* 和 $@ 显示所有传递给函数的参数，$? 表示函数的返回值，也可以用于获取上一个命令的退出状态，执行成功会返回 0，失败返回 1\n# 定义函数 #!/usr/bin/env bash funWithParam(){ echo \"参数个数：$#\" # 参数个数：11 echo \"传递给函数的所有参数：$*\" # 传递给函数的所有参数：1 2 3 4 5 6 7 8 9 34 73 echo \"$1\" # 1 # 超过 9 的参数需要用 ${} 接收参数，否则直接显示数值 echo \"$10\" # 10 echo \"${11}\" # 73 } # 调用函数：函数名后面直接跟上参数 funWithParam 1 2 3 4 5 6 7 8 9 34 73 echo \"$?\" # 0 输入输出重定向 使用 \u003e 将应该输出到终端上的数据重定向输出到文件，\u003e 默认为覆盖文件，使用 \u003e\u003e 追加写入文件 使用 \u003c 将默认从键盘输入的数据，定向为从文件输入\n# who 命令用于显示系统中有哪些使用者正在上面 # 将结果输入 who.txt who \u003e who.txt # wc -l 作用是计算文本行数 wc -l \u003c who.txt 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n标准输入 (stdin)：stdin 的文件描述符为 0，Unix 程序默认从 stdin 读取数据 标准输出 (stdout)：stdout 的文件描述符为 1，Unix 程序默认向 stdout 输出数据 标准错误输出 (stderr)：stderr 的文件描述符为 2，Unix 程序会向 stderr 流中写入错误信息 所以一般我们后台启动应用并且输出日志文件都使用：\nnohup java -jar xxx.jar \u003e\u003e nohup.log 2\u003e\u00261 \u0026 nohup：(no hang up) 保证在退出帐户或者关闭终端之后继续运行相应的进程 \u003e\u003e nohup.log：将 java -jar xxx.jar 的输出追加到 nohup.log 文件 2\u003e\u00261：将 java -jar xxx.jar 的 标准错误输出 也重定向到 标准输入 \u0026：让进程在后台运行\n默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。 如果希望 stderr 重定向到 file，可以这样写：\n坑梳理 变量赋值时，变量名命名规则和其他语言类似，注意变量赋值时 = 两边不能有空格 数组 unset 元素，并不是真正的移除元素 获取参数时，当 n\u003e=10 时，需要使用${n}来获取参数 常见的特殊 Shell 环境变量 $$ 表示当前Shell进程的ID，即pid $0 表示当前脚本的绝对路径 $# 传递给脚本或函数的参数个数 $n 传递给脚本或函数的参数 $? 上个命令的退出状态 $* 和 $@ 传递给脚本或函数的所有参数 $n n 代表 1~9 其中任意一个数字，传递给脚本或函数该位置的参数 $* 和 $@ 区别：\n#!/usr/bin/env bash function asterisk () { echo \"\\\"\\$*\\\"\" for var in \"$*\" do echo \"$var\" done } function mail () { echo \"\\\"\\$@\\\"\" for var in \"$@\" do echo \"$var\" done } asterisk a b c mail a b c 输出\n\"$*\" a b c \"$@\" a b c 当 $* 和 $@ 直接使用效果相同，都是接收一份数据如上所示的例子，接收到的就是：a b c，一份数据，以空格隔开。加了双引号后 \"$@\" 会将每个参数都当成一份独立的数据\n参考资料 VS code 打造 shell脚本 IDE #!/bin/bash 和 #!/usr/bin/env bash 的区别 Shell脚本 - wiki Linux跑脚本用sh和./有什么区别？ 执行shell脚本三种方法的区别：（sh、exec、source） Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数 exec 跟 source 差在哪？ bash - 如何删除数组中的元素，然后在 Shell 脚本中移动数组？ nohup /dev/null 2\u003e\u00261 含义详解 Linux—shell中$(( ))、$( )、``与${ }的区别 Shell $*和$@的区别\n","wordCount":"970","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-01-05T09:08:33+08:00","dateModified":"2022-01-05T09:08:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/%E7%AE%80%E5%8D%95%E7%9A%84-shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">简单的 Shell 脚本入门教程</h1><div class=post-meta><span title='2022-01-05 09:08:33 +0800 +0800'>January 5, 2022</span></div></header><div class=post-content><p>Shell脚本 运作方式与解释型语言相当，如果有语言基础，学起 Shell 脚本就非常容易，但是 Shell 与常见的语言不同，一些常见的函数在 Shell 中需要组合一些命令得以实现</p><h1 id=工具推荐>工具推荐<a hidden class=anchor aria-hidden=true href=#工具推荐>#</a></h1><p>Shell 似乎没有定制的 IDE，这里推荐 VS Code 搭配对应的插件：</p><ol><li>shellman 智能提示和自动补全，在插件页面有介绍常用代码片段的触发关键词，作者在 <a href=https://medium.com/@remisa.yousefvand/shellman-reborn-f2cc948ce3fc>Shellman reborn</a> 中写到了 Shellman 诞生的故事，挺有趣的</li><li>shellcheck 语法静态检查工具，插件安装后需要本地安装 shellcheck，参考 <a href=https://github.com/koalaman/shellcheck#installing>shellcheck Installing</a>，Mac OS 可以使用 <code>brew install shellcheck</code>，这样在写 Shell 的时候，语法有误的地方就会以波浪线的方式提示</li><li>shell-format 代码整理，Win 快捷键：Alt + Shift + F，Mac OS 快捷键：option + shift + F</li><li>Code Runner 脚本运行，右键 <code>Run Code</code>，Win 快捷键：Ctrl + Alt + N，Mac OS 快捷键：control + option + N</li></ol><h1 id=运行-shell-脚本>运行 shell 脚本<a hidden class=anchor aria-hidden=true href=#运行-shell-脚本>#</a></h1><p>新建脚本：<code>test.sh</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># 使用echo 打印字符串或者变量</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;hello world&#39;</span>
</span></span></code></pre></div><p>可以用 Code Runner 运行，就会输出：<code>hello world</code></p><p>在 Shell脚本 的第一行一般会写 <code>#!/bin/bash</code> 这个是 <a href=https://zh.wikipedia.org/wiki/Shebang>Shebang</a>，<code>#!</code> 后面是解释器的绝对路径，脚本将用该解释器执行。还有一种写法是：<code>#!/usr/bin/env bash</code>，<code>/usr/bin/env</code> 是 env 命令的绝对路径，而 env 命令用于显示系统中已存在的环境变量，其中包含了 <code>$PATH</code> ，会在 <code>$PATH</code> 包含的目录依次找 <code>bash</code>，常见的命令行解释器有：sh ,bash ,zsh(Mac OS 默认解释器)</p><p>如果在 Linux 或 类Unix 下运行，有这么几种方式：</p><ol><li>先给脚本添加执行权限：<code>chmod +x test.sh</code>，然后运行脚本：<code>./test.sh</code>，这种方式执行会读取 Shebang，用指定的解释器执行脚本</li><li><code>sh test.sh</code>，使用 sh 这个解释器执行脚本，当然也可以用其他执行，比如：<code>bash test.sh</code>。与第一种方式相同，当前的 shell 是父进程，生成一个子 shell 进程（子进程会继承父进程的环境变量），在子 shell 中执行脚本，脚本执行完毕，退出子 shell 回到当前 shell</li><li>source 点命令方式：<code>source test.sh</code> 等效于 <code>. test.sh</code>。source 让脚本在当前 shell 执行，不生成新的子进程。使用 source 执行脚本，脚本中对于环境变量的修改会作用于当前 shell，这就是为什么我们在修改了一些配置如：<code>~/.bashrc</code>，执行 <code>source ~/.bashrc</code> 后配置就生效了</li><li>exec 方式：有需要先给脚本添加执行权限：<code>chmod +x test.sh</code>，执行 <code>exec ./test.sh</code>，也是让脚本在同一个进程上执行不生成新的子进程，与 source 的区别就是，在脚本执行完成后进程会被结束</li></ol><h1 id=基础命令>基础命令<a hidden class=anchor aria-hidden=true href=#基础命令>#</a></h1><p>可以按照 <a href=https://www.cnblogs.com/maybe2030/p/5022595.html>[Bash Shell] Shell学习笔记</a> 学习，这篇文章讲的非常详细，本篇博客也是在学习这篇文章后写下的</p><h2 id=获取输入>获取输入<a hidden class=anchor aria-hidden=true href=#获取输入>#</a></h2><p>使用 <code>read</code> 命令，从标准输入流 (stdin) 获取输入</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>read</span> var
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>var</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>运行脚本，输入任意字符，回车确认，输入的值会赋值给变量 <code>var</code>，并打印出该变量</p><h2 id=输出>输出<a hidden class=anchor aria-hidden=true href=#输出>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nv>var</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># 输出变量</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>var</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=c1># 输出字符串 显示部分字符需要转义</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;\&#34;hello world\&#34;&#34;</span> <span class=c1># &#34;hello world&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 换行使用 -e 参数：使转义字符生效</span>
</span></span><span class=line><span class=cl><span class=c1># 使用 \n 换行</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;newline\n&#34;</span>
</span></span></code></pre></div><p>也可以让 shell 输出不同颜色的字符，可以参考：<a href=https://www.cnblogs.com/lr-ting/archive/2013/02/28/2936792.html>shell脚本中echo显示内容带颜色</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>echo</span> -e <span class=s2>&#34;\033[30m 黑色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[31m 红色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[32m 绿色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[33m 黄色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[34m 蓝色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[35m 紫色字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[36m 天蓝字 \033[0m&#34;</span> 
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\033[37m 白色字 \033[0m&#34;</span> 
</span></span></code></pre></div><h2 id=变量使用>变量使用<a hidden class=anchor aria-hidden=true href=#变量使用>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># = 两边不能有空格</span>
</span></span><span class=line><span class=cl><span class=nv>var</span><span class=o>=</span><span class=s2>&#34;hello world&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>num</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在引用变量时，这种方式可以，但是推荐下面一种</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$var</span>
</span></span><span class=line><span class=cl><span class=c1># 推荐在使用字符串变量时，在两侧加上双引号，否则如果变量字符串中存在空格，则字符串会被切分</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$var</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># 如果涉及字符串拼接，可以在变量名两侧加上花括号</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;变量为: </span><span class=si>${</span><span class=nv>var</span><span class=si>}</span><span class=s2>.&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将变量设置为只读，再次修改会报错</span>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> var
</span></span><span class=line><span class=cl><span class=c1># var=&#34;wolrd&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除变量，不能删除 readonly 修饰的变量</span>
</span></span><span class=line><span class=cl><span class=nb>unset</span> num
</span></span></code></pre></div><p>变量赋值时，变量名命名规则和其他语言类似，<strong>注意变量赋值时 <code>=</code> 两边不能有空格</strong></p><p>使用时在变量名前加上 <code>$</code>，推荐所有的变量都使用 <code>${}</code> 的方式使用变量</p><h2 id=运算>运算<a hidden class=anchor aria-hidden=true href=#运算>#</a></h2><p>算术运算：Bash 原生不支持数学运算，可以使用 <code>awk</code> 和 <code>expr</code></p><p>注意乘号需要加上转义：<code>\*</code>，而且<strong>运算符两侧必须空格</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>b</span><span class=o>=</span><span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>val</span><span class=o>=</span><span class=sb>`</span>expr <span class=nv>$a</span> + <span class=nv>$b</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;a + b : </span><span class=nv>$val</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>val</span><span class=o>=</span><span class=sb>`</span>expr <span class=nv>$a</span> - <span class=nv>$b</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;a - b : </span><span class=nv>$val</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>val</span><span class=o>=</span><span class=sb>`</span>expr <span class=nv>$a</span> <span class=se>\*</span> <span class=nv>$b</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;a * b : </span><span class=nv>$val</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>val</span><span class=o>=</span><span class=sb>`</span>expr <span class=nv>$b</span> / <span class=nv>$a</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;b / a : </span><span class=nv>$val</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>val</span><span class=o>=</span><span class=sb>`</span>expr <span class=nv>$b</span> % <span class=nv>$a</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;b % a : </span><span class=nv>$val</span><span class=s2>&#34;</span>
</span></span></code></pre></div><h2 id=执行命令>执行命令<a hidden class=anchor aria-hidden=true href=#执行命令>#</a></h2><p>$()与 ``（反引号）都可以用于执行命令，并会将执行的结果返回，shellcheck 推荐使用第一种 $() 的方式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nv>result</span><span class=o>=</span><span class=sb>`</span>date <span class=s2>&#34;+%Y-%m-%d&#34;</span><span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>result</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>result</span><span class=o>=</span><span class=k>$(</span>date <span class=s2>&#34;+%Y-%m-%d&#34;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>result</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></div><h2 id=运算符>运算符<a hidden class=anchor aria-hidden=true href=#运算符>#</a></h2><p>关系运算符只支持数字，如果字符串为数字也可以，关系运算符包括：</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-lt</td><td>小于</td></tr><tr><td>-ge</td><td>大等于</td></tr><tr><td>-le</td><td>小等于</td></tr></tbody></table><p>条件表达式必须放在 <code>[]</code> 中，并且 <code>[</code> 的右侧，和 <code>]</code> 的左侧必须留有空格</p><p>布尔运算符列表：</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>!</td><td>非</td></tr><tr><td>-o</td><td>或 (or)</td></tr><tr><td>-a</td><td>与 (and)</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=s2>&#34;10&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>b</span><span class=o>=</span><span class=s2>&#34;3&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>c</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=si>${</span><span class=nv>a</span><span class=si>}</span> -ne <span class=si>${</span><span class=nv>b</span><span class=si>}</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;相同&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;不相同&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=si>${</span><span class=nv>a</span><span class=si>}</span> -gt <span class=si>${</span><span class=nv>b</span><span class=si>}</span> -a <span class=si>${</span><span class=nv>b</span><span class=si>}</span> -gt <span class=si>${</span><span class=nv>c</span><span class=si>}</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;a &gt; b &amp; b &gt; c&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>其他常用判断：</p><ol><li>直接在 <code>[ ]</code> 中放字符串变量 如 <code>[ ${str} ]</code> 则就是判断 <code>str</code> 这个字符串是否非空</li><li>-f 判断是否为普通文件，如：<code>[ -f $file ]</code></li><li>-d 判断是否为文件夹，如：<code>[ -d $file ]</code></li></ol><h2 id=字符串截取>字符串截取<a hidden class=anchor aria-hidden=true href=#字符串截取>#</a></h2><p>字符截取的格式：<code>${string: start :length}</code>
索引从 0 开始，可以省略 <code>:length</code> 这样就截取到最后，注意空格要空在 <code>:</code> 后，否则可能提示：bad substitution</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nv>string</span><span class=o>=</span><span class=s2>&#34;hello world&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>string</span><span class=p>: 1 : 3</span><span class=si>}</span> <span class=c1># ell</span>
</span></span><span class=line><span class=cl><span class=c1># 截取到最后</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>string</span><span class=p>:</span><span class=nv>1</span><span class=si>}</span> <span class=c1># ello world</span>
</span></span></code></pre></div><h2 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># 1. 定义数组：使用括号声明，用“空格”分隔开，也可以换行隔开</span>
</span></span><span class=line><span class=cl><span class=nv>arr</span><span class=o>=(</span><span class=m>1</span> <span class=m>2</span> 3<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>strArr</span><span class=o>=(</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;first&#34;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;second&#34;</span>
</span></span><span class=line><span class=cl><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 读取数组：通过下标读取，下标从 0 开始计算</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[0]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 * 或者 @ 读取所有元素</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>arr</span><span class=p>[*]</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 读取数组长度 读取全部元素前面加上 #</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${#</span><span class=nv>arr</span><span class=p>[*]</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${#</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 遍历下标</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=o>((</span> <span class=nv>i</span><span class=o>=</span>0<span class=p>;</span>i&lt;<span class=si>${#</span><span class=nv>strArr</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span>i++<span class=o>))</span> 
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>strArr</span><span class=p>[i]</span><span class=si>}</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># for in 遍历元素</span>
</span></span><span class=line><span class=cl><span class=k>for</span> element in <span class=si>${</span><span class=nv>strArr</span><span class=p>[*]</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$element</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 修改数组元素</span>
</span></span><span class=line><span class=cl>strArr<span class=o>[</span>0<span class=o>]=</span><span class=s2>&#34;modify&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>strArr</span><span class=p>[0]</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. 删除元素</span>
</span></span><span class=line><span class=cl><span class=nb>unset</span> arr<span class=o>[</span>1<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${#</span><span class=nv>arr</span><span class=p>[*]</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>arr</span><span class=p>[*]</span><span class=si>}</span> <span class=c1># 1 3</span>
</span></span><span class=line><span class=cl><span class=c1># ！使用 unset 要注意，这其实并不是真正删除了该元素，而只是将该元素置空，所以使用下标遍历会出问题，如下</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;数组遍历：&#34;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=o>((</span> <span class=nv>i</span><span class=o>=</span>0<span class=p>;</span>i&lt;<span class=si>${#</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span>i++<span class=o>))</span> 
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;index </span><span class=si>${</span><span class=nv>i</span><span class=si>}</span><span class=s2> -&gt; </span><span class=si>${</span><span class=nv>arr</span><span class=p>[i]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1># index 0 -&gt; 1</span>
</span></span><span class=line><span class=cl><span class=c1># index 1 -&gt; </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 解决 unset 无法真正删除的方法：重新赋值给新的数组</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;数组遍历：&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>arr</span><span class=o>=(</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=o>((</span> <span class=nv>i</span><span class=o>=</span>0<span class=p>;</span>i&lt;<span class=si>${#</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span>i++<span class=o>))</span> 
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;index </span><span class=si>${</span><span class=nv>i</span><span class=si>}</span><span class=s2> -&gt; </span><span class=si>${</span><span class=nv>arr</span><span class=p>[i]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1># index 0 -&gt; 1</span>
</span></span><span class=line><span class=cl><span class=c1># index 1 -&gt; 3</span>
</span></span></code></pre></div><h2 id=判断语句>判断语句<a hidden class=anchor aria-hidden=true href=#判断语句>#</a></h2><p>使用 <code>if</code> 和 <code>fi</code> 定义判断的边界，使用 <code>then</code> , <code>elif</code> , <code>else</code> 定义条件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>a</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>b</span><span class=o>=</span><span class=m>20</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=nv>$a</span> <span class=o>==</span> <span class=nv>$b</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;相等&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;不相等&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=nv>$a</span> <span class=o>==</span> <span class=nv>$b</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;相等&#34;</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=o>[</span> <span class=nv>$a</span> -lt <span class=nv>$b</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;a 小于 b&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;其他情况&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><p>调用函数时，我们可以传入参数，可以通过 <code>$n</code> 来获取参数，这里的 <code>n</code> 表示 需要取的参数的索引，当n>=10时，需要使用${n}来获取参数</p><p><code>$#</code> 传递给函数的参数个数，<code>$*</code> 和 <code>$@</code> 显示所有传递给函数的参数，<code>$?</code> 表示函数的返回值，也可以用于获取上一个命令的退出状态，执行成功会返回 0，失败返回 1</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 定义函数</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl>funWithParam<span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;参数个数：</span><span class=nv>$#</span><span class=s2>&#34;</span>  <span class=c1># 参数个数：11</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;传递给函数的所有参数：</span><span class=nv>$*</span><span class=s2>&#34;</span> <span class=c1># 传递给函数的所有参数：1 2 3 4 5 6 7 8 9 34 73</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=c1># 1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 超过 9 的参数需要用 ${} 接收参数，否则直接显示数值</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$10</span><span class=s2>&#34;</span> <span class=c1># 10</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>11</span><span class=si>}</span><span class=s2>&#34;</span> <span class=c1># 73  </span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 调用函数：函数名后面直接跟上参数</span>
</span></span><span class=line><span class=cl>funWithParam <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span> <span class=m>6</span> <span class=m>7</span> <span class=m>8</span> <span class=m>9</span> <span class=m>34</span> <span class=m>73</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$?</span><span class=s2>&#34;</span> <span class=c1># 0</span>
</span></span></code></pre></div><h2 id=输入输出重定向>输入输出重定向<a hidden class=anchor aria-hidden=true href=#输入输出重定向>#</a></h2><p>使用 <code>></code> 将应该输出到终端上的数据重定向输出到文件，<code>></code> 默认为覆盖文件，使用 <code>>></code> 追加写入文件
使用 <code>&lt;</code> 将默认从键盘输入的数据，定向为从文件输入</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># who 命令用于显示系统中有哪些使用者正在上面</span>
</span></span><span class=line><span class=cl><span class=c1># 将结果输入 who.txt</span>
</span></span><span class=line><span class=cl>who &gt; who.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># wc -l 作用是计算文本行数</span>
</span></span><span class=line><span class=cl>wc -l &lt; who.txt
</span></span></code></pre></div><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ol><li>标准输入 (stdin)：stdin 的文件描述符为 0，Unix 程序默认从 stdin 读取数据</li><li>标准输出 (stdout)：stdout 的文件描述符为 1，Unix 程序默认向 stdout 输出数据</li><li>标准错误输出 (stderr)：stderr 的文件描述符为 2，Unix 程序会向 stderr 流中写入错误信息</li></ol><p>所以一般我们后台启动应用并且输出日志文件都使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nohup java -jar xxx.jar &gt;&gt; nohup.log  2&gt;<span class=p>&amp;</span><span class=m>1</span> <span class=p>&amp;</span> 
</span></span></code></pre></div><p><code>nohup</code>：(no hang up) 保证在<strong>退出帐户</strong>或者<strong>关闭终端</strong>之后继续运行相应的进程
<code>>> nohup.log</code>：将 <code>java -jar xxx.jar</code> 的输出追加到 <code>nohup.log</code> 文件
<code>2>&amp;1</code>：将 <code>java -jar xxx.jar</code> 的 标准错误输出 也重定向到 标准输入
<code>&</code>：让进程在后台运行</p><p>默认情况下，command > file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。
如果希望 stderr 重定向到 file，可以这样写：</p><h2 id=坑梳理>坑梳理<a hidden class=anchor aria-hidden=true href=#坑梳理>#</a></h2><ol><li>变量赋值时，变量名命名规则和其他语言类似，<strong>注意变量赋值时 <code>=</code> 两边不能有空格</strong></li><li>数组 unset 元素，并不是真正的移除元素</li><li>获取参数时，当 n>=10 时，需要使用${n}来获取参数</li></ol><h2 id=常见的特殊-shell-环境变量>常见的特殊 Shell 环境变量<a hidden class=anchor aria-hidden=true href=#常见的特殊-shell-环境变量>#</a></h2><ul><li><code>$$</code> 表示当前Shell进程的ID，即pid</li><li><code>$0</code> 表示当前脚本的绝对路径</li><li><code>$#</code> 传递给脚本或函数的参数个数</li><li><code>$n</code> 传递给脚本或函数的参数</li><li><code>$?</code> 上个命令的退出状态</li><li><code>$*</code> 和 <code>$@</code> 传递给脚本或函数的所有参数</li><li><code>$n</code> n 代表 1~9 其中任意一个数字，传递给脚本或函数该位置的参数</li></ul><p><code>$*</code> 和 <code>$@</code> 区别：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>function</span> asterisk <span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;\&#34;\$*\&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> var in <span class=s2>&#34;</span><span class=nv>$*</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$var</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>done</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>function</span> mail <span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;\&#34;\$@\&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> var in <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$var</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>done</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>asterisk a b c 
</span></span><span class=line><span class=cl>mail a b c
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=s2>&#34;</span><span class=nv>$*</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>a b c
</span></span><span class=line><span class=cl><span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>a
</span></span><span class=line><span class=cl>b
</span></span><span class=line><span class=cl>c
</span></span></code></pre></div><p>当 <code>$*</code> 和 <code>$@</code> 直接使用效果相同，都是接收一份数据如上所示的例子，接收到的就是：<code>a b c</code>，一份数据，以空格隔开。加了双引号后 <code>"$@"</code> 会将每个参数都当成一份独立的数据</p><h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1><p><a href=https://zhuanlan.zhihu.com/p/199187317>VS code 打造 shell脚本 IDE</a>
<a href=https://blog.csdn.net/qq_37164975/article/details/106181500>#!/bin/bash 和 #!/usr/bin/env bash 的区别</a>
<a href=https://zh.wikipedia.org/wiki/%E5%A4%96%E5%A3%B3%E8%84%9A%E6%9C%AC>Shell脚本 - wiki</a>
<a href=https://www.zhihu.com/question/41441630>Linux跑脚本用sh和./有什么区别？</a>
<a href=https://blog.csdn.net/kouryoushine/article/details/91361718>执行shell脚本三种方法的区别：（sh、exec、source）</a>
<a href=http://c.biancheng.net/cpp/view/2739.html>Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数</a>
<a href=https://wiki.jikexueyuan.com/project/13-questions-of-shell/exec-source.html>exec 跟 source 差在哪？</a>
<a href=https://www.coder.work/article/2568469>bash - 如何删除数组中的元素，然后在 Shell 脚本中移动数组？</a>
<a href=https://blog.csdn.net/u010889390/article/details/50575345>nohup /dev/null 2>&amp;1 含义详解</a>
<a href=https://www.cnblogs.com/chengd/p/7803664.html>Linux—shell中$(( ))、$( )、``与${ }的区别</a>
<a href=http://c.biancheng.net/view/807.html>Shell $*和$@的区别</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronlinv.github.io/posts/%E9%A9%AC%E6%96%87%E6%9F%AF%E6%9E%97%E6%96%AF%E7%9A%84%E6%95%99%E8%82%B2%E4%B9%8B%E9%81%93%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/><span class=title>« Prev</span><br><span>《马文 柯林斯的教育之道》阅读笔记</span>
</a><a class=next href=https://aaronlinv.github.io/posts/%E5%BC%80%E6%BA%90%E5%85%8D%E8%B4%B9-%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/><span class=title>Next »</span><br><span>开源≠免费 常见开源协议介绍</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>