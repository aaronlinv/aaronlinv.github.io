<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Aaron Lin</title>
<meta name=keywords content="Blog,Web,Technology"><meta name=description content="Less is more"><meta name=author content><link rel=canonical href=https://aaronlinv.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://aaronlinv.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronlinv.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronlinv.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronlinv.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aaronlinv.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://aaronlinv.github.io/index.xml><link rel=alternate type=application/json href=https://aaronlinv.github.io/index.json><link rel=alternate hreflang=en href=https://aaronlinv.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://aaronlinv.github.io/"><meta property="og:site_name" content="Aaron Lin"><meta property="og:title" content="Aaron Lin"><meta property="og:description" content="Less is more"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aaronlinv.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Aaron Lin"><meta name=twitter:description content="Less is more"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Aaron Lin","url":"https://aaronlinv.github.io/","description":"Less is more","logo":"https://aaronlinv.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronlinv.github.io/ accesskey=h title="Aaron's Blog (Alt + H)">Aaron's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aaronlinv.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://aaronlinv.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aaronlinv.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aaronlinv.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>为什么 AI 时代更应该 Learn in Public</h2></header><div class=entry-content><p>TL;DR Learn in Public 强调将学习到的知识 分享到公共空间，相较于纯输入式的学习有诸多好处。AI 工具极大降低了信息检索、整理、概括的门槛，使得输入信息更容易，但对我们真正掌握知识的帮助仍然有限，所以我们更需践行要像 Learn in Public 这样能提供 有效输出 的学习方式
AI 工具大大降低了信息检索、整理和概括的门槛，使得获取信息更加便捷，但对我们真正掌握知识的帮助仍然有限。因此我们更需要践行像 Learn in Public 这样重视 有效输出 的学习方式
为什么会想到这个话题 偶然间看到 Owen 发的贴子：
看到一个说法：笔记是一种无限游戏，没有结果，只有过程；而博客是一种有限游戏，因为它产出了完成的作品：博文。这说明我们不能当一个完美主义者，只在脑海或草稿箱中保留想法，我们应该尽可能完成作品，公开它，然后不断的练习这个过程。
我更坚定那个想法了：做一个默认设计为公开的笔记软件
看到这个贴子，马上联想到了 Learn in Public 这个概念，开始思考自己的这些年记笔记的方式，意识到了原来的方式可能存在一些问题，于是开始尝试践行 Learn in Public，将自己学习的一些东西写成博客、用学到的知识做一个有意义的产品等等。经过了这段时间的实践，再结合上自己日常使用 AI 的一些感受和想法，很自然地就想到了这个话题
什么是 Learn In Public 在 swyx 发布 Learn In Public 后，这个概念变得更加流行。Learn in Public 强调的是 将学到的东西分享到公共空间
常见的 Learn In Public 的方式，例如：
撰写博客、教程 在会议上发言 在问答社区提问或者回答 制作并发布视频 与之相对的 Learn in Private 侧重的是 消费内容，例如：
个人笔记 阅读书籍 阅读源码 订阅 GitHub 的 Repos 和 Issues，观察其他的人实践 为什么需要 Learn in Public Learn in Public 是一个输出的过程，促进知识的整理、理解、求证，帮助我们拓宽对某些 知识理解的边界 公共空间能提供 反馈，反馈可以产生激励、也可以修正我们努力的方向 有助于 筛选 所要学习的东西，Learn In Public 会花费大量精力，它能促使我们评估即将学习的内容是否值得 对抗完美主义，先有产出，走出第一步再根据反馈 持续迭代，而不是止步不前 很多的知识都来自 Public ，所以没有什么好藏着掖着，大部分的成果可能都是站在巨人的肩膀上 为什么 AI 时代更应该 Learn in Public 在 AI 的推动下，知识获取已经实现了质的飞跃，但对我们真正掌握知识的帮助仍然有限，所以我们更应该 Learn in Public，做更多的 有效输出
...</p></div><footer class=entry-footer><span title='2024-05-15 08:56:33 +0800 +0800'>May 15, 2024</span></footer><a class=entry-link aria-label="post link to 为什么 AI 时代更应该 Learn in Public" href=https://aaronlinv.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88-ai-%E6%97%B6%E4%BB%A3%E6%9B%B4%E5%BA%94%E8%AF%A5-learn-in-public/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>理解前端工程化</h2></header><div class=entry-content><p>最初对前端的观感：眼花缭乱，各种各样的工具链以及其对应的配置文件、VS Code 插件，各种技术百家争鸣，选择众多。后来才理解前端不同于后端，后端代码的运行环境相对可控，而前端代码运行在用户设备上，所以需要兼容不同的环境，而很大一部分的工具、配置都是解决兼容性的问题
TL;DR 工程化的目的：降低开发成本提高开发效率 方式：解决前端三大件（HTML, CSS, JS）存在的问题并对其进行增强，JS 通过 Babel 而 CSS 可以通过 Sass, Less, PostCSS 等工具实现进行增强，并且保证输出向后兼容的的 JS 或 CSS 代码
模块化、包管理 分解聚合：拆分复杂任务，降低复杂度（分而治之）
模块化解决 问题：1. 全局污染 2. 依赖管理 等等 JS 模块化标准（常用）：1. CommonJS （Node 标准）2. ES modules（JavaScript 官方标准模块化方案） 实现：1. 浏览器只支持 ESM 2. Node 和 构建工具 上面两种标准都支持
包 (package) 管理：npm（Node.js的标准包管理器），还有其他的 pnpm 和 yarn 等
JS 工具链 JS 语言本身一直都在繁荣地发展，经常出现新的 API 和 语言特性，但是用户的运行环境（浏览器、Node等）的版本可能是五花八门的，可能会导致报错、兼容性等的问题，所以最朴素的解决方式就是把 JS 都转换为向后兼容的老版本 JS 代码。前端的运行环境更多的是在用户这边，这点不同于后端能比较自由地调整服务器运行环境，这可能就是前端缝缝补补的原因吧，修补主要有的方式：
新 API：使用 Polyfill（填充物），为其实现缺少的 API，例如 core-js 库，就实现了 Array 的 flatMap 方法，这样在旧版本的 Node 环境，也可使用该方法 新语法：例如 Promise，对于这样的语法糖，就无法直接为其编写方法，需要转换代码，有点类似翻译，通过 regenerator 库可以将含有 Promise 的代码转换为向后兼容的代码 有很多这样的库用于解决某个特定的兼容性问题，一个个导入很麻烦，所以就有了 Babel，可以通过 Babel 的插件整合这些转换代码的库，需要安装对应的 Babel 插件依赖 并在 babel.config.js 中配置 plugins。这样还是很麻烦，所以我们可以直接使用 Babel 的预设，其中最常用的就是：@babel/preset-env，安装依赖以后完成以下的 babel.config.js 配置，即可开箱即用：
...</p></div><footer class=entry-footer><span title='2024-04-28 08:58:33 +0800 +0800'>April 28, 2024</span></footer><a class=entry-link aria-label="post link to 理解前端工程化" href=https://aaronlinv.github.io/posts/%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaScript 事件循环 动画演示</h2></header><div class=entry-content><p>在前端代码中很经常看到使用 setTimeout(fn, 0)，如下面代码所示，乍一看很多余，但是移除了可能会出现一些奇奇怪怪的问题。要解释这个就需要理解 事件循环（Event Loop），下面会通过一些例子和动画来辅助理解事件循环
setTimeout(() => { // 调用一些方法 }, 0) 为什么使用事件循环 JS 是单线程的（浏览器和 Node则是多线程的），为了避免 渲染主线程 阻塞，需要异步，事件循环 是异步的实现方式
浏览器在一个渲染主线程中运行一个页面中的所有 JavaScript 脚本，以及呈现布局，回流，和垃圾回收。为了避免 同步 的执行方式导致渲染主线程阻塞，使得页面卡死，所以浏览器采用异步的方式：渲染主线程将任务交给其他线程去处理，自身 立即结束 任务的执行，转而执行后续代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入到对应的消息队列的末尾排队，等待渲染主线程调度执行
流程：
渲染主线程执行全局 JS，需要异步的任务放到对应的队列，如果是 setTimeout 则会有线程计时，到了指定时间会将任务放入 延时队列（并非立即执行） 渲染主线程为空时，按队列的优先级依次选择队列（最先执行微队列的任务），依次按顺序执行各个队列的任务 任务没有优先级，而消息队列有优先级，不同任务分属于不同队列：参考 W3C 规范。微队列优先级最高，接着是交互队列然后才是延时队列
常见队列：
微队列（microtask）：⽤户存放需要最快执⾏的任务，优先级「最⾼」，通过 Promise.resolve().then() ⽴即把⼀个函数添加到微队列 交互队列：⽤于存放⽤户操作后产⽣的事件处理任务，优先级「⾼」 延时队列：⽤于存放计时器到达后的回调任务，优先级「中」 事件循环 下面例子来自于：《WEB前端大师课》，大块的文字描述相对没那么直观，所以用 Keynote 做了 gif 方便理解（如果有更好的做 gif 的方式可以留言告诉我）
1. JS阻碍页面渲染 JS 修改了 DOM 后，并不会马上显示在页面上，需要进行 绘制 后才会显示页面变更
&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head>&lt;/head> &lt;body> &lt;h1>初始h1&lt;/h1> &lt;button>change&lt;/button> &lt;script> var h1 = document.querySelector('h1'); var btn = document.querySelector('button'); function delay(duration) { var start = Date.now(); while (Date.now() - start &lt; duration) {} } btn.onclick = function () { h1.textContent = '修改h1 textContent'; delay(3000); }; &lt;/script> &lt;/body> &lt;/html> ...</p></div><footer class=entry-footer><span title='2024-04-17 07:49:33 +0800 +0800'>April 17, 2024</span></footer><a class=entry-link aria-label="post link to JavaScript 事件循环 动画演示" href=https://aaronlinv.github.io/posts/javascript-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何弄懂复杂项目</h2></header><div class=entry-content><p>先跑起来，通过文档和实践熟悉业务流程
这一步可以通过看官方文档开始，要注意的是一些项目是 更新先于文档 的，比如新版本启动方式有变更，但是文档还没更新。跟着文档不一定能把项目跑起来，需要借助 GitHub Issue 或者是 Slack 这样的工具以获取即时的帮助
看测试，通过测试了解流程
如果是开源项目，可以通过 GitHub Action 快速了解需要哪些依赖、如何快速运行测试，便于在本地运行测试，通过这些集成测试可以快速弄懂业务主线
通过 debug 高效快速地梳理流程
通过断点可以一步一步跟踪程序的运行，可以比较直观地看调用栈、变量等等的
对于一些无法本地调试的项目来说，我们可以退而求其次，断点它的测试，这也是一个很有效的方法
画图：降低复杂度
很多项目会使用一些比较优雅的设计或是引入一些抽象层，这样代码读起来就会跳来跳去，层级深的话就很容把人给绕晕了
可以用 draw.io 或者 excalidraw 等工具，根据实际情况画一画 活动图、时序图等
提出具体的问题，带着问题看项目
如果只是盲目地看项目代码，可能看完还是一头雾水，但是如果能提出一个具体问题，或是带着一个需求去看，效果就会好得多
比如我提出问题：“某个任务在集群内是如何完成的？”，我可能会先去找到该任务的创建入口，然后顺藤摸瓜，找到任务的调度逻辑，顺着 happy path 找到下发任务的逻辑，再找到 Woker 的处理逻辑，这样就能弄懂整个调度流程
最后如果能用 一句话 回答提出的问题，那可能能说明你对这个问题涉及的知识已经有了一个比较好的理解
英语很重要
大多数项目的注释、日志等的都是英文，看懂这些能极大提高效率</p></div><footer class=entry-footer><span title='2024-04-07 08:31:33 +0800 +0800'>April 7, 2024</span></footer><a class=entry-link aria-label="post link to 如何弄懂复杂项目" href=https://aaronlinv.github.io/posts/%E5%A6%82%E4%BD%95%E5%BC%84%E6%87%82%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IDEA （任意 JetBrains IDE）拆分先前 commit</h2></header><div class=entry-content><p>最近在合并上游代码，遇到了一个问题：某个 commit 杂糅了几个不同的特性修改，这可能会导致 rebase 上游代码时需要再对该 commit 进行额外的代码冲突处理
解决方法：合并上游分支前，拆分杂糅的 commit，并将其中不同的特性修改合并（Squash）回相关的 commit。可以直接通过命令行进行操作，可以参考：Break a previous commit into multiple commits。也可以通过 JetBrains 家内置的 Git 进行操作，下面会介绍 IDEA 图形化操作的方法
非先前 commit 的拆分 对于刚提交的 commit，要拆分多个 commit 是非常容易的，因为我们只要 soft reset commit，将 commit 内容撤销回至 暂存区，就可以随意提交 commit
如果对于 soft reset 不太了解，可以参考我之前的博客：Git 中的回退操作：reset 和 revert 先前 commit 的拆分 先前 commit 指的是：在目标 commit 后已经有了若干个 commit。它无法直接通过 soft reset 进行拆分，因为这样会丢失后续的 commit，如下图，我们需要拆分 B commit，我们就无法直接使用 soft reset ，因为这样会丢失 C 和 D commit 的修改
所以我们需要使用 rebase，具体步骤：
在 交互式 (interactive) rebase 中将 B 标记为 edit，这时 B 后面的 commit 会被暂时隐藏起来 使用 soft reset 将 B 撤销回 暂存区 将 B 的修改内容分多个 commit 提交 B1 和 B2 使用 rebase 的 continue 将刚才隐藏的 C 和 D 恢复回来，需要注意的是：因为之前的 commit 记录已经改变了，所以这时的 C 和 D 已经与原来的 commit 记录不相同，故标记为 C' 和 D' ...</p></div><footer class=entry-footer><span title='2024-03-27 08:50:33 +0800 +0800'>March 27, 2024</span></footer><a class=entry-link aria-label="post link to IDEA （任意 JetBrains IDE）拆分先前 commit" href=https://aaronlinv.github.io/posts/idea-%E4%BB%BB%E6%84%8F-jetbrains-ide%E6%8B%86%E5%88%86%E5%85%88%E5%89%8D-commit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer</h2></header><div class=entry-content><p>上一节：SpringBoot 测试实践 - 2：单元测试与集成测试
编写测试的时候，我们必须保证外部依赖行为一致，也需要模拟一些边界条件，所以我们需要使用 Mock 来模拟对象的行为。SpringBoot 提供了 @MockBean 和 @SpyBean 注解，可以方便地将模拟对象与 Spring 测试相结合，简化测试代码的编写
@MockBean @MockBean 是 Spring Boot Test提供的注解，用于在 Spring Boot 测试中创建一个模拟的 Bean 实例，并注入到测试类中的依赖项中。使用 Mock 可以控制被 Mock 对象的行为：自定义返回值、抛出指定异常等，模拟各种可能的情况，提高测试的覆盖率
@SpringBootTest @RunWith(SpringRunner.class) public class MyServiceTest { @MockBean private ExternalDependency externalDependency; @Autowired private MyService myService; @Test public void testSomeMethod() { // 定义外部依赖的行为 Mockito.when(externalDependency.someMethod()).thenReturn("Mocked Result"); // 调用被测试类的方法 // 被测方法内部调用了 ExternalDependency 的 someMethod 方法 String result = myService.someMethod(); // 验证外部依赖的方法是否被调用 Mockito.verify(externalDependency).someMethod(); // 断言结果 assertEquals("Mocked Result", result); } } 需要注意的是：使用了 @MockBean，会创建完全模拟的对象，它完全替代了被模拟的 Bean，并且所有方法的调用都被模拟。对于未指定行为的方法，返回值如果是基本类型则返回对应基本类型的默认值，如果是引用类型则返回 null
...</p></div><footer class=entry-footer><span title='2023-08-24 08:40:33 +0800 +0800'>August 24, 2023</span></footer><a class=entry-link aria-label="post link to SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer" href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---3@mockbean@spybean-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6testcontainer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot 测试实践 - 2：单元测试与集成测试</h2></header><div class=entry-content><p>上一节：SpringBoot 测试实践 - 1：常用的工具 下一节：SpringBoot 测试实践 - 3：@MockBean、@SpyBean 、提升测试运行速度、Testcontainer
单元测试 vs. 集成测试 只编写单测，无法测试方法之间的集成情况，而且某些需求可能会修改多个方法，这可能会影响方法对应的单测，涉及到大量的相关单测的修改，这样的维护成本很高
可以把重心放在完善集成测试上，专注从外部判断程序是否符合预期。对于一些非常重要的方法，增加单元测试可以减轻集成测试排查错误的难度
先导知识可以参考上一节：SpringBoot 测试实践 - 1：常用的工具
SpringBootTest 和 MockMvc 进行集成测试 从 Spring Boot 2.1 开始 @ExtendWith({SpringExtension.class}) 作为元注解包含在 Spring Boot 测试注解中，例如 @DataJpaTest、@WebMvcTest 和 @SpringBootTest，所以我们不用重复添加 @ExtendWith({SpringExtension.class}) 注解
HelloWorld 测试 使用 SpringBoot 一个简单的 HelloWorld 案例，通过 @SpringBootTest 可以在测试环境中加载整个 Spring 应用程序上下文，@SpringBootTest 注解会扫描应用程序的主配置类，并加载所有的 Bean（包括依赖的 Bean）到测试上下文中。这样，测试中就可以使用完整的 Spring 功能，包括依赖注入、AOP、事务管理等
使用 @AutoConfigureMockMvc 自动配置 MockMvc，通过 MockMvc 可以模拟 HTTP 请求，并对响应的结果进行断言和验证
import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; @AutoConfigureMockMvc @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class MySpringBootTest { @Autowired private MockMvc mockMvc; // 注入 MockMvc @Test public void testHelloWorld() throws Exception { // 发送 GET 请求 mockMvc.perform(MockMvcRequestBuilders.get("/hello") // 设置请求头 .accept(MediaType.APPLICATION_JSON)) // 验证响应状态码 .andExpect(MockMvcResultMatchers.status().isOk()) // 验证响应内容 .andExpect(MockMvcResultMatchers.content().string("Hello, World!")); } } 涉及数据层的测试：H2 部分操作涉及到数据库，一般都会引入数据层的依赖，在对应的 HTTP 请求后，对响应体和数据库数据进行断言和验证，就像下面这样：
...</p></div><footer class=entry-footer><span title='2023-08-22 08:48:33 +0800 +0800'>August 22, 2023</span></footer><a class=entry-link aria-label="post link to SpringBoot 测试实践 - 2：单元测试与集成测试" href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot 测试实践 - 1：常用的工具</h2></header><div class=entry-content><p>下一节：SpringBoot 测试实践 - 2：单元测试与集成测试
我自己接触到的一些商业或是开源的基于 SpringBoot 项目，它们大部分是没有测试代码的，test 文件夹只有脚手架初始化生成的那个测试类，跟不同的开发聊到这个话题，发现他们中的大部分没有写测试的习惯，或者是觉得写测试代码麻烦，主要还是依赖测试工程师做黑盒的测试。只做黑盒测试的话有一定的的局限性，一些边界的条件可能就覆盖不到，而且相对来说人也比较容易出错、遗漏。而测试代码能解决其中很大一部分的问题，利用好单元测试和集成测试在某些情况下相对于直接通过 UI 进行测试是要更方便、节省时间的，所以想通过几篇博客来分享一下自己的测试实践
为什么要写测试（优点） 覆盖更多的边界条件，且随时都可以运行测试代码（一劳永逸） 缩小测试范围：测试某个方法只需要运行对应的测试代码，而不需要运行整个项目通过请求接口进行测试 对重构更友好，可以随时重构有集成测试的代码，不用担心打破原有的代码 其他人也可以通过测试快速地理清楚对应被测代码的主线逻辑（类似文档的作用，特别是复杂代码，通过测试能快速理解上手） 写测试的过程，给自己一个新的视角去审视代码结构的设计，有助于改善代码设计 当然代码方式的测试也并非完美无缺：测试代码增加编写和维护的成本，同时一些外部依赖也需要通过 Mock 的方式实现，这些都提高了整个测试编写的门槛。也倒逼我们思考更好地组织代码，减少依赖
另一个方面：测试对于重构也是至关重要的，随着对业务的理解越来越深刻，可以重构代码，抽象出了一些共性的逻辑，优化代码结构，但是如果没有相关测试，面对着旧代码就只能望而却步了
测试工具：JUnit 5, AssertJ，Mockito spring-boot-starter-test 自带常用的测试工具：JUnit5、Assertj、Mockito，可以直接使用
JUnit5 Junit 5 包含：
JUnit Platform：Test Engine Jupiter：编程模型和拓展模型 Vintage：兼容老版本 JUnit 4 和 5 使用的包有所不同
// JUnit 4 import org.junit.Test; import static org.junit.Assert.assertEquals; // JUnit 5 import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; 如果不考虑兼容 JUnit 4 的测试，我们可以直接在依赖中直接排除 JUnit 4 的依赖，这样也可以避免在使用的时候错误地引入 JUnit 4 的包
...</p></div><footer class=entry-footer><span title='2023-08-21 09:00:33 +0800 +0800'>August 21, 2023</span></footer><a class=entry-link aria-label="post link to SpringBoot 测试实践 - 1：常用的工具" href=https://aaronlinv.github.io/posts/springboot-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5---1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>快速重拾 Tmux</h2></header><div class=entry-content><p>Tmux 是一个 Linux （Mac OS也支持）下的终端复用器，相较于 Screen 更为强大，但快捷键和操作逻辑也更复杂，一段时间不用，就很容易忘记相关的命令和快捷键。本文旨在通过一个简单的场景，快速重拾 Tmux
Tmux 通常用来保持会话（session），如果我们通过 ssh 连接服务器处理打包等的耗时操作，那么网络波动可能会导致连接断开，使得操作失败，使用 Tmux 会话会被保持，任务依然会继续，我们可以随时恢复会话
Tmux 另一个常用的功能是分屏，快速地创建 Window 和 Pane，方便地在不同的任务间穿梭
修改配置 vim ~/.tmux.conf # 将默认修饰键（prefix） ctrl + b 修改：ctrl + a set -g prefix C-a unbind C-b bind C-a send-prefix # 激活鼠标模式 set-option -g -q mouse on # 修改分屏快捷键 # 左右分屏 bind h split-window -h # 上下分屏 bind v split-window -v # 可以取消默认的分屏快捷键映射 # unbind '"' # unbind % # 将 tmux 的复制模式键绑定设置为 vi 模式 setw -g mode-keys vi # windows 和 panes 的序号从 1 开始 set -g base-index 1 setw -g pane-base-index 1 重新加载 Tmux 配置文件
...</p></div><footer class=entry-footer><span title='2023-04-13 08:43:33 +0800 +0800'>April 13, 2023</span></footer><a class=entry-link aria-label="post link to 快速重拾 Tmux" href=https://aaronlinv.github.io/posts/%E5%BF%AB%E9%80%9F%E9%87%8D%E6%8B%BE-tmux-/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>32 位计算机时间戳溢出的思考 —— 整数的二进制表示</h2></header><div class=entry-content><p>Year 2038 problem 在 CS50 第 01 讲：C语言 中，提到了一个很有趣的问题：Year 2038 problem，这个问题指的是：一些使用 32 位来存储时间戳的计算机，在 2038 年，可能会出现整数溢出的问题，导致计算机的时间倒退回 1901 年
时间戳 指得是：UTC 1970 年 1 月 1 日 0 时 0 分 0 秒到现在经历的秒数，用时间戳就可以表示当前的时间
为什么会出现这个问题呢？因为时间总是在流逝，所以每时每刻时间戳都在增加，但是 32 位的存储空间是有限的，总有一天会超出所能存放的最大值，而反直觉的是在超过了最大值后并不是归零（时间戳回到 1970），而是倒退到了更前的 1901 年，对应下面的表格我们就可以更直观地看到几个时间戳对应的具体时间
时间戳 对应的 UTC 时间 0 1970-01-01 00:00:00 2147483647 （32 位 int 最大整数值：2^31 - 1） 2038-01-19 03:14:07 -2147483648 （32 位 int 最小整数值：-2^31） 1901-12-13 20:45:52 可以看到当存储超过位数能容纳的最大值时，该值会从一个非常大的正数突然变为一个非常小的负数，所以导致了日期回到了 1901 年
原码、反码、补码 计算机底层是通过二进制的方式存储整数，两者转换可以参考文章：二进制和十进制之间的互相转换，除了整数的大小，还需要存储的是整数的正负，一般首位（最高位）用于存储正负，0 代表该整数为正数，1 代表该数为负数，将一个整数对应的二进制数转化为计算机存储的二进制数，这个变换就是《数字逻辑电路》里面经常提到的原码、反码、补码转化。注意：正数和 0 的原码、反码、补码相同，负数则需要转换
我们回顾一下，以 4 位二进制表示的整数举例：0 的原反补码都是 0000，1 的原反补码都是 0001，而 -1 该如何表示呢？
...</p></div><footer class=entry-footer><span title='2022-11-09 08:32:33 +0800 +0800'>November 9, 2022</span></footer><a class=entry-link aria-label="post link to 32 位计算机时间戳溢出的思考 —— 整数的二进制表示" href=https://aaronlinv.github.io/posts/32-%E4%BD%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%97%B6%E9%97%B4%E6%88%B3%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83--%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://aaronlinv.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://aaronlinv.github.io/>Aaron Lin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>