<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="面向过程与面向对象如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写好，而面向对象就像是去饭店吃饭，告诉服务员吃什么就好了，而不用考虑菜是怎么做的，只要吃就好了

面向过程
面向过程性能比面向对象高，面向对象调用类需要实例化，资源开销大，而面向对象则不需要


面向">


<link rel="alternate" href="/atom.xml" title="Aaron Lin" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>Java笔记-面向对象 - Aaron Lin</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->


<!-- <link rel="shortcut icon" href="/favicon.png"> -->

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/css/style.css">
<!-- 谷歌 Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-153099566-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-153099566-1');
</script>


<nav class="main-nav">
	
	    <a href="/">← 主页</a>
	
	
	    <a href="/about/">关于</a>
	
	    <a href="/archives/">归档</a>
	
	<a class="cta" href="/rss2.xml" data-no-instant>订阅</a>
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>Java笔记-面向对象</h1>
        
        <h2 class="headline">Dec 25 2019
        
            
            <a href="/categories/Java笔记/#Java笔记">Java笔记</a>
        
        </h2>
    </header>
</article>
<section id="post-body"><h4 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h4><p>如果用吃饭举例，面向过程就是把从买菜、洗菜、切菜、烹饪、装盘、吃饭、洗碗等的步骤都写好，而面向对象就像是去饭店吃饭，告诉服务员吃什么就好了，而不用考虑菜是怎么做的，只要吃就好了</p>
<ul>
<li>面向过程<ul>
<li>面向过程性能比面向对象高，面向对象调用类需要实例化，资源开销大，而面向对象则不需要</li>
</ul>
</li>
<li>面向对象<ul>
<li>易维护、易复用、易扩展，可以设计出低耦合的系统</li>
</ul>
</li>
</ul>
<p>面向对象就像是盖浇饭，饭和菜分离可维护性好，耦合程度低，可根据需求更改饭或者菜，而不像蛋炒饭，蛋和饭杂糅在一起，想替换其中某一个都非常困难</p>
<h4 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h4><p>封装：去饭店吃饭，你并不知道饭菜的具体做法，但是你可以通过服务员来点菜，得到点的饭菜<br>继承：父亲有钱，儿子可以继承父亲的财产<br>多态：亲戚结婚，邀请函上写的是你的父亲的名字，但实际上可以是你或你的妹妹去参加</p>
<ul>
<li>封装：封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能</li>
<li>继承：当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员</li>
<li>多态：多态是可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征</li>
</ul>
<h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>对象：可以是一个人，具有特性如：身高、体重，有行为如：跑、跳<br>类：把具有共同特征的对象抽象出一个类，张三李四都属于人类<br>实例化：就是根据某一个类的特征去塑造一个该类的对象</p>
<ul>
<li>对象（object）定义：包含特性和行为的一个实体，对象也称为实例（instance）</li>
<li>类：把具有相同“特性”和“行为”的多个对象的抽象就是类</li>
<li>实例化：把类具体到某一个对象上面，该对象有具体的什么的状态特征和什么行为</li>
</ul>
<h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>注意点</p>
<ol>
<li>若类使用public修饰，则当前所在的文件名必须和类名相同</li>
<li>类型必须符合标识符的命名规范（使用名词，首字母大写）</li>
</ol>
<h4 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h4><p>JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器</p>
<ul>
<li>方法区：存放程序中唯一的元素：class字节码文件、static变量</li>
<li>栈：每调用一个函数，就创建一个栈帧，加入虚拟机栈，调用结束就出栈</li>
<li>堆：所有new出来的东西</li>
</ul>
<h4 id="方法栈帧"><a href="#方法栈帧" class="headerlink" title="方法栈帧"></a>方法栈帧</h4><p>栈特点：先进后出（类似弹夹）<br>写一个sum方法，再写一个main方法，在main中调用sum方法<br>执行过程：</p>
<ul>
<li>执行main方法，main方法对应一个栈帧入栈，里面包含main的成员变量</li>
<li>调用sum方法，sum方法栈帧入栈，里面包含sum的成员变量</li>
<li>调用sum方法结束，sum方法出栈，sum方法成员变量清除</li>
<li>main方法结束，main方法出栈，程序执行结束</li>
</ul>
<h4 id="堆与数组初始化"><a href="#堆与数组初始化" class="headerlink" title="堆与数组初始化"></a>堆与数组初始化</h4><p>main方法栈帧入栈</p>
<ol>
<li>声明int类型的数组ages int[]ages；</li>
<li>在堆中初始化数组 new int[]{10，20，30}；</li>
<li>把被初始数组的地址赋值给ages变量<br>main方法栈帧出栈</li>
</ol>
<p>GC垃圾回收机制：Java自动垃圾回收机制<br>如果给一个数组变量赋了新的数组，就是把新数组的地址赋值给变量<br>原来堆中的数组，就没被引用，等待被回收</p>
<h4 id="对象堆内存分析"><a href="#对象堆内存分析" class="headerlink" title="对象堆内存分析"></a>对象堆内存分析</h4><p>方法区：存放类的class字节码文件（包括方法，常量，static变量类的描述信息）<br>Person类内存分析</p>
<ul>
<li>Person.class 存放在方法区</li>
<li>main方法栈帧入栈</li>
<li>new一个具体Person，堆里有了一个Person对象</li>
<li>将堆里的Person对象地址值赋值给main方法栈帧中的Person变量</li>
<li>main方法结束 main方法栈帧出栈</li>
</ul>
<p>堆里面都有初始值，基本类型为 0 引用类型为 null</p>
<ul>
<li>byte short int 0</li>
<li>long 0L</li>
<li>float 0.0f</li>
<li>double 0.0d</li>
<li>char ‘/u0000’  空值，打印为空格</li>
<li>boolean false</li>
</ul>
<p>基本数据类型：<br>    只有一块存储空间，在栈中，存放的是具体的值<br>引用数据类型：<br>    引用数据类型有两块存储空间：一个在栈（Stack）中，一个在堆（heap）中<br>    5种引用类型：类、接口、数组、枚举、注解</p>
<p>基本数据类型：值传递<br>引用数据类型：地址传递</p>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>匿名对象：创建一个对象，没有把它赋值给任何一个变量，匿名对象只能使用一次<br>一个对象没有任何人指向时，就会成为垃圾，等待垃圾回收器回收</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器：在创建对象时，自动调用的方法</p>
<ol>
<li>和类名相同</li>
<li>不能定义返回值类型</li>
<li>不能returen（实际上返回的是创建对象的地址）<br>默认构造器是无参构造，如果类用public修饰，默认构造器也用public修饰</li>
</ol>
<p>自己定义了构造器，编译器就不会帮你再生成构造器（需要无参构造就要自己写）</p>
<p>构造器重载：和方法重载一样，方法名相同，参数不一样</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>在字段和方法前添加了static，那么这个字段或方法它<strong>就属于类</strong><br>状态和行为有： <strong>类和对象之分</strong></p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="center">状态</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">对象</td>
<td align="center">姓名</td>
<td align="left">死亡</td>
</tr>
<tr>
<td align="left">类</td>
<td align="center">人口总数</td>
<td align="left">毁灭</td>
</tr>
</tbody></table>
<ol>
<li>static修饰的内容随类的加载而加载，JVM把字节码加载到虚拟机中，static修饰的成员自动被加载到方法区</li>
<li><strong>static修饰的内容优先于对象</strong></li>
<li>static修饰的内容该类所有对象共享</li>
<li>static修饰的内容可以通过类名调用(可以通过对象名调用，但编译了本质还是用类名调用)</li>
</ol>
<p><strong>类成员</strong>：static修饰的成员<br><strong>实例成员</strong>：非static修饰的成员</p>
<p>在static方法中只能调用static成员：例如main方法调用的方法就必须是是static方法<br>非static方法可以访问静态成员也可以访问非静态成员：static</p>
<p>运行：加载class字节码文件，加载static成员（变量、方法）到方法区</p>
<p>static成员，被所有对象共享时，节省空间，没必须每个对象都存储一份，可以直接使用类名调用，生命周期长，虚拟机停止才消失</p>
<p>总结：<br>static的作用就是方便在不创建对象的情况下，进行调用方法或变量<br>static方法不能调用非static成员，因为非static成员必须依赖具体对象才能被调用</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><ol>
<li>成员变量：直接定义在类中的变量(也称全局变量或字段，不能称为属性)</li>
</ol>
<ul>
<li>类成员变量：static修饰的成员变量</li>
<li>实例成员变量：没有static修饰的成员变量，注意：在方法当中不能定义static变量</li>
</ul>
<p><strong>有初始值，可以直接用</strong></p>
<ol>
<li>局部变量：定义在方法当中的变量（方法的参数，和内部定的变量,代码块）</li>
</ol>
<p><strong>必须初始化才能用</strong></p>
<p><img src="/2019/12/25/java-note-2/1.png" alt="高新强"></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://study.163.com/course/introduction/1005537028.htm" target="_blank" rel="noopener">Java零基础到高级JavaEE就业实战</a><br><a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a><br><a href="https://www.jianshu.com/p/68ddb5484ca2" target="_blank" rel="noopener">什么是多态？实现多态的机制是什么？</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p>
</section>
    

    <footer id="post-meta" class="clearfix">
        <a href="/about/">
        <img class="avatar" src="/images/avatar.jpg">
        <div>
            <span class="dark">Aaron Lin</span>
            <span></span>
        </div>
        </a>
        <section id="sharing">
            <a title="Share to Twitter" class="twitter" href="https://twitter.com/intent/tweet?text=https://aaronlinv.github.io/2019/12/25/java-note-2/ - Java笔记-面向对象 @" target="_blank" rel="noopener"><span class="icon-twitter">tweet</span></a>
            <a title="Share to Facebook" class="facebook" href="#" onclick="
                window.open(
                  'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
                  'facebook-share-dialog',
                  'width=626,height=436');
                return false;"><span class="icon-facebook-sign">Share</span>
            </a>
        </section>
    </footer>


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">加载评论</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            id: "Java笔记-面向对象",
          
            owner: "",
            repo: "",
            oauth: {
              client_id: "",
              client_secret: "",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


	<footer id="footer">
    <div id="social">
        <p class="small">©
            Aaron Lin | Powered by Hexo &
                <a href="https://github.com/F0r3at/Lights" target="_blank" rel="noopener"> Lights</a>
        </p>
    </div>
</footer>
</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
		InstantClick.init('mousedown');
	</script>



